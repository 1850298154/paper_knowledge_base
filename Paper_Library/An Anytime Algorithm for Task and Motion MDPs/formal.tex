\section{Formal Framework}
\label{sec:formal}
Let $X$ be a set of states and $S$ a set of abstract states. We define
a \textbf{state abstraction} as a surjective function $\alpha:
X\rightarrow S$. We focus on \emph{predicate
  abstractions}, where the abstraction function effectively projects
the state space into a space without a specified set of
predicates. Given a set of predicates $\mathcal{P}$ that are retained
by a predicate abstraction, the states of the abstract state space
are equivalence classes defined by the equivalence relation $s_1 \sim
s_2$ iff $s_1$ and $s_2$ agree on the valuations of every 
predicate in $\mathcal{P}$, grounded using the objects in the problem. 

For any $s\in S$, the \emph{concretization
  function} $\gamma_\alpha(s) = \set{x\in X: \alpha(x)=s}$ denotes the
set of concrete states \emph{represented by the abstract state}
$s$. For a set $C\subseteq X$, $[C]_\alpha$ denotes the smallest set
of abstract states representing $C$. Generating the complete
concretization of an abstract state can be computationally
intractable, especially in cases where the concrete state space is
continuous and the abstract state space is discrete. In such
situations, the concretization operation can be implemented as a
\emph{generator} that incrementally computes or samples elements
from an abstract state's concretization.
	



%% A \textbf{deterministic transition system} $T\tuple{X, A}$ consists of
%% a set of states $X$ and a set of actions $A$, where each $a\in A$ is a
%% function from $X$ to $X$. We denote the sound abstraction of an action
%% $a\in A$ w.r.t an abstraction function $\alpha$ as $[a]_\alpha$. For
%% any abstract state $s \in S$, $[a]_\alpha(s) = [\set{a(c) : c \in
%%     s}]_\alpha$ (the proof of soundness follows from the concept of
%% model-theoretic, or semantic, entailment). Given an abstraction
%% function $\alpha$, the \textbf{sound abstraction of a transition
%%   system} $T = \tuple{X, A}$ \textbf{w.r.t. $\alpha$} is derived as
%% $[T]_\alpha = \tuple{[X]_\alpha,\set{[a]_\alpha : a \in A}}$.  We will
%% drop the subscript $\alpha$ unless it is not clear from the context.
%% The problem of SDM in this terminology is to compute a concrete
%% solution plan in $T$. $T$ and $[T]$ may require different classes of
%% solution algorithms. E.g., $[T]$ may require MDP solvers and $T$ may
%% require motion planners.
	
\textbf{Action abstraction functions} can be defined similarly. The
main form of an action abstraction function is to drop action
arguments, which leads to predicate abstractions to eliminate all
predicates that used the dropped arguments in the action's
description. This process can also model non-recursive temporal
abstractions since a macro or a high-level action with multiple
implementations~\citep{marthi07_angelic} can be modeled as an action whose arguments include
the arguments of its possible implementations as well as an auxiliary
argument for selecting the implementation. The concretization
  of an action abstraction function is the set of actions
corresponding to different instantiations of the dropped action
arguments. Concretization functions for action abstraction functions
can also be implemented as generators.

Formally, the concretization of each high-level action corresponds to a set of motion planning problems. We will use the notation $a(x_1\mapsto o_1)$ to denote a grounded action, whose $x_1$ argument has been instantiated with the element $o_1$ defined by the underlying MDP problem (Sec.\,\ref{sec:background}). Let $a(\bar{x}, \bar{y})$ be a concrete action where $\bar{x}$ ($\bar{y}$) are ordered, typed discrete (continuous) arguments. The \emph{concretization of the instantiated abstract action} $\gamma([a](\bar{x}\mapsto \bar{o}))$ is the set of actions $\set{a(\bar{x}\mapsto \bar{o}, \bar{y}\mapsto \bar{o'}): \bar{o'} \emph{ is a tuple of elements with types and arity specified by  } y}$. Predicates in action preconditions specify the constraints that these arguments need to satisfy. Common examples for continuous arguments include robot poses and motion plans;  predicates about them may include \emph{collisionFree($tr$)}, which is true exactly when the trajectory $tr$ has no collisions as well as \emph{inspects} (Eg.~\ref{eg:inspect_concrete}). 


Both state and action abstractions affect the transition function of
the MDP. The actual transition probabilities of an abstract MDP depend
on the policy being used and are therefore difficult to estimate
accurately~\citep{bai16_markovian,li06_abstractMDP,singh95_abstractRL}. In
this paper, we will use an optimistic estimate of the true transition
probabilities when expressing the abstract MDP. Such estimates are
related to upper bounds for reachability used in prior
approaches for
reasoning in the presence of hierarchical abstractions~(e.g., \citep{marthi07_angelic,haddawy96_drips}).

\begin{example}

Consider the action presented in Eg.\,\ref{eg:inspect_concrete}
Such actions are difficult to plan with however, since the $tr$
argument is a high-dimensional real-valued vector. We can abstract
away this argument to construct the following abstraction:

        \begin{small}
                \begin{tabular}{r|p{4in}}\multicolumn{2}{p{4in}}
                  {Action:
                    \emph{[inspect](Structure $s$)}}\\
                  precond & $\emph{batterySufficient}$\\
                  effect & \emph{faultLocated}$(s) \qquad 0.8$ \\
                  & $\lnot$\emph{faultLocated}$(s) \qquad 0.2$ \\
                  & $\?$\{\emph{batteryLevel, batterySufficient}\}
                \end{tabular}
        \end{small}


Dropping the $tr$ argument from each predicate that results in
abstract predicates of lower arities. The zero-arity
\emph{batterySufficient} becomes a Boolean state variable and
\emph{batteryLevel} becomes a numeric variable. The symbol $\?$
indicates that this action affects the predicates \emph{batteryLevel}
and \emph{batterySufficient}, but its effects on these predicates
cannot be determined due to abstraction.

An optimistic representation of this abstract action would state that
it does not reduce \emph{batteryLevel} and consequently, does
not make \emph{batterySufficient} false.
\end{example}

This approach for abstraction is computationally better than a high-level representation that discretizes the continuous variables, as it does not require the addition of constants representing discrete pose or trajectory names to the vocabulary. This is desirable because the size of the state space would be exponential in the number of such discretized values that are included.
