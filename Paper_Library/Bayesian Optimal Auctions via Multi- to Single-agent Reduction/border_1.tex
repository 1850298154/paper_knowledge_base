
\subsection{Single Unit Feasibility Constraints}
\label{sec:border_1}%


In this section, we consider environments where at most one agent can be allocated to. For such environments, we characterize
interim feasibility as implementability via a particular, simple {\em stochastic sequential allocation} mechanism. Importantly,
the parameters of this mechanism are easy to optimize efficiently.

A stochastic sequential allocation mechanism is parameterized by a stochastic transition table.  Such a table specifies the
probability by which an agent with a given type can steal a token from a preceding agent with a given type.  For simplicity in
describing the process we will assume the token starts under the possession of a ``dummy agent'' indexed by 0; the agents are
then considered in the arbitrary order from 1 to $n$; and the agent with the token at the end of the process is the one that is
allocated (or none are allocated if the dummy agent retains the token).

\begin{definition}[stochastic sequential allocation mechanism]
\label{def:ssa}%
Parameterized by a stochastic transition table $\SeqTable$, the {\em stochastic sequential allocation mechanism (SSA)} computes
the allocations for a type profile $\types \in \TypeSpaces$ as follows:
\begin{enumerate}
\item Give the token to the dummy agent $0$ with dummy type $\type_0$.
\item For each agent $i$: (in order of $1$ to $n$)

If agent $i'$ has the token, transfer the token to
agent $i$ with probability $\pi(\type_{i'},\type_i)$.

\item Allocate to the agent who has the token (or none if the
  dummy agent has it).
\end{enumerate}
\end{definition}


%
%\Xcomment{
%
%
%
%In this section we present a computationally tractable allocation
%oracle that can implement any jointly feasible collection of interim
%allocation rules. Furthermore, we show that the space of all jointly
%feasible interim allocation rules can be specified by a small number
%of linear constraints in a higher dimensional space, thereby obviating
%the need for a separation oracle for solving optimization problems
%over this space.
%
%An allocation oracle takes as its input a profile of types
%$\Types=(\Type_1,\ldots, \Type_n)$ reported by the agents, and returns
%as its output a winner from the set $\{0, \cdots, n\}$, ($0$ means no
%winner). For each $i \in [n]$, agent~$i$ reports each type $\Type_i
%\in \TypeSpace_i$ with probability $\DistProb_i(\Type_i)$
%independently of other agents. An allocation oracle implements an
%interim allocation rule $\InAlloc_i \in [0,1]^{\TypeSpace_i}$, for
%agent~$i$, if{f} the expected probability of winning for agent $i$
%conditioned on reporting type $\Type_i \in \TypeSpace_i$ is exactly
%$\InAlloc_i(\Type_i)$, where the expectation is taken over the random
%reports of other agents and the random choices of the oracle. A
%profile of interim allocation rules $\InAllocs=(\InAlloc_1,\cdots,
%\InAlloc_n)$ is feasible if{f} it can be implemented by some
%allocation oracle. $\InAllocSpace$ denotes the space of all feasible
%profiles of interim allocation rules.
%
%We present an allocation oracle which is parameterized by a
%pre-computed stochastic transition table $\SeqTable \in
%[0,1]^{\NumTypes\times \NumTypes}$ where $\NumTypes = \sum_{i=0}^n
%\abs{T_i}$. We show that any feasible profile of interim allocation
%rules can be implemented by this oracle by using the appropriate
%choice of $\SeqTable$. More importantly, for any choice of
%$\SeqTable$, the profile of interim allocation rules produced by this
%oracle can be computed from $\SeqTable$ using a dynamic program which
%can be specified by $O(\NumTypes^2)$ linear equations. The space of
%all feasible $\SeqTable$ is a $\NumTypes^2$-dimensional unit
%hyper-cube and the linear equations of the dynamic program define a
%projection of this hyper-cube to the $\NumTypes$-dimensional space of
%all feasible profiles of interim allocation rules
%$\InAllocSpace$. Consequently, $\InAllocSpace$ can be specified using
%only $O(\NumTypes^2)$ variables and linear constraints. Furthermore,
%solving the optimization problem over this higher dimensional space
%immediately gives us an appropriate choice of $\SeqTable$ which can be
%used with the oracle to implement the desired interim allocation
%rules.
%
%The oracle uses an algorithm called \emph{stochastic sequential
%  allocation (SSA)} (see algorithm~\ref{alg:seq_alloc}) which can be
%described as a token passing process. We introduce a dummy agent~$0$
%whose type space is a singleton set $T_0$. A token, initially given to
%the dummy agent~$0$, is randomly passed from one agent to another in a
%certain order by certain precomputed probabilities, and the agent who
%holds the token at the end is picked as the winner (no winner if the
%token is held by the dummy agent). More precisely, the algorithm
%visits the agents one by one\footnote{The ordering is arbitrary, but
%  it should be fixed in advance.} from $1$ to $n$; upon visiting each
%agent~$i'$ if the token is held by agent~$i$, it is passed to agent
%$i'$ with probability $\SeqTable(\Type_i, \Type_{i'})$, where
%$\Types=(\Type_0, \cdots, \Type_n)$ is the profile of types reported
%by the agents\footnote{We assume $t_0$ is the singleton type of the
%  dummy agent.}, $\SeqTable \in [0,1]^{\UnionTypeSpace\times
%\UnionTypeSpace}$ is a precomputed stochastic transition table,
%$\UnionTypeSpace = \bigcup_{i \in \Agents} \TypeSpace_i$, and
%$\Agents=\{0,\cdots,n\}$. We assume that the types of each agent are
%labeled with the name of that agent so that the type spaces are
%disjoint, i.e., $\UnionTypeSpace$ has a distinct element for each type
%of each agent.
%
%\begin{algorithm}
%\textbf{Input:} A profile of types $\Types \in \times_{i=0}^n \TypeSpace_i$, a stochastic transition table $\SeqTable \in [0,1]^{\UnionTypeSpace\times \UnionTypeSpace}$.\\
%\textbf{Output:} The index of the winner (or $0$ if no winner)
%\begin{algorithmic}[1]
%    \STATE Set $i \leftarrow 0$, i.e., tentatively give the token to the dummy agent.
%    \FOR{$i'=1$ to $n$}
%        \STATE Choose $Z$ uniformly at random from $[0,1]$.
%        \IF{$Z \le \SeqTable(\Type_{i}, \Type_{i'})$}
%            \STATE Set $i \leftarrow i'$, i.e., pass the token to agent $i'$.
%        \ENDIF
%    \ENDFOR
%    \MyRETURN $i$.
%\end{algorithmic}
%\caption{\textsc{StochasticSequentialAllocation}$(\Types, \SeqTable)$ \label{alg:seq_alloc}}
%\end{algorithm}
%}

First, we present a dynamic program, in the form of a collection of linear equations, for calculating the interim allocation rule
implemented by SSA for a given $\SeqTable$. Let $\SeqAlloc(\Type_{i'},i)$ denote the ex-ante probability of the event that
agent~$i'$ has type $\Type_{i'}$ and is holding the token at the end of iteration $i$. Let $\SeqTrans(\Type_{i'}, \Type_{i})$
denote the ex-ante probability in iteration $i$ of SSA that agent~$i$ has type~$\Type_i$ and takes the token from agent~$i'$ who
has type $\Type_{i'}$.


The following additional notation will be useful in this section.  For any subset of agents $\AgentSubset \subseteq \Agents =
\{1,\ldots, n\}$, we define $\TypeSpace_\AgentSubset = \bigcup_{i \in
  \AgentSubset} \TypeSpace_i$ (Recall that without loss of generality
agent type spaces are assumed to be disjoint.).  The shorthand notation $\Type_i \in \TypeSubset$ for $\TypeSubset \subseteq
\UnionTypeSpace$ will be used to quantify over all types in $\TypeSubset$ and their corresponding agents (i.e., $\forall \Type_i
\in \TypeSubset$ is equivalent to $\forall i \in \Agents, \forall \Type_i \in \TypeSubset\cap \TypeSpace_i$).

The normalized interim allocation rule $\PreAlloc$ resulting from the
SSA is exactly given by the dynamic program specified by the following
linear equations.

\newcounter{SeqCounter}
\newcommand{\SeqTag}{{\protect\stepcounter{SeqCounter}$\SeqAllocSpace$.\arabic{SeqCounter}}}

\begin{align}
    \SeqAlloc(\Type_0,0) & = 1, &
        & \tag{\SeqTag} \label{eq:seq_alloc0} \\
    \SeqAlloc(\Type_i,i) &= \sum_{\Type_{i'} \in \TypeSpace_{\Range{0}{i-1}}} \SeqTrans(\Type_{i'},\Type_i), &
        & \forall \Type_i \in \TypeSpace_{\Range{1}{n}}  \tag{\SeqTag} \label{eq:seq_alloc_self} \\
    \SeqAlloc(\Type_{i'},i) &= \SeqAlloc(\Type_{i'}, i-1) - \sum_{\Type_{i} \in \TypeSpace_{i}} \SeqTrans(\Type_{i'}, \Type_{i}), &
        & \forall i \in \Range{1}{n}, \forall \Type_{i'} \in \TypeSpace_{\Range{0}{i-1}} \tag{\SeqTag} \label{eq:seq_alloc}  \\
    \SeqTrans(\Type_{i'}, \Type_{i}) &= \SeqAlloc(\Type_{i'}, i-1) \SeqTable(\Type_{i'}, \Type_{i}) \DistProb_{i}(\Type_{i}), &
        & \forall \Type_{i} \in \TypeSpace_{\Range{1}{n}}, \forall \Type_{i'} \in \TypeSpace_{\Range{0}{i-1}} \tag{$\pi$}
        \label{eq:seq_pi} \\
    \PreAlloc(\Type_i) &=\SeqAlloc(\Type_i,n), &
        & \forall \Type_i \in \TypeSpace_{\Range{1}{n}} \notag %\tag{\SeqTag} \label{eq:seq_inter} \\
\intertext{Note that $\SeqTable$ is the only adjustable parameter in the SSA algorithm, so by relaxing the equation
\eqref{eq:seq_pi} and replacing it with the following inequality we can specify all possible dynamics of the SSA algorithm. }
    0 \le \SeqTrans(\Type_{i'}, \Type_{i}) &\le \SeqAlloc(\Type_{i'}, i-1) \DistProb_{i}(\Type_{i}), &
        & \forall \Type_{i} \in \TypeSpace_{\Range{1}{n}}, \forall \Type_{i'} \in \TypeSpace_{\Range{0}{i-1}} \tag{\SeqTag} \label{eq:seq_last}
\end{align}

Let $\SeqAllocSpace$ denote the convex polytope captured by the \arabic{SeqCounter}~sets of linear constraints
\eqref{eq:seq_alloc0} through \eqref{eq:seq_last} above, i.e., $(\SeqAllocs, \SeqTranses) \in \SeqAllocSpace$ if{f} $\SeqAllocs$
and $\SeqTranses$ satisfy the aforementioned constraints. Note that every $(\SeqAllocs, \SeqTranses) \in \SeqAllocSpace$
corresponds to some stochastic transition table $\SeqTable$ by solving equation~\eqref{eq:seq_pi} for
$\SeqTable(\type_i,\type_{i'})$. We show that $\SeqAllocSpace$ captures all feasible normalized interim allocation rules, i.e.,
the projection of $\SeqAllocSpace$ on $\PreAlloc(\cdot)=\SeqAllocs(\cdot, n)$ is exactly $\PreAllocSpace$, as formally stated by
the following theorem.

\begin{theorem}
\label{thm:seq_alloc}%
A normalized interim allocation rule $\PreAlloc$ is feasible if and only if it can be implemented by the SSA algorithm for some
choice of stochastic transition table $\SeqTable$. In other words, $\PreAlloc \in \PreAllocSpace$ if{f} there exists
$(\SeqAllocs, \SeqTranses) \in \SeqAllocSpace$ such that $\PreAlloc(\Type_i)=\SeqAllocs(\Type_i, n)$ for all $\Type_i \in
\UnionTypeSpace$.
\end{theorem}

\begin{corollary}
Given a blackbox for each agent~$i$ that solves for the optimal expected revenue $\Rev_i(\InAlloc_i)$ for any feasible interim
allocation rule $\InAllocs$, the optimal interim allocation rule can be computed by the following convex program which is of
quadratic size in the total number of types.
\begin{alignat*}{3}
    \text{maximize}     &\qquad& & \sum_{i=1}^n \Rev_i(\InAlloc_i) & \qquad & \\
    \text{subject to}   && & \SeqAllocs(\Type_i, n) = \PreAlloc(\Type_i) = \InAlloc_i(\Type_i) \DistProb_i(\Type_i),&
                            &\forall \Type_i \in \UnionTypeSpace\\
                        && & (\SeqAllocs, \SeqTranses) \in \SeqAllocSpace.
\end{alignat*}
Furthermore, given an optimal assignment for this program, the computed interim allocation rule can be implemented by SSA using
the the stochastic transition table defined by:\footnote{If the denominator is
  zero, i.e., $\SeqAlloc(\Type_i, i'-1)=0$, we can set
  $\SeqTable(\Type_i, \Type_{i'})$ to an arbitrary value in $[0,1]$.}
\begin{align*}
    \SeqTable(\Type_{i'}, \Type_{i}) &= \frac{\SeqTrans(\Type_{i'}, \Type_{i})}{\SeqAlloc(\Type_{i'}, i-1) \DistProb_{i}(\Type_{i})}, &
        & \forall \Type_{i} \in \TypeSpace_{\Range{1}{n}}, \forall \Type_{i'} \in \TypeSpace_{\Range{0}{i-1}}.
\end{align*}
\end{corollary}

Next, we present a few definitions and lemmas that are used in the
proof of \autoref{thm:seq_alloc}.  Two transition tables $\SeqTable$
and $\SeqTable'$ are considered \emph{equivalent} if their induced
normalized interim allocation rules for SSA are equal.  Type $\Type_i$
is called \emph{degenerate} for $\SeqTable$ if in the execution of SSA
the token is sometimes passed to type $\Type_i$ but it is always taken
away from $\Type_i$ later, i.e., if $\SeqAllocs(\Type_i,i) > 0$ but
$\SeqAllocs(\Type_i,n) = 0$.  The stochastic transition table
$\SeqTable$ is degenerate if there is a degenerate type. For
$\SeqTable$, type $\Type_i$ is {\em augmentable} if there exists a
$\SeqTable'$ (with a corresponding $\SeqAllocs'$) which is
\emph{equivalent} to $\SeqTable$ for all types expect $\Type_i$ and
has $\SeqAllocs(\Type_i,n) > \SeqAllocs'(\Type_i,n)$.\footnote{We
  define $\Type_0$ to be augmentable unless the dummy agent never
  retains the token in which case all agents are non-augmentable (and
  for technical reasons we declare the dummy agent to be
  non-augmentable as well).}

\begin{lemma}
\label{lem:degen}%
For any stochastic transition table $\SeqTable$ there exists an equivalent $\SeqTable'$ that is non-degenerate.
%For any given $(\InAllocs,\SeqAllocs,\SeqTranses) \in \SeqAllocSpace$
%there always exists $\SeqAllocs'$ and $\SeqTranses'$ such that
%$(\InAllocs,\SeqAllocs',\SeqTranses') \in \SeqAllocSpace$ is
%non-degenerate.
\end{lemma}


\begin{lemma}
\label{lem:aug}%
For any non-degenerate stochastic transition table $\SeqTable$, any
non-augmentable type $\Type_{i}$ always wins against any augmentable
type $\Type_{i'}$.
%In the
%token passing process corresponding to a non-degenerate
%$(\InAllocs,\SeqAllocs,\SeqTranses) \in \SeqAllocSpace$, any
%non-augmentable type always wins against any augmentable type. I.e.,
%$\SeqTable$ corresponding to $(\InAllocs,\SeqAllocs,\SeqTranses)$
%satisfies
I.e.,
\begin{itemize}
\item if $i' < i$ and $\Type_{i'}$ has non-zero probability of holding
  the token then $\SeqTable(\Type_{i'}, \Type_{i})=1$, i.e.,
  $\Type_{i}$ always takes the token away from $\Type_{i'}$, and
\item if $i < i'$ and $\Type_{i}$ has non-zero probability of holding
  the token then $\SeqTable(\Type_{i}, \Type_{i'})=0$, i.e.,
  $\Type_{i'}$ never takes the token away from $\Type_{i}$.
\end{itemize}
\end{lemma}

It is possible to view the token passing in stochastic sequential allocation as a network flow.  From this perspective, the
augmentable and non-augmentable types form a minimum-cut and \autoref{lem:aug} states that the token must eventually flow from
the augmentable to non-augmentable types.  We defer the proof of this lemma to Appendix~\ref{app:border_1} where the main difficulty
in its proof is that the edges in the relevant flow problem have dynamic(non-constant) capacities.


\begin{proof}[Proof of Theorem~\ref{thm:seq_alloc}]
Any normalized interim allocation rule that can be implemented by the SSA algorithm is obviously feasible, so we only need to
prove the opposite direction. The proof is by contradiction, i.e., given a normalized interim allocation rule $\PreAlloc$ we show
that if there is no $(\SeqAllocs, \SeqTranses) \in \SeqAllocSpace$ such that $\PreAlloc(\cdot)=\SeqAllocs(\cdot, n)$, then
$\PreAlloc$ must be infeasible. Consider the following linear program for a given $\PreAlloc$ (i.e., $\PreAlloc$ is constant).
\begin{alignat*}{3}
    \text{maximize}     & \qquad    & &\sum_{\Type_{i} \in \TypeSpace_{\Range{1}{n}}} \SeqAllocs(\Type_{i}, n) & \qquad & \\
    \text{subject to}   &           & &\SeqAllocs(\Type_{i}, n) \le \PreAlloc(\Type_{i}), & &\forall \Type_{i} \in \TypeSpace_{\Range{1}{n}} \\
                        &           & &(\SeqAllocs, \SeqTrans) \in \SeqAllocSpace.
\end{alignat*}

Let $(\SeqAllocs, \SeqTrans)$ be an optimal assignment of this LP. If the first set of inequalities are all tight (i.e.,
$\PreAlloc(\cdot)=\SeqAllocs(\cdot, n)$) then $\PreAlloc$ can be implemented by the SSA, so by contradiction there must exists a
type $\NonAugType \in \UnionTypeSpace$ for which the inequality is not tight. Note that $\NonAugType$ cannot be augmentable
--- otherwise, by the definition of augmentability, the objective of the LP could be improved. Partition
$\TypeSpace_\Agents$ to augmentable types $\TypeSpace^+_\Agents$ and non-augmentable types $\TypeSpace^-_\Agents$. Note that
$\TypeSpace^-_\Agents$ is non-empty because $\NonAugType \in \TypeSpace^-_\Agents$. Without loss of generality, by
\autoref{lem:degen} we may assume that $(\SeqAllocs, \SeqTrans)$ is non-degenerate.\footnote{By \autoref{lem:degen}, there exits
an non-degenerate assignment with the same objective value.}

An agent wins if she holds the token at the end of the SSA algorithm. The ex ante probability that some agent with
non-augmentable type wins is $\sum_{\Type_i \in \TypeSpace^-_\Agents} \SeqAlloc(\Type_i, n)$. On the other hand,
\autoref{lem:aug} implies that the first (in the order agents are considered by SSA) agent with non-augmentable type will take
the token from her predecessors and, while she may lose the token to another non-augmentable type, the token will not be
relinquished to any augmentable type.  Therefore, the probability that an agent with a non-augmentable type is the winner is
exactly equal to the probability that at least one such agent exists, therefore
\begin{align*}
    \Prx[\Types \sim \DistProbs]{\exists i : \Type_{i} \in \TypeSpace^-_\Agents}
        &= \sum_{\Type_{i} \in \TypeSpace^-_\Agents} \SeqAlloc(\Type_{i}, n)
        < \sum_{\Type_{i} \in \TypeSpace^-_\Agents} \PreAlloc(\Type_{i}).
\end{align*}
The second inequality follows from the assumption above that $\NonAugType$ satisfies $\SeqAlloc(\NonAugType, n) <
\PreAlloc(\NonAugType)$. We conclude that $\PreAlloc$ requires an agent with non-augmentable type to win more frequently than
such an agent exists, which is a contradiction to interim feasibility of $\PreAlloc$.
\end{proof}

The contradiction that we derived in the proof of \autoref{thm:seq_alloc} yields a necessary and sufficient condition, as
formally stated in the following corollary, for feasibility of any given normalized interim allocation rule.
\begin{corollary}
\label{cor:1cons}%
A normalized interim allocation rule $\PreAlloc$ is feasible if and only if
\begin{align}
    \sum_{\TypeVar \in \TypeSubset} \PreAlloc(\TypeVar)  & \le \Prx[\Types \sim \DistProbs]{\exists i: \Type_i \in \TypeSubset}, &
        & \forall \TypeSubset \subseteq \UnionTypeSpace \tag{MRMB} \label{eq:MRMB}
\end{align}
\end{corollary}

The necessity of condition \eqref{eq:MRMB} is trivial and its sufficiency was previously proved by \citet{B91}. This condition
implies that the space of all feasible normalized interim allocation rules, $\PreAllocSpace$, can be specified by $2^\NumTypes$
linear constraints on $\NumTypes$-dimensional vectors $\PreAlloc$. An important consequence of \autoref{thm:seq_alloc} is that
$\PreAllocSpace$ can equivalently be formulated by only $O(\NumTypes^2)$ variables and  $O(\NumTypes^2)$ linear constraints as a
projection of $\SeqAllocSpace$, therefore any optimization problem over $\PreAllocSpace$ can equivalently be solved over
$\SeqAllocSpace$.
