\documentclass{ifacconf}

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

% Needed to meet printer requirements.

%In case you encounter the following error:
%Error 1010 The PDF file may be corrupt (unable to open PDF file) OR
%Error 1000 An error occurred while parsing a contents stream. Unable to analyze the PDF file.
%This is a known problem with pdfLaTeX conversion filter. The file cannot be opened with acrobat reader
%Please use one of the alternatives below to circumvent this error by uncommenting one or the other
%\pdfobjcompresslevel=0
%\pdfminorversion=4

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% The following packages can be found on http:\\www.ctan.org

\makeatletter
\let\old@ssect\@ssect % Store how ifacconf defines \@ssect
\makeatother
\usepackage{optidef}
\usepackage{graphics} % for pdf, bitmapped graphics files
\usepackage{times} % assumes new font selection scheme installed
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb}  % assumes amsmath package installed
\usepackage[hidelinks]{hyperref}
\usepackage[printonlyused]{acronym}
\usepackage{nomencl}
\usepackage{mathrsfs}
\usepackage[caption=false,font=footnotesize]{subfig}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\usepackage{makecell}
\usepackage{longtable}
%\usepackage{citep}
\usepackage{graphicx}      % include this line if your document contains figures
\usepackage{natbib}        % required for bibliography}
%\usepackage{draftwatermark}
%\SetWatermarkText{DRAFT}
%\SetWatermarkScale{1.5}

\makeatletter
\def\@ssect#1#2#3#4#5#6{%
  \NR@gettitle{#6}% Insert key \nameref title grab
  \old@ssect{#1}{#2}{#3}{#4}{#5}{#6}% Restore ifacconf's \@ssect
}
\makeatother

\begin{document}
\begin{frontmatter}

\title{Continuous-Time Trajectory Optimization for Decentralized Multi-Robot Navigation}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%

\author{Shravan Krishnan,}
\author{Govind Aadithya Rajagopalan,} 
\author{Sivanathan Kandhasamy}
\author{and Madhavan Shanmugavel}
        % <-this % stops a space
\address{Autonomous Systems Lab, Department of Mechatronics, SRM Institute of Science and Technology, India, e-mail: shravan\_krishnan@srmuniv.edu.in }
%\address[Second]{}
%\address[third]{Autonomous Systems Lab, SRM Institute of Science and Technology, India (e-mail: author@snu.ac.kr)}
   
%\thanks[sponsorship]{This work was funded by SRM Institute of Science and Technology, India }

%\thanks{Corresponding Author: Shravan Krishnan, shravan\_krishnan@srmuniv.edu.in}


%\maketitle

\begin{abstract}
Multi-robot systems have begun to permeate into a variety of different fields, but collision-free navigation in a decentralized manner is still an arduous task. Typically, the navigation of high speed multi-robot systems demands replanning of trajectories to avoid collisions with one another. This paper presents an online replanning algorithm for trajectory optimization in labeled multi-robot scenarios. With reliable communication of states among robots, each robot predicts a smooth continuous-time trajectory for every other remaining robots. Based on the knowledge of these predicted trajectories, each robot then plans a collision-free trajectory for itself. The collision-free trajectory optimization problem is cast as a non linear program (NLP) by exploiting polynomial based trajectory generation. The algorithm was tested in simulations on Gazebo with aerial robots. 
\end{abstract}

\begin{keyword}
Trajectory Planning, Optimal Control, Multi-Robot Systems
\end{keyword}

\end{frontmatter}

\section{Introduction}
Multi-robotics is currently an emerging field with numerous applications and potential in several cross-cutting fields. However, the navigation of a group of robots in complex environments is still a daunting task. In such scenarios, it is essential that every robot is able to autonomously plan collision-free trajectory while also making sure that it replans the generated trajectory appropriately based on the dynamic nature of environment. In this paper, We present a decentralized multi-robot trajectory optimization algorithm which accepts only current states and non-interchangeable end poses of other robots as inputs and generates smooth trajectories. The algorithm exploits the differential flatness property of the robots  \citep{mellinger2011minimum} \citep{chul2010}; a property  that allows planning of trajectories in the space of flat variables and their derivatives.  

Trajectory generation for a fleet of robots has received wide spread attention recently. A plethora of different solutions have been proposed to solve this problem. However, a majority of them are centralized methods \citep{tang2018hold}\citep{Solovey2016finding}. Centralized methods have recently branched into decentralized methods that are capable of planning trajectories appropriately in a decentralized manner \citep{Bekris2017Safe} \citep{2017fast}. These approaches with exception of \citep{tang2018hold}(which is also centralized) are discrete-time and provide the robots with discrete commands and thereby overlook probable collisions. Moreover, discrete approaches are sampling based \citep{Solovey2016finding}\citep{Bekris2017Safe} or search based \citep{fan} that incrementally look through the space. 

An another class of multi-robot algorithms  utilize the concept of velocity obstacles to plan velocities appropriately by formulating admissible velocities that robots can be at without colliding \citep{Berg2008,mora2018cooperative,Jur2011,rufli2013reciprocal,snape2010smooth}. The advantage of such approaches is that they are easily adaptable for decentralized implementations, but restricted to only circular shaped robots. Recently, some extensions have been proposed  that allow their usages for heterogeneous robots \citep{bareiss2017general}. Building on these works, \citep{mora2018cooperative} proposed a collaborative collision avoidance for non-holonomic robots with re-planning, while respecting the vehicular constraints and also accounting for potential tracking error bounds of the robot. They have also proposed an extension of the same to aerial robots in \citep{aerialalonsomora}. 

\begin{figure*}
\centering
\subfloat[][]{\includegraphics[width=0.35\textwidth]{ACDOS/8_hetero.jpeg}\label{maneuver/maneuver1}} 
\hspace{2mm} \subfloat[][]{\includegraphics[width=0.25\textwidth]{ACDOS/10_visual.png}\label{maneuver2}} 
\hspace{2mm} \subfloat[][]{\includegraphics[width=0.3\textwidth]{ACDOS/neo6traj.png}\label{maneuver3}} 
%\hspace{2mm} \subfloat[][]{\includegraphics[width=0.19\textwidth]{maneuver/maneuver4}\label{maneuver4}} 
%\hspace{2mm} \subfloat[][]{\includegraphics[width=0.2\textwidth]{maneuver/maneuver5}\label{maneuver5}} 
%\includegraphics[width=\textwidth]{neo8distance}
\caption{A sequence of images showing robots during different transitions. The red curves are the planned trajectories. A video of the simulations is available at \href{https://bit.ly/2ZpGq76}{https://bit.ly/2ZpGq76}}
\label{differentposes}
\end{figure*}

Recently, a centralized method for generating collision-free trajectories for a swarm of quadrotors in known obstacle filled environments was proposed \citep{honig2018}. The method utilized a three step process with first step for generating sparse roadmaps,  second step for planning discrete schedules and third step for generating bezier curve based time parametrized smooth trajectories. Additionally, the duration of the trajectory is not directly optimized but scaled to satisfy the dynamics of robots. 

%\begin{figure}
%\includegraphics[width=0.5\textwidth]{hetero}
%\caption{Five fireflys and three Neos starting to navigate while avoiding collision using the algorithm presented in this work using RotorS \citep{rotors} }
%\label{fireflyandneo}
%\end{figure}

Methods based upon sequential convex programming have also been proposed for multi-robot systems \citep{chen2015scp}\citep{agualiro2012scp}. However, these methods are centralized and use a discrete approach for planning trajectories. Furthermore, they use only second order dynamics with jerk constrained as rate of change between two subsequent time steps. Nevertheless, the algorithms do not have any dimensional restrictions. Additionally, utilizing such approaches is tractable only if the end times are known or end times are scaled accordingly beforehand.

Barrier functions based methods have been proposed for collision avoidance \citep{safe2017certificate}. Recently, model predictive control based methods have been used for multi-robot collision avoidance \citep{scpmpc}\citep{rob}. \citep{mpcorca}  proposed a Model Predictive Control scheme based on \citep{Jur2011}.


A majority of these methods account for lower order dynamics of the robot and/or do not guarantee a continuous time trajectory that also accounts for collision avoidance in continuous time. Moreover, the algorithms do not consider time as a coupled optimization parameter. 

In this work, a higher order dynamics(three) is used for the robots rather than two which is often found in literature. Additionally, trajectories are generated in continuous-time for multi-robot systems with $M$ different robots rather than sampling based or discrete time methods.% Besides, we propose a method to predict trajectories for other robots in the environment given the desired position and current state.

The major contributions of this paper are:
\begin{enumerate}
\item A closed form solution for generating minimum time-jerk squared smooth trajectories given current state and desired end position.
\item A decentralized algorithm for generating collision-free continuous-time trajectories for multi-robot systems in $N$ dimensions.
\item Extensive simulations of the proposed algorithm using a variety of different aerial robots in three dimensional spaces
\end{enumerate}


 The proposed algorithm involves $MN$ polynomials in each of the $M$ robots. $(M-1)N$ polynomials denote the predicted trajectories of other robots in $N$ dimensions and $N$ polynomials represent the collision-free trajectory. 
 
 Based upon the $MN$ polynomials, a two-step process is used to generate collision-free trajectories. The first step generates the $(M-1)N$ polynomials representing the continuous-time predicted trajectory of other robots in the environment. The second step formulates a non linear optimization problem(NLP) with objectives of minimizing jerk and time while not exceeding the dynamic limits and avoiding collision(with respect to the trajectories from the previous step). The solution of the NLP provides the coefficients of the collision-free trajectory and the duration of the trajectory.

%The proposed algorithm uses two steps with the first step used to predict continuous-time fifth order polynomial based trajectories for other robots from their current position to the desired end position. In the second step, using the predicted trajectories, we formulate a non linear optimization problem by using exponential barrier functions for collision avoidance and dynamic limits while also simultaneously minimizing time and jerk; whose solution provides fifth order polynomial coefficients along with end time of the trajectory. The robots communicate amongst themselves their current state estimates, their desired poses and their sizes.  


Furthermore, replanning of trajectories is done online for two reasons; one, the number of robots may not be known beforehand and two, the trajectory prediction does not account for robot-robot interaction and therefore the predicted trajectory diverges from the planned trajectories of other robots considerably during longer durations. To allow for efficient use of the previous trajectory, the algorithm is implemented in a receding horizon manner, i.e, a part of the trajectory is applied after which the trajectory is re-planned.



The rest of the paper is organized as: Section \ref{prediction} showcases the Trajectory prediction method. Section \ref{traj optimization} details the trajectory optimization problem. Section \ref{results} showcases the performance of the algorithm in simulations and Section \ref{conclusion} concludes the paper



\section{Trajectory Prediction}
\label{prediction}
Knowing the trajectories of other robots in the environment improves the efficiency of the generated trajectory in avoiding collision. In this section, we derive a closed-form solution for efficiently predicting minimum time and jerk smooth trajectories for other robots in the environment. The dynamic limits of other robots are unknown and hence neglected. The trajectory prediction algorithm was inspired by the closed form solutions for efficient trajectory generation for quadcopters shown by \citep{efficient2015quad} and is discussed below.	

Commonly used dynamic models for mobile robots or multirotors are differentially flat. This allows us to formulate the input of those robots as the $n$\textsuperscript{th} derivative of a $n$\textsuperscript{th} order robot. Additionally, The generated trajectory should be represented by at least a $2 n-1$ order polynomial \citep{tang2018hold}.

\subsection{State model}
The robots are modelled as a third order system with state $\textbf{x}=[p \hspace{1mm} v \hspace{1mm} a]$ and input $u=[j]$, where $p$ is position, $v$ is velocity, $a$ is acceleration and $j$ is jerk. Hence, the dynamics is represented as:
\begin{equation}
\dot{\textbf{x}}=[v \hspace{1mm} a \hspace{1mm} j]
\label{dynam}
\end{equation}

\begin{figure*}
    \centering
    \includegraphics[width=0.7\textwidth]{Schematic.png}
    \caption{A schematic explaining the overall system. The white curve indicates the planned trajectory by robot 1 from it's current state $^1x_0$ to it's end state $^1x_f$. Similarly, the black curve indicates the planned trajectory by robot 2 from it's current state $^2x_0$ to it's end state $^2x_f$. The green and red arrows indicate the communication and the data being shared during the communication}
    \label{schematic}
\end{figure*}


\subsection{Objective Function}
The objective of the trajectory prediction is to find smooth and minimum-time trajectory that moves the robot from it's current state to the partially defined end state in  minimal time. The objective can be represented as 
\begin{argmini}
{}{\int_{0}^{T}  \norm{u} ^2 +1 \hspace{1mm} dt}{}{}
\end{argmini}

The objective is coupled only by the end time $T$ in each dimension. This allows looking at each dimension individually. Hence, for the sake of brevity and readability, the trajectory is derived for a single dimension and the dimensions are coupled at end once a closed-form solution for $T$ is found. 

The system represented in Eq.\eqref{dynam} is a linear system. Utilizing Pontygarin's maximum principle \citep{dynamicprogramming}, the system can be solved. We derive the closed form solution for the system with a third order model, which has been used for a variety of classes of robots ranging from multirotors \citep{efficient2015quad} to Autonomous ground vehicles \citep{highspeed}.%\footnote{The derivation of closed form solution for second order and forth order solution is provided in }. 
The Hamiltonian of the third order system is:

\begin{equation}
H(x,\lambda,u)= \norm{u}^2 +1 + \lambda_1v + \lambda_2a + \lambda_3u
\end{equation}

%\begin{figure}
%\includegraphics[width=0.5\textwidth]{prediction_for_two_robot}
%\caption{The optimized trajectory and predicted trajectory in one dimension during a two robot navigation during one planning cycle. Note that the final optimized time has changed when compared to the actually predicted trajectory}
%\label{predicted}
%	\end{figure}


where $\Lambda=[\lambda_1 \hspace{2mm} \lambda_2 \hspace{2mm} \lambda_3]^T$ is the costate equation. The optimal costate equation can be formulated as:
\begin{equation}
\dot{\Lambda}^*(t)=-\frac{\partial H}{\partial x}=-\begin{bmatrix}
0 \\
\lambda_1 \\
\lambda_2 
\end{bmatrix}
\end{equation}

The solution of costate differential equations is then represented as:
\begin{equation}
\Lambda^*(t)=-\begin{bmatrix}
2\beta_1 \\
2\beta_1t+ 2\beta_2 \\
\beta_1t^2+ 2\beta_2t + 2\beta_3
\end{bmatrix}
\label{costatesol}
\end{equation}

The optimal control input can be found by:
\begin{argmini}
{u^*}{H(x^*(t),u^*(t),\Lambda^*(t))}{}{}
\end{argmini}
\begin{equation*}
u^*=-\frac{\lambda_3}{2}=\frac{\beta_1t^2}{2}+ \beta_2t + \beta_3
\end{equation*}

On integrating

\begin{equation}
\begin{split}
p^*(t)&= \frac{\beta_1t^5}{120}+\frac{\beta_2t^4}{24}+\frac{\beta_3t^3}{6}+\frac{a_0t^2}{2}+v_0t+p_0 \\
v^*(t)&=\frac{\beta_1t^4}{24}+\frac{\beta_2t^3}{6}+\frac{\beta_3t^2}{2}+a_0t+v_0 \\
a^*(t)&=\frac{\beta_1t^3}{6}+\frac{\beta_2t^2}{2}+\beta_3t+a_0
\end{split}
\label{optimal_state}
\end{equation}

As the end state is partially defined (only position), the position can be substituted into Eq. \eqref{optimal_state} resulting in 
\begin{equation}
p_{end}= \frac{\beta_1T^5}{120}+\frac{\beta_2T^4}{24}+\frac{\beta_3T^3}{6}+\frac{a_0T^2}{2}+v_0T+p_0 
\end{equation}

 The unknown coefficients can be found as the corresponding costates will be zero at the free endstates\citep{dynamicprogramming}. Thus, from \eqref{costatesol}, the  appropriate equations(second and third) can be used to solve for the three unknown coefficients. This also allows a representation of the unknown coefficients as a function of end time, known initial states and end position. Resulting in:

\begin{equation}
\begin{bmatrix}
\beta_1 \\
\beta_2 \\
\beta_3 \\
\end{bmatrix} = \frac{1}{T^5}\begin{bmatrix}
20 \\
-20T \\
10T^2
\end{bmatrix}(p_{end}-(p_0+v_0T+ \frac{a_0T^2}{a}))
\label{equation}
\end{equation}
Furthermore, due to the time being a variable to optimize, $H(x,\lambda,u)$ of the system is now zero instead of a constant \citep{dynamicprogramming}. Hence,

\begin{equation}
H(x,\lambda,u)= \norm{u}^2 +1 + \lambda_1v + \lambda_1a + \lambda_3u=0
\label{Hamil}
\end{equation}

substituting Eq. \eqref{equation} into Eq. \eqref{Hamil} and simplifying results yields

\begin{equation}
\begin{split}
&\frac{a_0^2T^8}{2}+a_0v_0T^7+(1+a_0(p_{end}-p_0))T^6+(20a_0^2v_0)T^5\\
&+(40a_0v_0+10a_0^2-717a_0^2/4)T^4+40a_0(p_{end}-p_0)T^3\\
&-697a_0v_0T^3+(20a_0(p_{end}-p_0)+20v_0+10a_0v_0)T^2\\
&-717(v_0+p_{end}a_0-a_0p_0)T^2-(1434v_0(p_{end}-p_0)T\\
&-717(p_0^2+p_{end}^2-2p_{end}p_0)
\end{split}
\end{equation}
Similarly, the other dimensions can also be lumped into the coefficients for finding the time. 
This eighth order polynomial can be solved for the roots. This is solved using \citep [p. ~ 146--147]{horn1985cr}, which is implemented in numpy on python\footnote{\href{https://docs.scipy.org/doc/numpy/reference/}{https://docs.scipy.org/doc/numpy/reference/}}. %using the numerically stable Jenkins-Traub algorithm \citep{jenkins}\footnote{A C++ implementation of the algorithm is available at \href{https://github.com/ethz-asl/mav_trajectory_generation}{https://github.com/ethz-asl/mav\_trajectory\_generation}}.
The trajectory with the least cost among all the real and positive solutions for the polynomial is utilized after the coefficients are found using Eq. \eqref{equation}. There are scenarios where no real roots exist,then we assume a constant jerk and use Newton's second equation of motion to solve for the end time(This assumption is used rather than fixing an end time due to the fact that fixing an end time beforehand reduces a degree of freedom in the solution). After getting the end time, we solve for the polynomial coefficients. Each of the polynomial represents the predicted trajectory in one dimension for one robot. Therefore, for every other robot that transmits it's current state and desired state, the above method is used for predicting trajectories thereby generating a smooth trajectory representation for dynamic obstacles.


\section{Trajectory generation}
\label{traj optimization}
The trajectory generation problem can be formulated as:
\begin{argmini!}
  {\textbf{\textit{x}}}{\int_{0}^{T} C_{d} +\sum_{i=1}^M C_{c}+C_{l}+ K_t \hspace{1mm} dt  }{}{}
  %\breakObjective{+
  \label{traj_objective}
  \addConstraint{\textbf{\textit{x}}(0)}{=x_0}{}
  \label{staring_const}
  \addConstraint{\textbf{\textit{x}}(T)}{=x_f}
  \label{end_const}
\end{argmini!}

Where $C_{d}$,$C_{c}$ and $C_{l}$ are costs for trajectory smoothness, collision with other robots and dynamic limits respectively. Please note the addition of $K_t$ at the end of the cost, which is added to minimize the time taken along the trajectory. Besides, the constraint in Eq. \eqref{end_const} can be defined for the complete state or partial state. Furthermore, we represent the trajectories by time parameterized polynomials of order five to allow trajectories to be similar in representation to the predicted trajectory. %But in this scenario, we utilize piecewise polynomials for each of the $N$ dimension with $K$ segments, resulting in the one segment being represented as:
Therefore, for each dimension, the trajectory can be represented by:
\begin{equation}
x(t)= \sum_{j=0}^{5}\alpha_j t^j%, \text{for} \hspace{2mm} t_1 \leq t \leq t_2 
\label{decision with degree}
\end{equation}
%$t_1$ and $t_2$ are the starting time and ending time of the trajectory segments. This makes the coefficients to be optimized per segment to be:
 The decision variables of the optimization problem are:
 \begin{equation}
\mathcal{D} = [\alpha_0 \hspace{1mm} \alpha_1 \hspace{1mm} \alpha;_2 \hspace{1mm} \cdots \alpha_{6N-1} \hspace{1mm} T]^T
\label{per_vehicle}
\end{equation}

where the first six numbers represent the polynomial coefficients of the first dimension, the second six the second dimension. Lastly the $T$ represents the end time.

%And for $K$ segments

%\begin{equation}
%\mathcal{C}= [\mathcal{D}_1 \hspace{1mm} \mathcal{D}_2  \hspace{1mm} \ldots \hspace{1mm} %\mathcal{D}_K]^T 
%\label{decision_vector}
%\end{equation}

%This formulation adds $n+1$ continuity constraints on the changeover of the piecewise segments to ensure that the trajectories are continuous. This constraint is a non linear equality constraint and adds $K(n+1)$ constraints.  

\subsection{Dynamic Smoothness}
To ensure that the generated trajectory is smooth, a smoothness constraint is added. This constraint is represented as:
\begin{equation}
C_{d}=Q_{dynm}\norm{\frac{d^{n}\textbf{\textit{x}}}{dt^{n}}}^2 
\label{derivative}
\end{equation}
$Q_{dynm}$ is a weight for the dynamics. This derivative cost can be integrated analytically and solved for in terms of the optimization variables as shown in Eq. \eqref{per_vehicle}.

\subsection{Collision Avoidance}
To avoid collisions with other robots in the environment, an exponential barrier function based collision avoidance method is utilized. This function can be represented as

%\begin{figure}
%\centering
%\includegraphics[width=0.5\textwidth]{deriv}
%\caption{The derivative soft constraint objective function for different values of $\rho$. Note that this cost function is slightly different from the derivative cost limit utilized in \citep{2017real}. }
%\label{Deriv_cost}
%\end{figure}

\begin{equation}
C_{c}=Q_{obs}c(x(t))
\end{equation}
Where $Q_{obs}$ is collision avoidance weighing parameter, 
\begin{equation}
c(x(t)) = \frac{x(t)-x_{obs}(t)(v(t)-v_{obs}(t))}{\exp^{K_p(d(x(t),x_{obs}(t))-\rho)}d(x(t),x_{obs}(t))} 
%\begin{cases}
%\frac{1}{2\rho}(d(x)-\rho)^2 & \text{if} d(x) \leq \rho \\
%0 & \text{if} d(x) \geq \rho   
%\end{cases}
\label{Pieceswise obstacle}
\end{equation}
$c(x(t))$is the collision avoidance cost and $d(x)$ is the euclidean distance between the robot and obstacle and $\rho$ is a threshold distance beyond which the robots have to be for collision-free navigation. Thus, we model the robots as $N$ dimensional spheres and $\rho$ is the sum of the two radii(minimum distance to ensure collision avoidance). The robots are modeled as spheres as it is easier to compute distances for spheres than ellipses. 

\begin{figure}
\includegraphics[width=0.5\textwidth]{ACDOS/neo6.png}
\caption{The trajectories for six Neos robots during a rest-to-rest experiment.}
\label{six_robot}
\end{figure}

%\begin{figure*}
%\subfloat[][]{\includegraphics[width=0.24\textwidth]{distance}\label{distance1}} 
%\subfloat[][]{\includegraphics[width=0.27\textwidth]{distance2}\label{distance2}}
%\subfloat[][]{\includegraphics[width=0.25\textwidth]{distance3}\label{distance3}} 
%\subfloat[][]{\includegraphics[width=0.27\textwidth]{distance4}\label{distance4}} 
%\caption{The distance trajectories as the robots traverse through the environment for a six robot homogeneous rest-to-rest trajectory as shown in Figure \ref{six_robot}. The robot in this experiment start of at a distance and when they come close they robot evades and ensures that the threshold isn't violated }
%\label{Distance}
%\end{figure*}

Furthermore, the velocity difference $v(t)-v_{obs}(t)$ is added to the cost for two reasons, one, to account for the difference in velocity of the robots and two, analytical integration of the proposed cost for closed-form solutions. The analytically integrated cost is then utilized for collision avoidance. Moreover, in the case of other robots( whose trajectories are predicted as detailed in Section \ref{prediction}), the trajectories are represented by time parameterized polynomials. Therefore, this time parameterized trajectories of each of the robots can be directly incorporated into the objective in $x_{obs}(t)$,  allowing for continuous time evaluation.

\subsection{Dynamic limits}
As the algorithm attempts to minimize the time taken by the robots, it is important to consider the dynamic limits of the robot. To account for the limits, we utilize a soft constraint inspired by \citep{2017real} that allows for continuous time limit verification while also not adding constraints. The dynamic limits are represented as:
\begin{equation}
C_{l}=Q_{lim}D(x(t))
\end{equation}
Where $Q_{lim}$ is the tuning weight for the dynamic limits,
\begin{equation}
D(x(t))=\exp^{d(x(t))^2-\tau^2}
\end{equation}
Here $\tau$ is the maximum limit of the specific derivative that the robot is allowed and $d(x(t))$ is the euclidean norm of the $N$ dimensions of the robot.
Furthermore, in our implementation we utilize the euclidean norm of the derivatives to account for dynamic limits rather than each dimension individually. This is done as the dynamic limits of most robots are better represented by magnitude rather than decoupled limits on each dimension. We penalize the limits for the dynamics from the first derivative to $n^{\text{th}}$ derivative of the robot's position. The usage of soft constraints is guided by it allowing for a continuous time dynamic limit checking and if necessary, the dynamic limits can be violated by a small margin by the algorithm.  

\begin{figure}
\includegraphics[width=0.5\textwidth]{ACDOS/plot2.png}
\caption{The executed trajectory for Eight Fireflys from a hovering start to non zero end velocity. The robots as they start in a cluttered environment showcase some drastic changes and evasions, but as time progresses, they come to stand still}
\label{8neo}
\end{figure}

\begin{figure}
\includegraphics[width=0.45\textwidth]{ACDOS/velocity_heterogenous.png}
\caption{The velocity profile for the eight robot multiple transitions maneuver. The evasive velocity profiles as the robots navigate between the other robots initially. As the robots move further away from each other, the robots velocity profiles stabilize into a smooth curve. The dynamic limits are shown in dotted black lines }
\label{eightneo}
\end{figure}

%\begin{figure*}
%\centering
%\subfloat[][]{\includegraphics[width=0.25\textwidth]{distance1neo}\label{distance1neo}} 
%\subfloat[][]{\includegraphics[width=0.24\textwidth]{distance2neo}\label{distance2neo}}
%\subfloat[][]{\includegraphics[width=0.24\textwidth]{distance3neo}\label{distance3neo}} 
%\subfloat[][]{\includegraphics[width=0.25\textwidth]{distance4neo}\label{distance4neo}} 
%\includegraphics[width=\textwidth]{neo8distance}
%\caption{The distance trajectories as the robots traverse through the environment for the Eight Neos experiment with rest to rest trajectory as shown in Figure \ref{8neo}. The robots start off at distances lesser than the allowed threshold and as the robots progress towards their end destinations, the distance moves out of threshold. Moreover, due to congestion of robots, the robots do showcase scenarios where they come within the threshold but collision is avoided as the robots are at different heights.}
%\label{Distanceneo}
%\end{figure*}


%Q_{dynm}\norm{\frac{d^{n}\textbf{\textit{x}}}{dt^{n}}}^2 + \sum_{i=1}^M Q_{obs}c(x(t))+  \sum_{i=2}^n D(\frac{d^i\textbf{\textit{x}}(t)}{dt^i})

The NLP in Eq.(12) cannot be proven to be convex due to the equality constraints in Eq. \eqref{staring_const} and Eq. \eqref{end_const}. Hence, any solution that is generated is going to be locally optimal in general. We utilize Sequential Quadratic Program(SQP) to solve the NLP. The algorithm was implemented in \citep{nlopt} using the method proposed in \citep{sqp}. The initialization of the SQP is done using the previously optimized trajectory. For solving the problem during the first iteration, the algorithm was initialized using the method for trajectory prediction in Section \ref{prediction} 


\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{ACDOS/heterogenous_transition.jpeg}
\caption{The trajectories for Eight aerial robots(Three Neos and Five Fireflys) during multiple tranisitions}
\label{eight_robot_traj}
\end{figure}

%\begin{figure}
%\includegraphics[width=0.5\textwidth]{vel_hetero_trans8}
%\caption{The velocity profile for Eight robots in the experiment for testing the transition %capabilities of the algorithm. The robots plan smooth trajectories during the first transition. The second transition during which the robot has to contend with some collisions, also showcases smooth. Third transition during which the dynamic limits of the robots are changed, shows the robots all cluttered and planning drastic velocity profiles. The dynamic limits are shown in dotted black lines}
%\label{Sixfi}
%\end{figure}


\section{Simulation Results}
\label{results}
The algorithm was implemented in Python using Robot Operating System(ROS) with $N=3$. The algorithm was tested on a workstation with Intel Xeon E5 1630v5  processor, 64GB of RAM and a Nvidia Quadro M4000 GPU. The algorithm was verified with different rotary winged flying robots of different sizes (Asctec Hummingbird\footnote{\href{http://www.asctec.de/uav-uas-drohnen-flugsysteme/asctec-hummingbird/}{http://www.asctec.de/uav-uas-drohnen-flugsysteme/asctec-hummingbird/}},Firefly\footnote{\href{http://www.asctec.de/uav-uas-drohnen-flugsysteme/asctec-firefly/}{http://www.asctec.de/uav-uas-drohnen-flugsysteme/asctec-firefly/}},Neo\footnote{\href{http://www.asctec.de/uav-uas-drohnen-flugsysteme/asctec-neo/}{http://www.asctec.de/uav-uas-drohnen-flugsysteme/asctec-neo/}}) in Gazebo using RotorS \citep{rotors}, a high fidelity multirotor simulator.

\begin{figure}
\includegraphics[width=0.5\textwidth]{ACDOS/10_hetero.jpg}
\caption{Five Fireflys and Five Neos's trajectories during a rest-to-rest maneuver}
\label{10hetero}
\end{figure}


Although aerial robots are fourth order systems, in our experiments we utilize third order system that minimizes the jerk of the robot similar to \citep{efficient2015quad}. To track the generated trajectory, we use \citep{taecontroller}. Throughout the experiments, the yaw of the system is kept free as the rotation about yaw does not affect the translational motion. The trajectories are re-planned at a frequency of 8Hz.     
\subsection{Simulations}
In Figure \ref{six_robot},\ref{8neo},\ref{eight_robot_traj} and \ref{10hetero}, the colored circles represent the starting point of the robots while the colored triangles represent the end points of the robots.

In a first simulation, six Neos were spawned randomly and tested for rest-to-free-end-state trajectory. %Robot 1 takes 4.23 seconds to reach it's destination. Robot 2 reaches it's end state at 3.65 seconds. Robot 3 takes 4.53 seconds to reach its destination. Robot 4 takes 5.14 seconds to reach it's destination. Robot 5 reaches it's destination in 3.73 seconds. Robot 6 takes just 2.43 seconds to reach it's destination. 
The plotted trajectories are shown in Figure \ref{six_robot}. %The distance between two multirotors as they traverse through the environment is shown in Figure \ref{Distance}. 

In a second simulation, eight Fireflys starting from a tightly scrunched space, with many robots stacked on top of each other were given a non-rest end state. This experiment also had the robots start off at distances closer than the allowed threshold. The trajectories of the robots during this experiment are shown in Figure \ref{8neo}. %The distances between the robots are shown in Figure \ref{Distanceneo}. 

In a third simulation, the algorithm's performance with heterogeneous robots and multiple maneuvers was tested (The robots were first given a rest-to-rest state, and after that another non-rest desired pose was published). The experiment used five Fireflys and three Neos and consisted of four different transitions with the latter three transitions having non-rest end states (left free). The robots were able to maneuver safely in the experiment while ensuring the dynamic limits were not exceeded. The resulting trajectory is shown in Figure \ref{eight_robot_traj}. 
%The starting of the maneuver is shown in Figure \ref{fireflyandneo}. 

It can also be seen from the velocity profile that some of the robots do come to rest during the third transition.

In a final simulation, five Fireflys and five Neos were tested for their capabilities with rest-to-rest transitional maneuver. The resulting trajectories for different robots are shown in Figure \ref{10hetero}.

The algorithm is capable of generating collision-free smooth trajectories for the robots to traverse across the environment. Furthermore, the utilization of soft constraints allows the robots to be able to violate the constraints if required. This is while being a boon for dynamic limits but is not so for collision avoidance.

%\begin{table}
%\caption{Success \% of Algorithm}
%\label{table_example}
%\begin{center}
%\begin{tabular}{|c|c|c|c|}
%\hline
%\textbf{Experiment} & \textbf{Transition} & \thead{\textbf{Trajectory} \\ \textbf{Prediction}} & %\thead{\textbf{Trajectory} \\ \textbf{ Optimization}} \\
%\hline
%6 Fireflys & & 52.432\% & 62.456\%  \\
%\hline
%8 Neos & & 59.265\% & 59.200\%  \\
%\hline
%5 Fireflys and  & Transition 1 & 53.355\% & 52.238\%   \\\cline{2-4}
%3 Neos & Transition 2 & 53.355\% & 58.327\%   \\\cline{2-4}
%& Transition 3 & 66.521\% & 48.655\%   \\\cline{2-4}
%& Transition 4 & 52.489\% & 58.36\%   \\\cline{2-4}
%\hline
%5 Fireflys and  & Transition 1 & 53.355\% & 54.316\%   \\\cline{2-4}
%5 Neos & Transition 2 & 56.339\% & 48.278\%   \\\cline{2-4}
%& Transition 3 & 63.555\% & 58.424\%   \\\cline{2-4}
%& Transition 4 & 58.143\% & 54.233\%   \\\cline{2-4}
%\hline
%\end{tabular}
%\end{center}
%\end{table}

%It is to be noted that the algorithm required some empirical tuning to perfectly execute and achieve a proper trade-off between not violating the dynamic limits, collision-free navigation, minimizing time and dynamic smoothness. This can be attributed to the exponential nature of the dynamic limits and collision avoidance objective function while time is a monomial function. Moreover, time also affects the collision and dynamic limits thereby making the objective function highly non linear. Furthermore, some adaptive online tuning is required. This requirement was pronounced when using heterogeneous robots and transition maneuvers as this caused some jitters in the generated trajectory as shown in Figure \ref{10hetero}, where most robots perform some sudden jittery maneuvers despite being in free space.

%The failure of the algorithm to generate a solution is shown in Table \ref{table_example}. The failure in trajectory prediction is the times when the solutions returned for the roots of the polynomial are either all complex or real and non positive. In the trajectory optimization, a failure is represented by a scenario where the trajectory results in the collision of robots with each other or the failure of algorithm to find a solution.

\section{Conclusion}
\label{conclusion}
A decentralized algorithm for replanning trajectories for multi-robots systems with third order dynamics was proposed in this paper. Each robot uses the algorithm to predict continuous-time trajectories for other robots in the environment and utilizes those trajectories for planning collision-free trajectory for itself. The algorithm was simulated extensively on Gazebo for up to ten robots with speeds of up to 2 m/s in three dimensional spaces. Furthermore, the algorithm utilizes continuous time trajectory parameterization and implements soft constraints for dynamic limits.

Future work is to implement the algorithm on real robotic platforms. For collision avoidance, the performance is dependent on the axis in which the robots are proximal to each other. This is an anomaly that we look to solve in the future. Another avenue for research is to develop a methodology that allows for adapting the weights online as hand tuning the cost function is tedious and time consuming. Besides, in most of the experiments, the algorithm predicts trajectories assuming non-zero end states, developing a method to decide whether to use free-end state or rest-end state is another point to look through in the future.  Moreover, accounting for deviations in the predicted trajectory and actual trajectory can be incorporated into the collision avoidance to allow for better predictions.

%\addtolength{\textheight}{-7cm}

%\bibliographystyle{ifacconf}
\bibliography{references,refer}

\section*{Appendix}
\subsection*{Partially defined end state}
In case of end position only being available, substituting the velocity and acceleration terms from costate equation Eq.\eqref{costatesol} and equating them to zero allows:
\begin{equation}
\begin{bmatrix}
T^5 & T^4&T^3 \\
-2T & -2 & 0 \\
-T^2 & -2T & -2
\end{bmatrix} \begin{bmatrix}
\beta_1 \\
\beta_2 \\
\beta_3
\end{bmatrix} = 
\begin{bmatrix}
p_{end} -(p_0 + v_0T + 0.5a_0T^2) \\
0\\
0
\end{bmatrix}
\end{equation}

The solution to the linear system results in:

\begin{equation}
\begin{bmatrix}
\beta_1 \\
\beta_2 \\
\beta_3 \\
\end{bmatrix} = \frac{1}{T^5}\begin{bmatrix}
20 \\
-20T \\
10T^2
\end{bmatrix}(p_{end}-(p_0+v_0T+ \frac{a_0T^2}{a}))
\label{equationapend}
\end{equation}

\end{document}