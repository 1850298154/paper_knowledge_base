\subsection{Greedy formulation}

The previously discussed method produces an optimal result, but experimental evaluation reveals that it takes a long time to reach a solution. This motivates the need for another method that can solve the same problem quickly, although at the cost of optimality. We propose a simple, but effective greedy solver that produces a quick but sub-optimal result. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% ALGORITHM FOR COALITION/SCHEDULING %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}
\begin{algorithmic}[1]
\small
% \State $P$ holds all the robots' schedules
% \State $O \gets R$

\While{Any task is unsatisfied}

\State $(i_1, k_1),... \gets \text{Robot-task pairs with max contribution}$
% \State $i_1, k^c \gets \underset{i,k \in I_1, K_1}{\arg\min} (y^{\max}_{S_{i,-1}} + t^{e}_{S_{i,-1}} + t_{iS_{i,-1}k} + t^s_{S_{i,-1}k})$
% \State $i^c, k^c \gets \underset{(i,k) \in (i_1, k_1),...}{\arg\min} (y^*_{iP_{i,-1}k})$
% \State $i^c, k^c \gets \underset{(i,k) \in (i_1, k_1),...}{\arg\min} (\footnotesize\text{estimated time of arrival of robot }i\text{ at task } k)$
\State $(i^c, k^c) \gets \text{The earliest robot-task pair from} (i_1, k_1), ...$

\State  Assign task $k^c$ to the robot $i^c$ using Algorithm \ref{alg:assign_task}

\While{Unaddressed skill at task $k^c$}
% \State $I_2 \gets$ $\underset{i}{\arg\max} (q_{i} \cdot r_{k^c}^T)$
% \State $i_2 \gets \underset{i \in I_2}{\arg\min} (y^{\max}_{S_{i,-1}} + t^{e}_{S_{i,-1}} + t_{iS_{i,-1}k^c} + t^s_{S_{i,-1}k^c})$
\State $i^d_1, ... \gets $Robots with max contributions from remaining skills at $k^c$
\State $i^d \gets $ The earliest robot from $i^d_1, ...$

\State Assign task $k^c$ to the robot $i^d$ using Algorithm \ref{alg:assign_task}
\EndWhile

\State $y^{\max}_{k^c} \gets \underset{i}{\max} \ y_{ik^c}$

\EndWhile
\end{algorithmic}
\caption{The proposed greedy algorithm}\label{alg:greedy_algo}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% ALGORITHM FOR TASK ASSIGNING %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\begin{algorithmic}[1]
\small

\State $j \gets$ The current task of robot $i$
\State $x_{ijk}=1$
\State $y_{i,k} \gets y^{\max}_j + t^{e}_{j} + t_{ijk} + t^s_{jk}$
\State Update the list of unaddressed skills at task $k$

\caption{Assign task $k$ to robot $i$}\label{alg:assign_task}
\end{algorithmic}
\end{algorithm}


\subsubsection{Methodology}
% \paragraph{Methodology}

In this work, we assume that task execution can only start when all the required skills are fulfilled simultaneously. Thus, a coalition might cause its robots to wait idly until the last robot in the coalition arrives. It is thus desirable to have as small coalitions as possible with robots that cover as many skills as possible. On the other hand, only seeking a solution with small coalitions might require few, powerful robots to spend significant time travelling across the environment to attend the assigned tasks. In such a scenario, the generated paths for the robots are not optimal due to the absence of any mechanism to shorten the robots' travel path. Motivated by these observations, we propose a greedy algorithm that promotes forming small coalitions while also minimizing the distance traveled by the robots.

Our algorithm first finds the robots that can contribute the most to a task and arrive the soonest. We define a robot's `contribution' as the number of previously unoffered skills it can bring to a task. We identify all the robot-task pairs that maximize the robots' contributions to the tasks (Alg. \ref{alg:greedy_algo}, line 2). If multiple robots contribute equally, we choose the one that can reach the task location first (Alg. \ref{alg:greedy_algo}, line 3). This estimated time of arrival is calculated with the same logic as in Sec. \ref{subsec:arrival_times}. 

We use Alg. \ref{alg:assign_task} to add the task to the robot's schedule (line 2), update its arrival time (line 3), and update the task's requirements (line 4) to account for the skills provided by the attending robot. 

We now choose a robot coalition to fulfill the skills required for task $k^c$. If the task still requires additional skills to start (Alg. \ref{alg:greedy_algo}, line 5) we select the robots that can offer the highest number of the remaining skills (Alg. \ref{alg:greedy_algo}, line 6). If multiple robots are tied, we choose the one that can reach the task location first  (Alg. \ref{alg:greedy_algo}, line 7). We then use Algorithm \ref{alg:assign_task} to add the task to the robot's schedule  (Alg. \ref{alg:greedy_algo}, line 8). We repeat this process until all of the task requirements have been fulfilled (Alg. \ref{alg:greedy_algo}, line 5). We then update the task start time for the chosen task $k^c$ according to the attending coalition (Alg. \ref{alg:greedy_algo}, line 10).

% To assign more robots to a task if needed, we first consider the robot that can offer the highest number of remaining skills. If multiple robots are tied, we select the one that can reach the task location first. Algorithm \ref{alg:assign_task} is used to add the task to the robot's schedule. We repeat this process until all task requirements are met.

% In this method, we will consider a pool of robots $P$ to distribute the tasks evenly across all the robots. In each cycle, a random robot in the pool chooses a task and removes itself from the pool. When the pool runs out of robots, we reset it with all the robots, and the cycle starts again. Algirithm \ref{alg:greedy_algo} describes the methodology of this approach.

% A variable $S$ maintains the schedule of all the robots. The $m^{\text{th}}$ task in robot $i$'s schedule is given by $S_{im}$. We will use the notation $S_{i,-1}$ to refer to the last task assigned to the robot $i$, as per the latest schedule.

% At the start, we choose a random robot from the available pool. The robot chooses a task that it can contribute to the most. The contribution is the number of skills it can offer to the task. In case of a tie, the robot chooses a task it is estimated to reach earliest. The estimated time of arrival is given by the same logic as in the section \ref{subsec:arrival_times}, with the variables carrying the same meaning. The stochastic buffer time consideration is also the same as in section \ref{subsec:stoch_time} and is denoted by $t^s$. 

% Once the robot chooses a task $k^c$, it removes itself from the pool $P$ if it exists in the pool. Then the robot adds the task to its schedule and updates the time of arrival at that task (algorithm \ref{alg:assign_task})

% If the chosen task has more requirements than the robot can offer, the robot searches for a companion robot for the coalition.
% The robot chooses a companion that can offer the most number of remaining skills. Here we refer to the `remaining skills' as the skills that the task requires but the current coalition does not offer them. If multiple robots can offer the same number of remaining skills, then the robot that is estimated to arrive at the task earliest is chosen as a companion. To get an estimate of each robot's arrival times, we first refer to their last allocated task in the schedule $S$. Then, using the same logic as in section \ref{subsec:arrival_times}, we estimate how long it takes for the robot to arrive at the current task $k^c$.

% The earliest arriving robot is chosen for a coalition. We again use the algorithm \ref{alg:assign_task} to update this robot's schedule and the time of attending the task. This cycle of adding robots to the coalition continues until the coalition satisfies all the task requirements. And once they are satisfied, the task is removed from the task pool $O$










% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%% ALGORITHM FOR COALITION/SCHEDULING %%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{algorithm}
% \begin{algorithmic}
% \State $P \gets$ all robots
% \State $O \gets$ all tasks
% \State $S$ holds all the robots' schedules
% % \State $y$ holds each robot's arrival times at tasks

% % \For{$i$ in all robots} $y_i$ = 0\EndFor
% % \State $\forall i \quad y_i = 0$

% \While{$O$ has tasks remaining}
% \If{$P$ is empty}
% \State $P \gets$ all robots
% \EndIf
% \State $i \gets$ random robot out of $P$

% \State $K \gets$ all tasks where $\underset{k}{\arg\max} (q_{i}.q_{k}^T$)
% \State $j \gets S_{i,-1}$
% % \State $y^{\max}_{j} \gets \underset{i_2}{\max} \ y_{i_2j}$
% \State $k^c \gets \underset{k \in K}{\arg\min} (y^{\max}_{j} + t^{e}_{j} + t_{ijk} + t^s_{jk})$
% \State Assign task $k^c$ to the robot $i$ using Algorithm \ref{alg:assign_task}

% % \State $y_{ik^c} \gets y^{\max}_{j} + t^{e}_{j} + t_{ijk^c} + t^s_{jk^c}$
% % \State $r \gets $ vector of all requirements of the task $j$

% \While{any element of $(r_{j}-q_{i})>0$}
% \State $r_{j} \gets (r_{j}-q_{i})$
% \State Set negative values in $r_{j}$ as 0
% \State $I \gets$ all robots where $\underset{i}{\arg\min} \Big(\sum^l_{s=0}\big((r_{j}-q_{i})>0\big)\Big)$

% \State $i_2 \gets \underset{i \in I}{\arg\min} (y^{\max}_{S_{i,-1}} + t^{e}_{S_{i,-1}} + t_{iS_{i,-1}k^c} + t^s_{S_{i,-1}k^c})$

% % \State $j \gets S_{i_2,-1}$
% % \State $y^{\max}_{j} \gets \underset{i \in C}{\max} \ y_{ij}$
% \State Assign task $k^c$ to the robot $i_2$ using Algorithm \ref{alg:assign_task}
% % \State $y_{i_2k^c} \gets y^{\max}_{S_{i_2,-1}} + t^{e}_{S_{i_2,-1}} + t_{i_2S_{i_2,-1}k^c} + t^s_{S_{i_2,-1}k^c}$
% \EndWhile


% \State remove $k^c$ from $O$
% \State $y^{\max}_{k^c} \gets \underset{i}{\max} \ y_{ik^c}$


% \EndWhile
% \end{algorithmic}
% \caption{A greedy algorithm}\label{alg:greedy_algo}
% \end{algorithm}


\subsubsection{Correctness of the algorithm}
We assert that our algorithm yields a feasible solution in which all tasks are allocated to suitable robots. To establish this claim, we demonstrate that the algorithm assigns each task to a set of appropriate robots. Suppose there is an unassigned task $k$ with unfulfilled requirements, which means the sum of its requirements is greater than 0. The solver must continue until this task is assigned a group of robots that can fulfil all of its requirements. Hence, eventually a robot will choose this task, even if it can only provide a single skill. Once the solver has found a robot for task $k$, it will search for other robots to fulfil any remaining requirements. A feasible solution requires at least one robot to contribute at least one skill to the remaining requirements. As long as such a robot exists, it will be assigned to task $k$. Moreover, the solver will not choose a robot that cannot contribute to the task as long as there is a robot that can contribute at least one skill. Therefore, there can be no redundant robot assigned to any task. We conclude that our algorithm always terminates with a feasible solution. Therefore, we can conclude that the proposed greedy algorithm for task allocation is correct and produces a feasible solution.