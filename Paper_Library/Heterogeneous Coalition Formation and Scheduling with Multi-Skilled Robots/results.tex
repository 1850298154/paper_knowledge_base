\section{Experimentatal Evaluation}

We conducted experiments with 4 robots and 8 tasks, testing 3 configurations with 2, 4, and 8 skills. Each configuration comprised of 30 unique setups that differed in the location of the tasks, their skill requirements, and the allocation of skills among the robots.

\subsection{Experimental Setup}
In our experiments, we define an effective area of $200 \times 200$ units, and we assume that each robot can travel 1 unit of distance per time unit. For each configuration setup, we randomly assign the locations and skill requirements for each task. The task execution time of each task is set uniformly at random from the range $[0,100]$. We also allocate skills to the robots uniformly at random. We set the starting locations of the robots to be evenly distributed around the center of the experiment area. Specifically, the starting location $(p^i_x, p^i_y)$ of the $i^{th}$ robot is calculated using the value $r = 15$ units as follows:

\begin{equation}
    (p^i_x, p^i_y) = \Big(r\  \text{sin} \bigg( \frac{i \pi}{n}\bigg), r\  \text{cos}\bigg(\frac{i \pi}{n}\bigg) \Big).
\label{eq:robot_st_loc}
\end{equation}

% While generating the experiment setups, we have a few conditions to ensure the setup's validity. These conditions are as follows:
We verify the validity of each generated experiment setup by checking the following conditions:

\begin{enumerate}
    \item Each robot is not allocated more than $l/2$ skills; 
    \item Every skill is present at least once in the robot pool;
    \item Every robot possesses at least one skill.
\end{enumerate}

\paragraph{Stochasticity parameters} The value of the mean travel time, denoted by $\mu$, was set to 10\% of the time it takes for the robot to travel between tasks. The value of the standard deviation, denoted by $\sigma$, was set as a random fraction of $\mu$. Specifically, a value was chosen uniformly at random from the interval $[0.05, 0.50]$ and multiplied by $\mu$ to obtain the final value of $\sigma$. This ensured that the amount of variability in the travel times was proportional to the mean travel time. To make the experiment results repeatable, the standard deviation value for each path is assigned at the time of setup generation. This ensures that the same standard deviation values are used throughout all the experiment runs. Finally, the probability of a robot arriving at a task within a given time window, denoted as $\epsilon$, was set to 0.95 to allow for some flexibility in task scheduling.

\paragraph{Computer specifications} The experiments were run on a computing cluster with the following configuration allocation: AMD EPYC 7543 processors, 22 CPU cores, 156 GB of RAM.

\subsection{Discussion}

% For the results, we will be considering two aspects of the solution. The first is the final solution cost, and the second is the wall clock time taken to solve the problem. 
To evaluate the performance of the two methods, we analyze two key aspects of the solution. The first one is the final cost of the solution produced. This tells us the quality of the produced solution. The second aspect of interest pertains to the wall clock time required to solve the problem. This allows us to assess the efficiency of the two algorithms in terms of the computational resources and time complexity. A sample of optimal solution for a 2-skill, 4-robot, 8-task setup is reported in Figure \ref{fig:example_solution}.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.45\textwidth]{Images/example_solution.png}
    % \caption{An example solution for a configuration with 2 skills, 4 robots, and 8 tasks. Here, the two types of skills are shown with a \textit{cross} and a \textit{circle}. The green and the red icons denote the robots' start and end locations respectively. Hence, a green colored \textit{cross} shows the starting location of a robot that offers the \textit{cross} skill. All robot end locations are at the center of the simulated area and their starting locations are around it. The blue skill symbols indicates the skills required for the task at that location. Tasks are randomly placed in the simulation area.}
    % \caption{An example solution for a configuration with 2 skills, 4 robots, and 8 tasks. Here, the two types of skills are shown with a \textit{cross} and a \textit{circle}. All robot end locations are at the center of the simulated area (shown with red icons) and their starting locations are around it (shown with green icons). Hence, a green colored \textit{cross} shows the starting location of a robot that offers the \textit{cross} skill.  The blue skill symbols indicates the skills required for the task at that location. Tasks are randomly placed in the simulation area. The resultant schedule for each robot from its starting location to the end location is shown with the solid lines.}
    \caption{An example solution for a setup with 2 skills, 4 robots, and 8 tasks. The two types of skills are represented by a \textit{cross} and a \textit{circle}. The robots' starting locations are shown by green icons near the center of the area, and their end locations are shown by red icons at the center. If a robot with a \textit{cross} skill starts at a location, a green cross is shown at that location. Blue skill symbols indicate the skills needed for each task at that location, and the tasks are randomly placed in the simulation area. The solid lines show the schedule for each robot, from its starting location to its end location.}
    \label{fig:example_solution}
\end{figure}

\begin{figure}
     \centering
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/small_xp_optimal_cost.png}
         \caption{Optimal costs for each configurations}
         \label{fig:optimal_results:cost}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.23\textwidth}
         \centering
         \includegraphics[width=0.96\textwidth]{Images/small_xp_optimal_times.png}
         \caption{Wall clock solving time (WCST) for each configurations}
         \label{fig:optimal_results:times}
     \end{subfigure}
        \caption{Optimal solution cost and solving times for three different set of configurations with varying number of skills. We can see that as the number of skills increase, both the solution cost and the solving time increases.}
        \label{fig:optimal_results}
\end{figure}

\subsubsection{Optimal solver}
Figure \ref{fig:optimal_results} presents the results for the optimal solver. As we double the total number of skills required, both the solution cost and the wall clock solving time (WCST) increase. However, the notable increase is in the WCST of the 8-skilled setups. This indicates a significant increase in the computational resources required to solve the problem at higher scale. In this configuration, some setups required about 2,000 seconds and one of the setup required 5,000 seconds to declare the final solution as optimal. Based on these results, it would not be realistic to solve a problem larger than the setup presented, as the computational resources required would be prohibitively high.
% In the results for the optimal solution (figure \ref{fig:optimal_results},) we can see that the solution cost increases by some amount as we double the number of skills. But the notable result is regarding the wall clock time needed to produce a solution. As the skills double, it takes almost tenfold more time to solve the problem. In one of the setups for 8 skill configuration, it took about 5,000 seconds to solve the problem. It would not be realistic to solve a problem any larger than the setup presented. 

\subsubsection{Greedy solver}
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.23\textwidth]{Images/small_xp_cost_comparision.png}
%     \includegraphics[width=0.23\textwidth]{Images/small_xp_time_comparision.png}
%     \caption{Results for the greedy solver compared with the optimal solution method}
%     \label{fig:greedy_results}
% \end{figure}

\begin{figure}[t]
     \centering
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/small_xp_cost_comparision.png}
         \caption{Solution quality of the greedy solver}
         \label{fig:greedy_results:cost}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/small_xp_time_comparision.png}
         \caption{Relative speed of the greedy solver}
         \label{fig:greedy_results:times}
     \end{subfigure}
        \caption{Performance of the greedy solver as compared with the optimal solver. We can see that the greedy solution gets further away from the optimum solution as we increase the number of skills. But it takes the greedy solver orders of magnitude lesser amount of time, as compared with the optimum solver}
        \label{fig:greedy_results}
\end{figure}
To analyze the greedy solver, we compared its performance with the optimal solver. Figure \ref{fig:greedy_results} compares the performance of the greedy solver to that of the optimal one. In Figure \ref{fig:greedy_results:cost} we can see that for the configuration with 2 skills, multiple points lie near 1. This means that most of the solutions were very close to the optimum. The median relative cost performance of the greedy solver was 1.15.
 %As contrast, in the 8-skills configuration we have a few solutions that produced nearly double (1.8x - 1.9x) the cost produced by the optimal solution. 

% However, the greedy solver performs very well if we consider the run time in figure \ref{fig:greedy_results} (b). For the 2-skills configuration, the median $\log_{10}$ run-time is -3.57. The greedy solver solves the problem within 0.001 fractions of the wall clock time it took for the first method. This portrays the quick nature of the greedy solver.
The greedy solver performs very well in terms of computational efficiency, as shown in Figure \ref{fig:greedy_results:times}. In 2-skills setups, the median $\log_{10}$ relative run-time is -3.57, indicating that the greedy solver is more than three orders of magnitude faster than the optimal solver. These results showcase the fast nature of the greedy solver and its potential for use in scenarios where real-time decision-making is required. %However, it is important to note that the greedy solver sacrifices optimality for speed, and its performance may degrade as the complexity of the task allocation problem increases.

% As we scale up the configurations, the cost performance degrades slightly. For the configuration of 8 skills, no experiments produced a solution close to the optimal solution. The median cost performance is 1.36. It is off of the optimal solution by some margin. However, we see that most solutions take within $10^{-5}$ fraction of the time it took to solve the same problem using the optimal method. Even though the solution quality is not very good, it is extremely quick to produce the solution.

As we scale up the problem, the performance of the greedy solver in terms of cost slightly degrades. For the configuration with 8 skills, none of the experiments produced a solution close to the optimum. As indicated by the median cost performance of 1.36, the greedy solutions are off the optimal solution by a significant margin. However, as shown in Figure \ref{fig:greedy_results:times}, most solutions generated using the greedy solver are produced within a factor of $10^{-5}$ of the time it took to solve the same problem using the optimal method, demonstrating the efficiency of the greedy solver. Although the quality of the solutions generated by the greedy solver may not be very good for larger problem sizes, the method is extremely fast and can be useful for scenarios where quick, ``good enough'' decision-making is prioritized over solution optimality.

\begin{figure}[t]
     \centering
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/gurobi_solution_progression.png}
         \caption{Solution cost progression by the optimum solver for a typical setup of 8 skills}
         \label{fig:gurobi:progression}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/gurobi_FS_WCST.png}
         \caption{Time taken to produce the first feasible solution by the optimum solver}
         \label{fig:gurobi:first_solution}
     \end{subfigure}
        \caption{Progression of the solution cost produced by the optimum solver. The solver finds a sub-optimal solution quickly, but then spends long time improving and proving the solution as the optimal.}
        \label{fig:gurobi}
\end{figure}

\subsubsection{Optimal solver's first solution}
% We use Gurobi solver to get the optimum solution. The solver is known to produce a suboptimal solution quickly, but then spend a long time to reach the optimum solution and prove its optimality. The Figure \ref{fig:gurobi:progression} shows the typical progression of solution cost for one of the setups with configuration of 8 skills. We can see that the solver is able to produce first feasible but sub-optimal solution quickly. However, the solver takes a long time to reach the optimum solution. Even after finding the optimum solution, the solver spends even more time to prove that the solution is optimum. This claim is further supported  in Figure \ref{fig:gurobi:first_solution} that portrays the time taken by the solver to produce the first feasible solution. The figure clearly shows that the solver consistently produces first solution very quickly and still takes long time to reach the optimum solution and prove its optimality (Figure \ref{fig:optimal_results:times}.) Hence, we reason that our greedy solver actually rivals the optimum solver's first solution. 

% In the Figure \ref{fig:greedy_fs_compare}, we compare the performance of the greedy solver with the first solution offered by the optimum solver. Figure \ref{fig:greedy_fs_compare:cost} shows that most of the solutions offered by the greedy solver are better than the first solutions offered by the optimum solver. Although, as we increase the problem complexity, the optimum solver's solutions get better. At the configuration scale of 8 skills, half the times the optimum solver's solutions were better than the greedy solver's solutions. Nevertheless, the greedy solver is still faster than the optimum solver. The greedy solver is consistently more than 2 orders of magnitude faster than the optimum solver. 

It is interesting to analyze the time taken by the optimal solver to reach its first solution, neglecting the time needed to verify whether it is optimal. As shown in Figure \ref{fig:gurobi:progression}, for the configuration with 8 skills, the solver rapidly produced a feasible but sub-optimal solution. However, it took a significantly longer time to reach the optimal solution and even more time to prove its optimality. This is further illustrated in Figure \ref{fig:gurobi:first_solution}, which displays the time taken by the solver to obtain the first feasible solution. The optimal solver consistently produces the first solution quickly, but it takes a long time to reach the optimum and prove its optimality (Figure \ref{fig:optimal_results:times}). 

We compared the performance of the greedy solver with the first solution offered by the optimal solver in Figure \ref{fig:greedy_fs_compare}. As shown in Figure \ref{fig:greedy_fs_compare:cost}, most of the solutions produced by the greedy solver are better than the first solutions provided by the optimal solver. While the optimal solver's solutions are superior half of the times with the 8-skill configurations, the greedy solver is still faster. The greedy solver is consistently more than two orders of magnitude faster than the optimal solver, as shown in Figure \ref{fig:greedy_fs_compare:times}. The data clearly shows the significant speed advantage of the greedy solver over the optimal solver.

\begin{figure}[t]
     \centering
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/greeedy_FS_cost.png}
         \caption{Comparing greedy solver's and optimum solver's first solution costs}
         \label{fig:greedy_fs_compare:cost}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.22\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Images/greedy_FS_times.png}
         \caption{Comparing greedy solver's and the optimum solver's first solution (FS) WCST}
         \label{fig:greedy_fs_compare:times}
     \end{subfigure}
        \caption{Performance of the greedy solver as compared with the optimal solver's first solution. We can see that the greedy solutions are mostly better than the first solutions offered by the optimum solver. The greedy solver is also orders of magnitude faster, as compared with the optimum solver.}
        \label{fig:greedy_fs_compare}
\end{figure}


% To analyze the speed and scalability of the method, we repeated the experiments on larger-scale configurations. We first set the number of robots as 32 and the number of skills as 64. We then generated 30 setups each with 128,256,512 and 1024 tasks. In figure \ref{fig:large_results} we see the $\log_{10}$ of solving times of each of these configurations. 

\subsubsection{Large-scale experiments}
To further investigate the speed and scalability of the proposed methods, we conducted a series of experiments on larger-scale configurations. We set the number of robots at 32 and the number of skills at 64, and generated 30 setups for each of four task counts: 128, 256, 512, and 1,024. For such large scales, the optimal solver failed to produce even the first solution after running for three hours. Hence, we analyze only the greedy solver's performance in what follows.

Figure \ref{fig:large_results} displays the $\log_{10}$ of the wall clock times required by the greedy solver to solve each of these configurations. 
% In this figure, we can observe that the $\log_{10}$ of the solve times increase by about 0.6 for each doubling of the number of tasks. This means the solve times increase by almost a factor of 4 when the tasks are doubled. But even with this increase, the problems were solved consistently within 45-50 seconds for the configuration of 1024 tasks. 
The results reveal that the $\log_{10}$ of the WCST required to solve the larger-scale configurations increases by approximately 0.6 for each doubling of the number of tasks. In other words, as the number of tasks doubles, the solve times increase by a factor of approximately four. Despite this increase, we consistently obtained solutions for the configuration of 1,024 tasks within 45-50 seconds. These results suggest that the greedy solver can handle large-scale instances efficiently, making it a promising approach for real-world scenarios with a large number of tasks.


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.45\textwidth]{Images/large_xp_greedy_times.png}
    \caption{Wall clock solving times (WCST) required by the greedy solver for large set of tasks}
    \label{fig:large_results}
\end{figure}

