%!TEX root = main.tex

\section{Details of Algorithms}

%\subsection{Verifying Abstract Deadlock Patterns}
%\applabel{verify-abstract-patterns}

%Given an abstract deadlock pattern of length $k \geq 2$,
%there can be $O(\NumEvents^k)$ instantiations of it,
%giving a naive enumerate-and-check algorithm running 
%in time $O(\NumThreads\cdot\NumEvents^{k+1})$.
%Instead we exploit monotonicity properties of 
%the sync-preserving closure (\propref{spclosure-monotone})
%and instantiations of an abstract pattern (\corref{pattern-monotone}) 
%that allow for an \emph{incremental}
%algorithm that iteratively checks successive instantiations
%of a given abstract deadlock pattern, while still spending total $O(\NumEvents\cdot \NumThreads)$ time.
%% , i.e., the running time is linear in $\NumEvents$, which is the dominating parameter.
%The first observation allows us to re-use a prior
%computation when checking later deadlock patterns.
%
%% We first observe that the sync-preserving closure is monotonic
%% with respect to the thread-order, and thus, when computing closure
%% of later events, one can avoid re-computation.
%\begin{restatable}{proposition}{spclosure-monotone}
%\proplabel{spclosure-monotone}
%For a trace $\tr$ and sets $S, S' \subseteq \events{\tr}$.
%If for every event $e \in S$, there is an event $e' \in S$
%such that $e \tho{\tr} e'$, then
%$\SPClosure{\tr}(S) \subseteq \SPClosure{\tr}(S')$.
%\end{restatable}
%
%%\begin{proof}
%%Follows from the definition of $\SPClosure{\tr}(S)$.
%%\end{proof}
%
%Next, we extend \propref{spclosure-monotone} to avoid redundant
%computations when a sync-preserving deadlock is not found and later deadlock patterns must be checked.
%Given two deadlock patterns
%$D_1 = e_0, \ldots, e_{k-1}$ and $D_2 = f_0, \ldots, f_{k-1}$
%of the same length $k$, 
%we say $D_1 \prec D_2$ if
%they are instantiations of a common abstract pattern $\abst{D}$
%(i.e., $D_1, D_2 \in \abst{D}$) and 
%for every $i<k$, $e_i \tho{\tr} f_i$.
%\begin{restatable}{corollary}{pattern-monotone}
%\corlabel{pattern-monotone}
%Let $\tr$ be a trace and let $D_1 = e_0, \ldots, e_{k-1}$ and 
%$D_2 = f_0, \ldots f_{k-1}$ be deadlock
%patterns of size $k$ in $\tr$ such that $D_1 \prec D_2$.
%Let $S_1 = \set{e_0, \ldots, e_{k-1}}$ and $S_2 = \set{f_0, \ldots, f_{k-1}}$.
%If $\SPClosure{\tr}(\prev{\tr}(S_1))\cap S_2 \neq \emptyset$,
%then $\SPClosure{\tr}(\prev{\tr}(S_2))\cap S_2 \neq \emptyset$.
%\end{restatable}
%
%The algorithm for checking if an abstract deadlock 
%pattern contains a sync-preserving instantiation
%is presented in~\algoref{abstract-pattern}.
%At a high level, it iterates over the sequences $F_0, \ldots, F_{k-1}$ of 
%acquires (one for each abstract acquire) in trace order.
%For this, the algorithm maintains
% indices $i_0, \ldots, i_{k-1}$ that point to entries in $F_0, \ldots, F_{k-1}$.
%At each step, it determines whether the current
%deadlock pattern $D = e_0, \ldots, e_{k-1}$
%by computing the sync-preserving closure
%of the predecessors of the deadlock pattern, and checks
%if it is disjoint from the deadlock.
%If so, it terminates.
%Otherwise, it looks for the next eligible deadlock,
%which it determines based on \corref{pattern-monotone}.
%In particular, it advances the pointer $i_j$
%all the way until an entry which is outside of the
%closure computed so far.
%Also observe that the timestamp $T$ of the closure
%computed in an iteration is being used in later iterations;
%this is a consequence of \propref{spclosure-monotone}.
%Further, we ensure that the list of acquires $\AcqLst_{t, \lk}$
%used in the function \fixpoint (\algoref{compute-closure})
%be reused across iterations, and not need be
%re-assigned to the original list of all acquire events;
%correctness of this optimization follows from~\propref{spclosure-monotone}.
%Let us now calculate the running time for this algorithm.
%Each of the $\AcqLst_{t, \lk}$ in \fixpoint is traversed
%at most once. 
%Next, each element of the sequences $F_0, \ldots, F_{k-1}$
%is also traversed atmost once.
%For each of these acquires, the algorithm spends $O(\NumThreads)$
%time for vector clock updates.
%The total time required is thus $O(\NumEvents \cdot \NumThreads)$.
%This concludes the proof of \lemref{abstract-pattern-linear-time}.

\subsection{The Online $\SyncPDOffline$ Algorithm}
\applabel{app_online}
%\seclabel{app_online}
\Andreas{We can consider bringing this in the main paper. We should have space now. Some reviewers requested this, and it does make the paper self contained.}
In this section we give a detailed pseudocode description of the online $\SyncPDOffline$ algorithm (\algoref{online}).
\input{algo-online_full}