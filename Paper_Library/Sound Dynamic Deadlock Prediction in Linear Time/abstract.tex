%!TEX root=./main.tex

\begin{abstract}
Deadlocks are one of the most notorious concurrency bugs, 
and significant research has focused on detecting them efficiently.
\emph{Dynamic predictive analyses} work by observing concurrent executions,
and reason about alternative interleavings that can witness concurrency bugs.
Such techniques offer scalability and sound bug reports, and have emerged as an
effective approach for concurrency bug detection, such as data races.
Effective dynamic deadlock prediction, however, has proven a challenging task,
as no deadlock predictor currently meets the requirements of 
\emph{soundness}, \emph{high-precision}, and \emph{efficiency}.

In this paper, we first formally establish that this tradeoff is unavoidable,
by showing that 
(a) sound and complete deadlock prediction is intractable, in general,
and (b) even the seemingly simpler task of determining the presence of \emph{potential} deadlocks,
which often serve as unsound witnesses for actual predictable deadlocks, is intractable.
The main contribution of this work is a new class of predictable deadlocks, 
called \emph{sync(hronization)-preserving} deadlocks.
Informally, these are deadlocks
that can be predicted by reordering the observed execution while preserving the relative order of conflicting critical sections.
 % predicted without reasoning about reorderings of lock-acquisition events that do not participate in the deadlock.
% This notion allows for efficient checks for realizability of a given deadlock pattern.
We present two algorithms for \emph{sound} deadlock prediction based on this notion.
Our first algorithm~\SyncPDOffline detects all sync-preserving deadlocks, with running time that is linear per \emph{abstract deadlock pattern}, a novel notion also introduced in this work.
%by first efficiently enumerating all \emph{deadlock patterns}
%and then checking if they are sync-preserving (and thus predictable) in a separate pass,
%spending linear time per \emph{abstract deadlock pattern}, 
%which captures all deadlock patterns having the same signature.
Our second algorithm~\SyncPDOnline predicts all sync-preserving deadlocks
that involve two threads in a \emph{strictly online} fashion, runs in overall linear time, 
and is better suited for a runtime monitoring setting.
%where storing the entire execution is not desirable. -- \Andreas{This is not true for us}
% Our second algorithm~\SyncPDOffline detects all sync-preserving deadlocks
% (of all sizes) by first efficiently enumerating all \emph{deadlock patterns}
% and then checking if they are sync-preserving (and thus predictable) in a separate pass,
% spending linear time per \emph{abstract deadlock pattern}, which captures all deadlock patterns having the same signature.
% 
% 
% We next present~\SyncPDOnline, an \emph{online}, \emph{sound} and \emph{complete}, and \ucomment{\emph{nearly}}\emph{-linear} time algorithm for detecting all sync-preserving deadlocks of size $2$.
% Further, we present SyncPDOffline, an offline version of SyncPD that is complete for sync-preserving deadlocks of arbitrary size.

%\ucomment{Remove description about \seqc.}
We implemented both our algorithms and evaluated their ability to perform offline and online deadlock-prediction on a large dataset of standard benchmarks.
Our results indicate that our new notion of sync-preserving deadlocks is highly effective, as
(i)~it can characterize the vast majority of deadlocks and
(ii)~it can be detected using an online, sound, complete and highly efficient algorithm.
\end{abstract}

% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011074.10011099</concept_id>
% <concept_desc>Software and its engineering~Software verification and validation</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003752.10010070</concept_id>
% <concept_desc>Theory of computation~Theory and algorithms for application domains</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% <concept>
% <concept_id>10003752.10010124.10010138.10010143</concept_id>
% <concept_desc>Theory of computation~Program analysis</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~Software verification and validation}
% \ccsdesc[300]{Theory of computation~Theory and algorithms for application domains}
% \ccsdesc[300]{Theory of computation~Program analysis}


%% Keywords
% \keywords{concurrency, dynamic analyses, deadlock prediction, runtime verification}