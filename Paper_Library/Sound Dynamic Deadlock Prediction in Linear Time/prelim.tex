%!TEX root=./main.tex

\section{Preliminaries}
\seclabel{prelim}

Here we set up our model and develop relevant notation,
following related work in predictive analyses of concurrent programs~\cite{Smaragdakis12,Kini2017,Roemer20}.
%\Andreas{@Hunkar: Add here a citation to M. Bond's paper, e.g., PLDI 2020}

\myparagraph{Execution traces}{
	A dynamic analysis observes traces
	generated by a concurrent program,
	and analyzes them to determine the presence of a bug.
	Each such trace $\tr$ is a linear arrangement of events $\events{\tr}$.
	An event $e \in \events{\tr}$ is tuple $e = \ev{i, t, o}$, 
	where $i$ is a unique identifier of $e$,
	$t$ is the unique identifier of the thread performing $e$, and $o$
	is either a read or write ($o = \rd(x)$ or $o = \wt(x)$)
	operation to some variable $x$,
	or an acquire or release ($o = \acq(\lk)$ or $o = \rel(\lk)$)
	operation on some lock $\lk$.
	For the sake of simplicity, we often omit $i$ when referring to an event.
	We use $\ThreadOf{e}$ and $\OpOf{e}$ to respectively denote
	the thread identifier and the operation performed in the event $e$.
	We use $\threads{\tr}$, $\vars{\tr}$ and $\locks{\tr}$
	to denote the set of thread, variable and lock identifiers
	 in $\tr$.

	%Traces are well-formed.
	We restrict our attention to \emph{well-formed} traces $\tr$, that abide to shared-memory semantics.
	%This means that, 
	That is, if a lock $\lk$
	is acquired at an event $e$ by thread $t$, then any later acquisition
	event $e'$ of the same lock $\lk$
	must be preceded by an 
	event $e''$ that releases lock $\lk$ in thread $t$
	in between the occurrence of $e$ and $e'$.
	Taking $e''$ to be the earliest such release event,
    %\footnote{For ease of 
	%presentation we do not consider re-entrant locks. 
	%All our results extend naturally to re-entrant locking.},
	we say that $e$ and $e''$ are matching acquire and 
	release events, and denote this by $e = \match{\tr}(e'')$ and $e'' = \match{\tr}(e)$.
	Moreover, every read event has at least one preceding write event on the same location, that it reads its value from.
	% We will restrict our attention to well-formed traces only.
}

\myparagraph{Functions and relations on traces}{
	A trace $\tr$ implicitly defines some relations.
	The \emph{trace-order} $\trord{\tr} \subseteq \events{\tr}\times\events{\tr}$ 
	orders the events of $\tr$ in a total order based
	on their order of occurrence in the sequence $\tr$.
	The \emph{thread-order} $\tho{\tr}$
	is the unique partial order over $\events{\tr}$ 
	such that $e \tho{\tr} e'$
	iff $\ThreadOf{e} = \ThreadOf{e'}$ and $e \trord{\tr} e'$.
	We say $e \stricttho{\tr} e'$ if $e \tho{\tr} e'$ but $e \neq e'$. 
	The \emph{reads-from} function $\rf{\tr}$ is a map
	from the read events to the write events in $\tr$.
	Under sequential consistency, for 
	a read event $e$ on variable $x$, we have that $e' = \rf{\tr}(e)$
	be the latest write event on the same variable $x$
	such that $e' \trord{\tr} e$.
	We say that a lock $\lk \in \locks{\tr}$ is held at an event
	$e \in \events{\tr}$ if there is an event $e'$
	such that (i)~$\OpOf{e'} = \acq(\lk)$, 
	(ii)~$e' \stricttho{\tr} e$, and
	(iii)~either $\match{\tr}(e')$ does not exist in $\tr$,
	or $e \tho{\tr} \match{\tr}(e')$.
	We use $\lheld{\tr}(e)$ to denote the set of all the locks
	that are held by $\ThreadOf{e}$ right before $e$.
	The lock nesting depth of $\tr$ is $\max\limits_{e \in \events{\tr}} |\lheld{\tr}(e)|+1$ where $\OpOf{e} = \acq(\lk)$.
}

\myparagraph{Deadlock patterns}{
	A deadlock pattern\footnote{Similar notions have been used in the literature, sometimes under the term \emph{deadlock potential~\cite{Havelund2000}.}} of size $k$ in a trace $\tr$ is a sequence 
	$D = \pattern{e_0, e_1, \ldots, e_{k-1}}$,
	with $k$ distinct threads $t_0, \ldots, t_{k-1}$
	and $k$ distinct locks $\lk_0, \ldots, \lk_{k-1}$ such that
	$\ThreadOf{e_i} = t_i$, $\OpOf{e_i} = \acq(\lk_i)$,
	$\lk_i \in \lheld{\tr}(e_{(i+1)\%k})$,
	and further, $\lheld{\tr}(e_i) \cap \lheld{\tr}(e_j) = \emptyset$ for every 
	%$0 \leq i, j < k$.
	$i, j$ such that $i \neq j$ and $0 \leq i, j < k$.
%	Prior works on dynamic deadlock detection~\cite{Havelund2000,Agarwal2005}
%	focused on detecting patterns (aka deadlock potentials) in traces.
	A deadlock pattern is a necessary but insufficient condition of an actual deadlock,
	due to subtle synchronization or control and data flow in the underlying program.
}

\myparagraph{Dynamic predictive analysis and correct reorderings}{
%	We intend to design a \emph{dynamic} deadlock detection technique that
%	observes a trace $\tr$ generated by a concurrent program, and 
%	determines the existence of a deadlock in the program by analyzing this trace,
%	without actually accessing the source code.
%	While such a purely dynamic approach enjoys the benefits of scalability,
%	a naive approach of only checking deadlocks that are witnessed in the observed trace
%	will likely miss many bugs, especially because concurrency bugs
%	are often subtle and manifest only in select thread interleavings~\cite{Musuvathi2008},
%	amongst an exponentially large set of interleavings.
%	\emph{Predictive} dynamic analysis intends to solve
%	exactly this problem --- instead of considering the observed execution
%	as is, such an analysis techniques \emph{predicts} the occurrence of
%	a concurrency bug in  alternate executions
%	that can be \emph{inferred} from the observed execution trace,
%	\emph{without} requiring the knowledge of the underlying program.
	Dynamic analyses aim to expose bugs by observing traces $\tr$ of a concurrent program, often without accessing the source code.
	While such purely dynamic approaches enjoy the benefits of scalability,
	simply detecting bugs that manifest on $\tr$ offer poor coverage and are bound to miss bugs that appear in select thread interleavings~\cite{Musuvathi2008}.
	Therefore, for better coverage, \emph{predictive} dynamic techniques are developed. 
	Such techniques predict the occurrence of bugs in alternate executions that can be \emph{inferred} from $\tr$,
	irrespective of the program that produced $\tr$.
	The notion of such inferred executions is formalized by the notion
	of correct reorderings~\cite{Smaragdakis12,serbanuta2013,Koushik05}.
	
	A trace $\rho$ is a \emph{correct reordering} of a trace $\tr$ if 
	\begin{enumerate*}[label=(\arabic*)]
		\item $\events{\rho} \subseteq \events{\tr}$,
		\item for every $e, f \in \events{\tr}$ with $e \tho{\tr} f$,
		if $f \in \events{\rho}$, then $e \in \events{\rho}$
		and $e \tho{\rho} f$, and
		\item for every read event $r \in \events{\rho}$, we have
		$\rf{\tr}(r) \in \events{\rho}$ and
		$\rf{\rho}(r)=\rf{\tr}(r)$.
	\end{enumerate*}
	Intuitively, a correct reordering $\rho$ of $\tr$ is a permutation of $\tr$
	that respects the thread order and preserves the values of each read and write
	that occur in $\rho$.
	This ensures a key property --- every program that generated 
	$\tr$ is also capable of generating $\rho$
	(possibly under a different thread schedule),
	and thus $\rho$ serves as a true witness of a bug.
	% Indeed, if $\rho$ is not a correct reordering of $\tr$,
	% one can construct a program $P$ that generates $\tr$ but not $\rho$~\cite{serbanuta2013},
	% and thus any conclusions drawn from $\rho$ may be inapplicable.
}

\myparagraph{Predictable deadlocks}{
%	Our work focuses on \emph{sound prediction}.
%	Here, one checks if an observed trace of a concurrent program 
%	has a \emph{predictable deadlock}, i.e.,
%	it can be correctly reordered to 
%	a trace that witnesses a deadlocked execution.
%	This is formalized as follows.
	We say that an event $e$
	is $\tr$-enabled in a correct reordering $\rho$ of $\tr$
	if $e \in \events{\tr}$, $e \not\in \events{\rho}$
	and for every $f \in \events{\tr}$ if $f \stricttho{\tr} e$,
	then $f \in \events{\rho}$.
	A deadlock pattern $D = \pattern{e_0, e_1 \ldots e_{k-1}}$
	of size $k$ in trace $\tr$ is said to be a predictable deadlock
	if there is a correct reordering $\rho$ of $\tr$
	such that each of $e_0, \ldots, e_{k-1}$
	are $\tr$-enabled in $\rho$.
	This notion guarantees that the witness $\rho$ is a valid execution of \emph{any}
	concurrent program that produced $\tr$.
	Analogous definitions have also been widely used for other predictable bugs~\cite{Huang14,Smaragdakis12}.
	We call a deadlock-prediction algorithm \emph{sound} if for every input trace $\tr$, 
	all deadlock reports on $\tr$ are predictable deadlocks of $\tr$ (i.e., no false positives), 
	and \emph{complete} if all predictable deadlocks of $\tr$ are reported by the algorithm (i.e., no false negatives).
	This is in line with the previous works on the topic of predictive analyses~\cite{Cai2021, Kalhauge2018, Mathur2021, Pavlogiannis2020}.
	We remark that other domains sometimes use this terminology reversed.
}
% 
% \begin{remark}
% Observe that whenever a program exhibits a deadlock, 
% this will indeed be witnessed by an execution that has the form of $\rho$,
% i.e., where the deadlocking threads are blocked on some lock-acquisition event,
% these lock-acquisition events being \emph{enabled} in such a deadlocked execution.
% Some related work~\cite{Kalhauge2018} distinguishes between lock-request 
% and lock-acquisition events,
% and defines deadlocks in terms of the former.
% While, we do not consider request events for clarity of presentation,
% we remark that incorporating such events, 
% and using them to define deadlocks is completely straightforward
% and results in an equivalent notion.
% Our implementation handles request events naturally, 
% as they are sometimes generated in our benchmarks.
% \end{remark}
% 
\begin{comment}
\begin{remark}
Prior works~\cite{Kalhauge2018} propose the use of lock-request events,
which precede lock-acquisition events.
In our work, we do not model such events as the notion of enabled
events implicitly captures them.
Our benchmarks and our
implementation handles them naturally.
\end{remark}
\end{comment}
% 
\begin{example}
\exlabel{prelim-defs}
Let us illustrate these definitions on the trace $\tr_2$
in \figref{motivating-dl}, with $e_i$ denoting the $i^\text{th}$ event in the figure.
The set of events,
threads, variables and locks of $\tr_2$ are respectively $\events{\tr_2} = \set{e_i}_{i=1}^{20}$,
$\threads{\tr_2} = \set{t_1, t_2, t_3, t_4}$,
$\vars{\tr_2} = \set{x, y, z}$ and 
$\locks{\tr_2} = \set{\lk_1, \lk_2, \lk_3}$.
The trace order yields
$e_i \trord{\tr_2} e_j$ iff $i \leq j$,
and some examples of thread-ordered events are
$e_1 \stricttho{\tr_2} e_2 \stricttho{\tr_2} e_{15}$ and $e_{16} \stricttho{\tr_2} e_{18} \stricttho{\tr_2} e_{20}$.
The reads-from function is as follows: 
$\rf{\tr_2}(e_{10}) = e_5$, $\rf{\tr_2}(e_{14}) = e_9$ and $\rf{\tr_2}(e_{17}) = e_{13}$.
The lock nesting depth of $\tr_2$ is $2$.
The sequence $D = \pattern{e_4, e_{18}}$ forms a deadlock pattern
because of the cyclic acquisition of locks $\lk_2$ and $\lk_3$
without simultaneously holding a common lock.
The trace
$\rho_4 = e_3..e_7\,e_8..e_{11}\,e_1 e_2 e_{12}..e_{15}\,e_{16} e_{17}$
is a correct reordering of $\tr_2$;
even though it differs from $\tr_2$ in the relative order of the critical sections of lock $\lk_1$, and
contains only a prefix of thread $t_3$, it is consistent with $\rf{\tr_2}$ and $\stricttho{\tr_2}$.
However, $\rho_4$ does not witness $\pattern{e_4, e_{18}}$ as a deadlock, as
only $e_{18}$ is $\tr_2$-enabled in $\rho_4$.
%while $e_4$ had to be executed in order to comply with the condition imposed by the correct reorderings.
%it differs from $\tr_2$ in the relative order of the critical sections of lock $\lk_1$,
%contains only a suffix of thread $t_3$, but is consistent with $\rf{\tr_2}$ and $\stricttho{\tr_2}$.
On the other hand, the trace $\rho_3 = e_1 e_2 e_3 e_8 e_9 \,e_{12}..e_{15}\,e_{16} e_{17}$
%defined in \cref{subsec:spd_intro}
is a correct reordering of $\tr_2$ in which $e_4$ and $e_{18}$ are $\tr_2$-enabled,
witnessing $D$ as a predictable deadlock of $\tr_2$. 
\end{example}