%!TEX root=./main.tex

\subsection{Our Contributions}\seclabel{contributions}
%In this paper, we advance the state-of-the-art in deadlock prediction on the following forefronts.
In detail, the contributions of this work are as follows.
\begin{enumerate}[label=(\arabic*)]
\item {\bf Complexity of Deadlock Prediction.} Perhaps surprisingly, the complexity of detecting deadlock patterns, as well as predicting deadlocks has remained elusive.
Our first contribution resolves such questions. 
Given a trace $\tr$ of size $\NumEvents$ and $\NumThreads$ threads,
we first show that detecting even one deadlock \emph{pattern} of length $k$ is $\W{1}$-hard in $k$.
This establishes that the problem is $\NP$-hard, and 
further rules out algorithms that are fixed-parameter-tractable in $k$, i.e.,
with running time of the form $f(k)\cdot \poly{\NumEvents}$, for some function $f$.
%This is important as $k$ is typically constant; 
%$\W{1}$-hardness indicates that any algorithm even for the presence of deadlock patterns must run in time of the form $O(\NumEvents^{g(k)})$, i.e., the degree of the polynomial depends on $k$.
% We next show a stronger fine-grained (conditional) hardness ---
% for every $k \geq 2$, there is no algorithm for detecting a
% deadlock \emph{pattern} of size $k$ that runs in time
% $O(\NumEvents^{k-\epsilon})$, no matter what $\epsilon > 0$ we choose.
We next show
that even with just $\NumThreads=2$ threads, the problem of 
detecting a single deadlock \emph{pattern} (of size $k=2$) admits a
quadratic lower bound, i.e., it cannot be solved in time $O(\NumEvents^{2-\epsilon})$,
no matter what $\epsilon > 0$ we choose.
These two results shed light on the difficulty in identifying deadlock patterns --- a task that might otherwise appear easier than the core task of prediction. 
These hardness results, in particular the fine-grained lower bound result,
are based on novel constructions, and results from fine-grained complexity~\cite{williams2018}.
Our third result is about confirming predictable deadlocks ---
even for a deadlock pattern of size $k=2$,
checking whether it yields a \emph{predictable deadlock} is $\W{1}$-hard
in the number of threads $\NumThreads$ (and thus again $\NP$-hard), 
and is inspired from an analogous result in the context of data race prediction~\cite{Mathur2020b}.
These results capture the intractability of deadlock prediction in general, 
even for the class of parametrized algorithms.

\item {\bf Sync-preserving Deadlock Prediction and Abstract Deadlock Patterns.}
Given the above hardness of predicting arbitrary deadlocks,
we define a novel notion of sync(hronization)-preserving deadlocks, illustrated in \cref{subsec:spd_intro}.
We develop $\SyncPDOnline$, an \emph{online, sound} deadlock predictor that takes as input a trace and reports \emph{all} sync-preserving deadlocks of size $2$ in \emph{linear time} $\Otilde(\NumEvents)$\footnote{We use $\Otilde$ to ignore \emph{polynomial} appearance of trace parameters typically much smaller than $\NumEvents$ (e.g., number of threads).}.
As most deadlocks in practice involve only two threads~\cite{Lu08}, restricting $\SyncPDOnline$ to size $2$ deadlocks leads to linear-time deadlock prediction with small impact on its coverage.
We also develop our more general algorithm, $\SyncPDOffline$,
that detects \emph{all} sync-preserving deadlocks of all sizes.
$\SyncPDOffline$ operates in two phases.
In the first phase, it detects all
\emph{abstract deadlock patterns}.
An abstract deadlock pattern is a novel notion that serves as a succinct representation
of the class of deadlock patterns having the same signature.
%(such as sequence of threads and locks acquired and held).
% 
% constructs a lock graph,
% whose nodes are \emph{abstract acquires} representing all dynamic acquire events
% of a given signature,
% and then detects \emph{abstract deadlock patterns} of any size.
In the second phase, $\SyncPDOffline$ executes 
$\SyncPDOnline$ on each abstract pattern to decide whether a deadlock is formed.
The running time of $\SyncPDOffline$ remains linear in $\NumEvents$, 
but increases by a factor proportional to the number 
of abstract deadlock patterns in the lock graph.

\item {\bf Implementation and Evaluation.}
We have evaluated $\SyncPDOnline$ and $\SyncPDOffline$ in terms of performance and predictive power on a large dataset of standard benchmarks.
In the offline setting, $\SyncPDOffline$ finds the same number of deadlocks as the recently introduced \seqc,
 while achieving a speedup of $>200\times$ on the most demanding benchmarks, and $21\times$ overall.
 In the online setting, $\SyncPDOnline$ achieved a significant improvement in deadlock discovery and deadlock-hit-rate compared to the random scheduling based controlled concurrency testing technique of \dlfuzzer~\cite{Joshi2009}.
Our experiments thus support that the notion of sync-preserving deadlocks is suitable:
%(i)~it is likely to characterize the vast majority of deadlocks in the wild, while
(i)~it captures the vast majority of the 
deadlocks in practice, and
%\hunkar{predictable} %deadlocks that are known to exist in our representative benchmarks, and
(ii)~sync-preserving deadlocks can be detected online and optimally --- that is, soundly, completely and in linear time,
(iii)~it can enhance the deadlock detection capability of controlled concurrency testing techniques, 
(iv)~with reasonable runtime overhead.
\end{enumerate}
