%!TEX root = main.tex

\section{Related Work}
\seclabel{related_work}

%Complexity
% Other works characterize the complexity of detecting and predicting data races~\cite{Mathur2020b,Kulkarni2021}, as well as predicting atomicity violations~\cite{Farzan2099}.

% \Andreas{@Umang: fill}



% 1. Deadlock potential detectors
% 2. Sound algorithms
% 3. static analyzers
	% Sound static deadlock analysis for C/Pthreads 
% 4. Deadlock immunity and avoidance and reilience - Dimmunix, UNDEAD, Gadara, "The theory of deadlock avoidance via discrete control"
% 5. Deadlock repair
% 6. Model Checking
% 7. Predictive analysis in general, ConLock, PickLock, Symbolic deadlock analysis in concurrent libraries and their
% clients
% 8. Detecting deadlocks as they occur: Dreadlocks: efficient deadlock detection
% 9. Random scheduling: Radius Aware Probabilistic Testing of Deadlocks with Guarantees., DeadlockFuzzer, MagicFuzzer (ppotential and re-execution), MagicLock

%Recall that a deadlock pattern --- a cyclic dependency
%where each lock attempts to acquire a lock held by
%another thread --- can be an indication of an actual deadlock
%in the underlying code, but may not be sufficient to prove
%that a deadlock may, in fact, occur.

%Static-analysis techniques such as~\cite{Williams2005a,Engler2003,Naik2009,Ng2016,Liu2021,kroenig2016}
%report deadlock patterns determined statically,
%or use a strict type system~\cite{Boyapati2002} to enforce a global
%ordering on locks,
%but may report false deadlock patterns, miss some or not scale.
% Dynamic techniques detect deadlock patterns
% by analyzing executions of instrumented programs,
% and scale well by foregoing source-code coverage.
Dynamic techniques for detecting deadlock patterns,
like the GoodLock algorithm~\cite{Havelund2000}
have been improved in performance~\cite{Cai2020,zhou2017undead}
and precision~\cite{Bensalem2005}, sometimes using re-executions to verify potential deadlocks~\cite{Samak2014,Samak2014b,Sorrentino2015,Joshi2009,Bensalem2006}.
%an intractable problem, in general (as we show in~\thmref{pattern-w1-hardness-pattern}).
% Techniques for re-executing the program~\cite{Samak2014,Samak2014b,Sorrentino2015}
% using controlled scheduling~\cite{Joshi2009,Bensalem2006}
% have been proposed to remove false positives.
%Re-execution based techniques
%address false positives in such techniques.
% Since a deadlock pattern may not be a real deadlock,
% further techniques attempt to drive
% the underlying program to a deadlocked state, either
% by reusing execution information~\cite{Samak2014,Samak2014b,Sorrentino2015},
% or by controlling the scheduler~\cite{Joshi2009,Bensalem2006}.
%Model checking techniques such as~\cite{havelund2000model} offer a balance
%of soundness and coverage but do not scale.
%
Predictive analyses directly infer concurrency bugs in
alternate executions~\cite{serbanuta2013} and are typically
\emph{sound} (no false positives).
This approach has been successfully applied for
detecting bugs 
% rooted in ordering inconsistencies 
such as data races~\cite{Said11,Huang14,Smaragdakis12,Kini2017,Pavlogiannis2020,Mathur2021,Roemer20}, use-after-free vulnerabilities~\cite{Huang2018}, and more recently for deadlocks~\cite{Eslamimehr2014,Kalhauge2018,Cai2021}.

% Predictive analyses aim to infer
% alternate executions that witness a concurrency bug
% from observed, bug-free executions.
% Such techniques typically 
% model and search the space of feasible reorderings~\cite{serbanuta2013} and are usually 
% \emph{sound} --- a reported bug is realized by some execution of the underlying program.
% This approach has seen a lot of success in
% detecting bugs rooted in ordering inconsistencies such as
% data races~\cite{Said11,Huang14,Smaragdakis12,Kini2017,Pavlogiannis2020,Mathur2021,Roemer20}
% and use-after-free vulnerabilities~\cite{Huang2018}.
% Predictive analyzers for deadlocks include SherLock~\cite{Eslamimehr2014}, \dirk~\cite{Kalhauge2018}, and more recently, \seqc~\cite{Cai2021}.

%In our evaluation we compare extensively against \dirk and \seqc.
%(the authors of SherLock informed us that the tool is not available) \hunkar{I think this sentence looks a bit out of place}.
%Hence, a comparison with SherLock was not possible.
%which we compare against extensively in our evaluation.

The notion of sync-preserving deadlocks has been inspired by 
a similar notion pertaining to data races~\cite{Mathur2021}.
However, sync-preserving deadlock prediction rests on some further novelties.
First, unlike data races, deadlocks can involve more than $2$ events.
Generalizing sync-preserving ideals of sets of events of arbitrary size, as well as 
establishing the monotonicity properties (\propref{spclosure-monotone} and \corref{pattern-monotone}) for arbitrarily many events is non-trivial.
Second, our notions of abstract deadlock patterns (\secref{verify-abstract-patterns}) 
and abstract lock graphs (\secref{enumerate-patterns}) are novel and carefully crafted
to leverage these monotonicity properties in the deadlock setting.
Indeed, the linear-time sync-preserving verification of each abstract deadlock pattern is the cornerstone of our approach, for the first linear-time, sound and precise deadlock predictor.
%which otherwise can be employed in a more straightforward manner for the case of data races.
%The efficiency of our algorithms heavily rely on 
%(a)~efficiently verifying
%each abstract pattern, which for the case of synchronization-preserving deadlocks
%can be performed in linear time, and 
%(b)~the empirical observation that the number of abstract patterns is typically much smaller
%than the number of concrete patterns in practice.

Although the basic principles of data-race and deadlock prediction are similar, there are notable differences.
First, identifying potential deadlocks is theoretically intractable, whereas, potential races are identified easily. 
Second, popular partial-order based techniques~\cite{Flanagan09,Kini2017} for data races are likely to require non-trivial modifications for deadlocks, as they typically order critical sections, which may hide a deadlock.
Nevertheless, bridging prediction techniques between data races and deadlocks is an interesting and relatively open direction.

Predicting deadlocks is an intractable problem, the complexity of which we have characterized in this work. 
%(see our result for deadlock prediction~\thmref{w1-hardness-pattern})
%due to exponential many thread interleavings that need be explored
%and prior techniques tend suffer from scalability bottlenecks.
%In our work, we consider a subset of interleavings (\emph{sync-preserving} correct reorderings)
%and show through our evaluation that these are often sufficient to reveal deadlocks.
Prior works have also focused on the complexity of predicting data races~\cite{Mathur2020b,Kulkarni2021} and atomicity violations~\cite{Farzan2099}.

