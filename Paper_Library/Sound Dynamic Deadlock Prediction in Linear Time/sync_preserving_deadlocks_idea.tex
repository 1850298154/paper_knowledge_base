%!TEX root=./main.tex

\subsection{Synchronization-Preserving Deadlocks}
\label{subsec:spd_intro}

% Here we illustrate our new notion of \emph{sync(hronization)-preserving deadlocks}, which forms a subclass of predictable deadlocks.
% Later we provide formal definition, and develop an online, efficient, sound and complete algorithm for predicting sync-preserving deadlocks.

%\input{figures/fig_motivating}
\input{figures/fig_motivating2}

% \ucomment{Get back.}

%Consider the trace $\tr$ in \figref{motivating} consisting of 
%$20$ events and four threads.
Consider the trace $\tr_1$ in \cref{fig:motivating-no-dl} consisting of 
$10$ events and two threads.
We use $e_i$ to denote the $i$-th event of $\tr_1$.
%The events $e_4$ and $e_{18}$ form a \emph{deadlock pattern}:~
The events $e_2$ and $e_{8}$ form a \emph{deadlock pattern}:~
%each one acquires a lock already held when the other is executed  
%while no common lock protects both.
%they respectively acquire the locks $\LockColorThree{\lk_3}$ and $\LockColorTwo{\lk_2}$ while holding the locks $\LockColorTwo{\lk_2}$ and $\LockColorThree{\lk_3}$,
they respectively acquire the locks $\LockColorTwo{\lk_2}$ and $\LockColorOne{\lk_1}$ while holding the locks $\LockColorOne{\lk_1}$ and $\LockColorTwo{\lk_2}$,
and no common lock protects these operations.

A deadlock pattern is a necessary but insufficient condition for an actual deadlock:~a sound algorithm must examine whether it can be realized to a deadlock via a witness.
A witness is a reordering $\rho$ of (a slice of) $\tr_1$ 
%that is also a valid trace, and such that $e_4$ and $e_{18}$ are locally enabled in their respective threads at the end of $\rho$.
that is also a valid trace, and such that $e_2$ and $e_{8}$ are locally enabled in their respective threads at the end of $\rho$.
%\hunkar{Observe that arriving at such a state where all the events that participate in the deadlock pattern are locally enabled in their respective threads corresponds to detecting an actual deadlock as none of those enabled events can be executed.}
In general, the problem of checking if a deadlock pattern
can be realized is intractable
(\thmref{w1-hardness-pattern}).
% Prior works encode the problem as a SAT or SMT constraint
% and invoke a solver~\cite{Kalhauge2018,Eslamimehr2014},
% but cannot scale to large traces without
% \emph{windowing} where one limits the analysis to fragments of smaller size.
% In doing so, they tend to miss simple deadlocks too.
%In this work we focus on checking whether $\pattern{e_4,e_{18}}$ forms a 
In this work we focus on checking whether a given deadlock pattern forms a
\emph{sync-preserving deadlock}, which is a subclass of the class of
all predictable deadlocks.
%Intuitively, the process goes as follows.

A deadlock pattern is said to be sync-preserving deadlock
if it can be witnessed in a \emph{sync-preserving reordering}.
A reordering $\rho^{\sf SP}$ of a trace $\tr$ is said to be sync-preserving if 
it preserves the control
flow taken by the original observed trace $\tr$, and further
it preserves the mutual order of any two critical sections (on the same lock)
that appear in the reordering $\rho^{\sf SP}$.
Consider, for example, the sequence $\rho_1 = e_1..e_3\,e_6..e_7$ where $e_i..e_j$ denote the contiguous sequence of events
that starts from $e_i$ and ends at $e_j$. 
We call $\rho_1$ a \emph{correct reordering} of $\tr_1$, being a slice of $\tr_1$ closed under the thread order and preserving the writer of each read in $\tr_1$;
the precise definition is presented in \secref{prelim}.
%\hunkar{
In this case, however, $\rho_1$ does not witness the deadlock as the event $e_2$ is not \emph{enabled} in $\rho_1$.
In fact, due to the dependency between the events $e_3$ and $e_7$, there are no correct reorderings of $\tr_1$ which make both $e_2$ and $e_8$ enabled.
This makes the deadlock pattern $\pattern{e_2, e_{8}}$ non-predictable.
%}
Consider now $\tr_2$ in \cref{fig:motivating-dl}, and the sequence $\rho_2 = e_3..e_7\,e_8..e_{11}\,e_1 e_2$.
Observe that $\rho_2$ is also a correct reordering.
However, $\rho_2$ is not sync-preserving as the order of 
the two critical sections
on lock $\lk_1$ in $\rho_2$ is different from their original order in $\tr_2$.
On the other hand, $\rho_3 = e_1 e_2 e_3 e_8 e_9 \,e_{12}..e_{15}\,e_{16} e_{17}$
is a correct reordering that is also sync-preserving --- all pairs of critical 
sections on the same lock appear in the same order in $\rho_3$ as they did in $\tr_2$.
Further, $\rho_3$ also witnesses the deadlock as the events $e_4$ and $e_{18}$
are both \emph{enabled} in $\rho_3$.
This makes the deadlock pattern $\pattern{e_4, e_{18}}$ a sync-preserving deadlock.
%\hunkar{
%We note that in the witness $\rho_2$ the events $e_4$ and $e_{18}$ are enabled but not executed.
%Hence, having executed $e_{12}$ in $\rho_2$, which appears after $e_{4}$ in the original order, does not %lead to switching the order of critical sections on lock $\LockColorThree{\lk_3}$.
%}
\begin{comment}
We will attempt to construct a certain slice of $\tr$, which we call a \emph{sync-preserving closure set} $\mathcal{I}$ for the focal events $e_4$ and $e_{18}$.
Since these events must be  enabled in their respective threads, their immediate local predecessors are taken in $\mathcal{I}$, i.e., $e_3, e_{17}\in \mathcal{I}$.
As $\mathcal{I}$ is a slice of $\tr$, all the indirect local predecessors of all events in $\mathcal{I}$ are also in $\mathcal{I}$, i.e., all events of $t_2$ and $t_3$ up to $e_3$ and $e_{17}$, respectively.
Note that $e_{17}$ is a read event, reading its value from the write event $e_{13}$.
For this reason, we take $e_{13}$, as well as all its local predecessors in $\mathcal{I}$.
At this point, the critical section of $t_1$ on $\lk_3$ opened by $e_{12}$ is open in $\mathcal{I}$,
as the matching release event $e_{15}\not \in \mathcal{I}$.
At the same time, $e_{16}$ opens a critical section also on $\lk_3$, while also $e_{16}\in \mathcal{I}$.
The sync-preservation property requires that, since $e_{16}$ appears \emph{after} $e_{13}$ in $\tr$, we have to include the matching release event $e_{15}$ of $e_{13}$ (as well as its local predecessors) in $\mathcal{I}$.
Note that this brings the read event $e_{14}$ in $\mathcal{I}$.
Similar reasoning as before will bring $e_{8}\in \mathcal{I}$, which is an acquire event on lock $\lk_1$.
At this point we must again decide on whether we will close this critical section, i.e., bring $e_{11}$ in $\mathcal{I}$.
Note that there is another acquire event on lock $\lk_1$ already in $\mathcal{I}$, namely $e_1$.
However $e_1$ appears before $e_{8}$ in $\tr$, sync-preservation allows the critical section on $e_8$ to remain open.
At this point we have completed the computation of $\mathcal{I}$, and as we have $e_4, e_{18}\not \in \mathcal{I}$,
we conclude that these two events indeed constitute a predictable deadlock, witnessed by $\rho=\tr\Project \mathcal{I}$,
i.e., by the same trace $\tr$ when sliced on $\mathcal{I}$.
Note that if we included $e_{10}$ in $\mathcal{I}$ then, due to $e_9$, we would also have to include $e_5$ in $\mathcal{I}$, which would result in $e_4\in \mathcal{I}$, in which case $\tr\Project \mathcal{I}$ would not be a valid witness for the deadlock.
\end{comment}


In this work we show that sync-preserving deadlocks enjoy two remarkable properties.
First, all sync-preserving deadlocks 
of a given \emph{abstract} deadlock pattern can be checked in linear time.
%Second, sync-preservation appears to capture almost all deadlocks that exist in the practice.
Second, our extensive experimental evaluation on standard benchmarks indicates that 
sync-preservation captures 
%almost all the deadlocks that are known to exist in practice.
a vast majority of deadlocks in practice.
In combination, these two benefits suggest that sync-preservation is the 
right notion of deadlocks to be targeted by dynamic deadlock predictors.