%!TEX root = main.tex

\subsection{Characterizing Sync-Preserving Deadlocks}
\seclabel{characterize-patterns}

There are two fundamental tasks in 
searching for a correct reordering that witnesses a deadlock --- 
(i)~determining the set of events in the correct reordering, and 
(ii)~identifying a total order on such events --- both of which are intractable~\cite{Mathur2020b}.
On the contrary, for sync-preserving deadlocks, we show that
(a)~the search for a correct reordering can be reduced
to the problem of checking if some well-defined set of events (\defref{spclosure})
does not contain the events appearing in the deadlock pattern (\lemref{spclosure-deadlock}),
and that (b)~this set can be constructed efficiently.
%These results directly extend the results of prior work
%on race detection~\cite{Mathur2021} to the more general
%case of checking concurrency of \emph{arbitrarily many} events.
%Let us define this set next.
\begin{definition}[Sync-Preserving Closure]
\deflabel{spclosure}
Let $\tr$ be a trace and $S \subseteq \events{\tr}$.
The sync-preserving closure of $S$, denoted
$\SPClosure{\tr}(S)$ is the smallest set $S'$ such that
\begin{enumerate*}[label=(\alph*)]
	\item \itmlabel{def-item-spclosure-a} $S \subseteq S'$,
	\item \itmlabel{def-item-spclosure-b} for every $e, e' \in \events{\tr}$ such that 
	$e \stricttho{\tr} e'$ or $e = \rf{\tr}(e')$, if $e' \in S'$, then $e \in S'$, and
	\item\itmlabel{acq-order-closure} for every lock $\lk$ and every two distinct events $e, e'\in S'$ with $\OpOf{e} = \OpOf{e'} = \acq(\lk)$,
	if $e \trord{\tr} e'$ then $\match{\tr}(e) \in S'$.
\end{enumerate*}
\end{definition}


\defref{spclosure} resembles 
the notion of correct reorderings (\defref{syncp-correct-reordering}). 
Indeed, \lemref{spclosure-necessary-sufficient} justifies using this set --- it is
both a necessary and a sufficient set for sync-preserving correct reorderings.

\begin{restatable}{lemma}{spclosureNecessarySufficient}
\lemlabel{spclosure-necessary-sufficient}
Let $\tr$ be a trace and let $S \subseteq \events{\tr}$.
For any sync-preserving correct reordering $\rho$ of $\tr$, 
	if $S \subseteq \events{\rho}$, then $\SPClosure{\tr}(S) \subseteq \events{\rho}$.
	Further, there is a sync-preserving correct reordering $\rho$ of 
	$\tr$ such that $\events{\rho} = \SPClosure{\tr}(S)$.
% \begin{enumerate}[label=(\arabic*)]
% 	\item For any sync-preserving correct reordering $\rho$ of $\tr$, 
% 	if $S \subseteq \events{\rho}$, then $\SPClosure{\tr}(S) \subseteq \events{\rho}$.
% 	\item There is a sync-preserving correct reordering $\rho$ of 
% 	$\tr$ such that $\events{\rho} = \SPClosure{\tr}(S)$.
% \end{enumerate}
\end{restatable}

%\hunkar{
For an intuition, consider again \cref{fig:syncp_example} and the sync-preserving correct reordering $\rho_5 = e_1..e_7e_8..e_{11}e_{12}..e_{15}\,e_{28}$ computed in \cref{ex:sp-deadlocks}.
According to \cref{lem:spclosure-necessary-sufficient}, $\SPClosure{\tr_3}(S) \subseteq \events{\rho_5}$ holds for all $S$ such that $S \subseteq \events{\rho_5}$.
For example, if we take $S=\set{e_1, e_{15}}$ then observe that $S \subseteq \events{\rho_5} $ and  $\SPClosure{\tr_3}(S)=\set{e_1, \ldots, e_6, \, e_8, \ldots e_{15}} \subseteq \events{\rho_5}$ holds.
%}

%\hunkar{
%Can we provide any intuition on the second part of the lemma?
%}
Based on~\lemref{spclosure-necessary-sufficient}, we 
present a sound and complete characterization of sync-preserving deadlocks
(\lemref{spclosure-deadlock}).
For a set $S \subseteq \events{\tr}$, 
we let $\prev{\tr}(S)$ denote the set of immediate thread
predecessors of events in $S$. 
That is,
$\prev{\tr}(S) = \setpred{e \in \events{\tr}}{\exists f \in S, e \stricttrord{\tr} f \text{ and } \forall e' \stricttrord{\tr} f, e' \tho{\tr} e}$.
% \begin{restatable}{lemma}{spclosure-iff-syncp-correct-reordering}
% \lemlabel{spclosure-iff-syncp-correct-reordering}
% Let $\tr$ be a trace and let $S \subseteq \events{\tr}$.
% There is a sync-preserving correct reordering $\rho$ of $\tr$
% in which each event $e \in S$ is $\tr$-enabled iff 
% $\SPClosure{\tr}(\prev{\tr}(S)) \cap S = \emptyset$.
% \end{restatable}

\begin{restatable}{lemma}{spclosureDeadlock}
\lemlabel{spclosure-deadlock}
Let $\tr$ be a trace and let $D = \pattern{e_0, \ldots, e_{k-1}}$
be a deadlock pattern of size $k$ in $\tr$.
$D$ is a sync-preserving deadlock of $\tr$ iff
$\SPClosure{\tr}(\prev{\tr}(S)) \cap S = \emptyset$, where
$S = \set{e_0, \ldots, e_{k-1}}$.
\end{restatable}

\input{example-syncp}
