

\documentclass{article}

% if you need to pass options to natbib, use, e.g.:
%     \PassOptionsToPackage{numbers, compress}{natbib}
% before loading neurips_2021

\PassOptionsToPackage{round}{natbib}
% ready for submission
\usepackage[final]{neurips_2021}

% to compile a preprint version, e.g., for submission to arXiv, add add the
% [preprint] option:
%     \usepackage[preprint]{neurips_2021}

% to compile a camera-ready version, add the [final] option, e.g.:
%     \usepackage[final]{neurips_2021}

% to avoid loading the natbib package, add option nonatbib:
%    \usepackage[nonatbib]{neurips_2021}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{algorithm} 
\usepackage{algpseudocode} 
\usepackage{subfigure}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{tikz}

\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\newtheorem{theorem}{Theorem}
\newtheorem*{theorem*}{Theorem}
\newtheorem{propo}{Proposition}
\newtheorem*{propo*}{Proposition}

% 固定行距：
% \usepackage{setspace}
% \setlength{\baselineskip}{11pt}


\title{Coordinated Proximal Policy Optimization}

% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to LaTeX to determine where to break the
% lines. Using \AND forces a line break at that point. So, if LaTeX puts 3 of 4
% authors names on the first line, and the last on the second line, try using
% \AND instead of \And before the third author name.

\author{
%   Zifan Wu\thanks{Use footnote for providing further information
%     about author (webpage, alternative address)---\emph{not} for acknowledging
%     funding agencies.} \\
%   Department of Computer Science\\
%   Cranberry-Lemon University\\
%   Pittsburgh, PA 15213 \\
%   \texttt{hippo@cs.cranberry-lemon.edu} \\
  Zifan Wu \\
  School of Computer Science and Engineering\\
  Sun Yat-sen University, Guangzhou, China \\
  \texttt{wuzf5@mail2.sysu.edu.cn} \\
%   examples of more authors
   \And
   Chao Yu\thanks{Corresponding authors.}\\
  School of Computer Science and Engineering\\
  Sun Yat-sen University, Guangzhou, China \\
  \texttt{yuchao3@mail.sysu.edu.cn} \\
   \And
   Deheng Ye \\
  Tencent AI Lab, Shenzhen, China \\
  \texttt{dericye@tencent.com} \\
   \And
   Junge Zhang$^{*}$\\
  Institute of Automation \\
  Chinese Academy of Science, Beijing, China \\
  \texttt{jgzhang@nlpr.ia.ac.cn} \\
   \And
   Haiyin Piao \\
  School of Electronic and Information\\
  Northwestern Polytechnical University, Xian, China \\
  \texttt{haiyinpiao@mail.nwpu.edu.cn} \\
    \And
    Hankz Hankui Zhuo \\
    School of Computer Science and Engineering\\
  Sun Yat-sen University, Guangzhou, China\\
\texttt{zhuohank@mail.sysu.edu.cn}

}


\begin{document}

\maketitle

\begin{abstract}
We present Coordinated Proximal Policy Optimization (CoPPO), an algorithm that extends the original Proximal Policy Optimization (PPO) to the multi-agent setting. 
%The highlight of CoPPO 
The key idea lies in the coordinated adaptation of step size during the policy update process among multiple agents. 
%We examine the effectiveness of CoPPO theoretically and experimentally. 
We prove the monotonicity of policy improvement when optimizing a theoretically-grounded joint objective, and derive a simplified optimization objective based on a set of approximations. % by making a series of transformations and approximations. 
We then interpret that such an objective in CoPPO can achieve dynamic credit assignment among agents, thereby alleviating the high variance issue during the concurrent update of agent policies. 
Finally, we demonstrate that CoPPO outperforms several strong baselines and is competitive with the latest multi-agent PPO method (i.e. MAPPO) under typical multi-agent settings, including cooperative matrix games and the StarCraft II micromanagement tasks. 
  
\end{abstract}

\section{Introduction}
Cooperative Multi-Agent Reinforcement Learning (CoMARL)  shows great promise for solving various real-world tasks, such as traffic light control~\citep{wu2020multi}, sensor network management~\citep{sharma2020distributed} and autonomous vehicle coordination~\citep{yu2019distributed}.
In such applications, a team of agents aim to maximize a joint expected utility through a single global reward. Since multiple agents coexist in a common environment and learn and adapt their behaviour concurrently, the arising non-stationary issue makes it difficult to design an efficient learning method~\citep{HernandezLeal2017ASO, papoudakis2019dealing}.
Recently, a number of CoMARL methods based on Centralized Training Decentralized Execution (CTDE)~\citep{Foerster2016LearningTC}  have been proposed, including policy-based ~\citep{ Lowe2017MultiAgentAF,foerster2018counterfactual, wang2020off, Yu2021TheSE} and value-based methods~\citep{Sunehag2018ValueDecompositionNF,Rashid2018QMIXMV,Son2019QTRANLT, Mahajan2019MAVENMV}. While generally having more stable convergence properties~\citep{gupta2017cooperative, song2019convergence, wang2020off} and being naturally suitable for problems with stochastic policies~\citep{deisenroth2013survey,su2020value}, policy-based methods still receive less attention from the community and generally possess inferior performance against value-based methods, as evidenced in the StarCraft II benchmark~\citep{Samvelyan2019TheSM}.

The performance discrepancy between policy-based and value-based methods can be largely attributed to the inadequate utilization of the centralized training procedure in the CTDE paradigm. Unlike value-based methods that directly optimize the policy via centralized training of value functions using extra global information, policy-based methods only utilize centralized value functions for state/action evaluation such that the policy can be updated to increase the likelihood of generating higher values~\citep{sutton1999policy}. In other words, there is an update lag between intermediate value functions and the final policy in policy-based methods, and merely coordinating over value functions is insufficient to guarantee satisfactory performance \citep{grondman2012survey, fujimoto2018addressing}.

To this end, we propose the \emph{Coordinated Proximal Policy Optimization} (CoPPO) algorithm, a multi-agent extension of PPO \citep{Schulman2017ProximalPO}, to directly coordinate over the agents' policies by dynamically adapting the step sizes during the agents' policy update processes. 
We first prove a relationship between a lower bound of joint policy performance and the update of policies. 
Based on this relationship, a monotonic joint policy improvement can be achieved through optimizing an ideal objective. 
To improve scalability and credit assignment, and to cope with the potential high variance due to non-stationarity, a series of transformations and approximations are then conducted to derive an implementable optimization objective in the final CoPPO algorithm. 
While originally aiming at monotonic joint policy improvement, CoPPO ultimately realizes a direct coordination over the policies at the level of each agent's policy update step size. 
Concretely, by taking other agents' policy update into consideration, CoPPO is able to achieve dynamic credit assignment that helps to indicate a proper update step size to each agent during the optimization procedure. 
In the empirical study, an extremely hard version of the \emph{penalty game} \citep{claus1998dynamics} is used to verify the efficacy and interpretability of CoPPO. 
In addition, the evaluation on the StarCraft II micromanagement benchmark further demonstrates the superior performance of CoPPO against several strong baselines.

The paper is organized as follows:
Section~\ref{Sec:Background} provides a background introduction. Section \ref{Coordinated Proximal Policy Optimization} introduces the derivation process of CoPPO. 
Section~\ref{sec:ex} presents the experimental studies, and Section~\ref{sec:related} reviews some related works. 
Finally, Section~\ref{sec:conclu} concludes the paper.



\section{Background}
\label{Sec:Background}

We model the fully cooperative MARL problem as a Dec-POMDP \citep{Oliehoek2016ACI} which is defined by a tuple $G=\langle N, S,  \Omega, O, A, R, P, \gamma\rangle$.
$N$ is the number of agents and $S$ is the set of true states of the environment.
Agent $i\in\{1, \ldots, N\}$ obtains its partial observation $o^i\in\Omega$ according to the observation function $O(s, i)$, where $s\in S$.
Each agent has an action-observation history $\tau^i\in T\equiv(\Omega\times A)^*$.
At each timestep, agent $i$ chooses an action $a^i\in A$ according to its policy $\pi(a^i|\tau^i)$, and we use $\boldsymbol{a}$ to denote the joint action $\{a^1,\ldots,a^N\}$.
The environment then returns the reward signal $R(s, \boldsymbol{a})$ that is shared by all agents, and shifts to the next state according to the transition function $P(s'|s, \boldsymbol{a})$.
The joint action-value function induced by a joint policy $\boldsymbol{\pi}$ is defined as: $Q^{\boldsymbol{\pi}}(s_t, \boldsymbol{a}_t) = \mathbb{E}_{s_{t+1:\infty}, \boldsymbol{a}_{t+1:\infty}}[\sum_{t'=0}^{\infty}\gamma^{t'}R_{t+t'}|s_t, \boldsymbol{a}_t]$, where $\gamma\in[0, 1)$ is the discounted factor.
We denote the joint action of agents other than agent $i$ as $\boldsymbol{a}^{-i}$, and $\boldsymbol{\pi}^{-i}$, $\boldsymbol{\tau}^{-i}$ follow a similar convention.
Joint policy $\boldsymbol{\pi}$ can be parameterized by $\theta=\{ \theta^1,\ldots,\theta^N\}$, where $\theta^i$ is the parameter set of agent $i$'s policy.
Our problem setting follows the CTDE paradigm \citep{Foerster2016LearningTC}, in which each agent executes its policy conditioned only on the partially observable information, but the policies can be trained centrally by using extra global information.

\paragraph{Value-based MARL}

In CTDE value-based methods such as~\citep{Sunehag2018ValueDecompositionNF, Rashid2018QMIXMV,Son2019QTRANLT, Mahajan2019MAVENMV}, an agent selects its action by performing an $\arg\max$ operation over the local action-value function, i.e. $\pi^i(\tau^i)=\mathop{\arg\max}_{a^i}Q^i(\tau^i, a^i)$.
Without loss in generality, the update rule for value-based methods can be formulated as follows:
\begin{equation}
    \label{eq:value-based}
    \Delta\theta^i\propto\mathbb{E}_{\boldsymbol{\pi}}\left[\left(R(s, \boldsymbol{a})+\max_{\boldsymbol{a}'}Q^{tot}(s, \boldsymbol{a}')-Q^{tot}(s,\boldsymbol{a}) \right)\frac{\partial Q^{tot}}{\partial Q^i}\nabla_{\theta^i}Q^i(\tau^i,a^i)\right],
\end{equation} %R(s, \boldsymbol{a})+\max_{\boldsymbol{a}'}Q^{tot}(s, \boldsymbol{a}')
where $\theta^i$ represents the parameter of $Q^i$, and $Q^{tot}$ is the global action-value function.
The centralized training procedure enables value-based methods to factorize $Q^{tot}$ into some local action-values.
Eq.~(\ref{eq:value-based}) is essentially Q-learning if rewriting $\frac{\partial Q^{tot}}{\partial Q^i}\nabla_{\theta^i}Q^i(\tau^i,a^i)$ as $\nabla_{\theta^i}Q^{tot}$.
The partial derivative is actually a credit assignment term that projects the step size of $Q^{tot}$ to that of $Q^i$~\citep{wang2020off}.

\paragraph{Policy-based MARL}

In CTDE policy-based methods such as~\citep{foerster2018counterfactual, Lowe2017MultiAgentAF,wang2020off, Yu2021TheSE}, an agent selects its action from an explicit policy $\pi^i(a^i|\tau^i)$.
The vanilla multi-agent policy gradient algorithm updates the policy using the following formula:
\begin{equation}
\label{eq:policy gradient-based}
    \Delta\theta^i\propto\mathbb{E}_{\boldsymbol{\pi}}\left[ Q^{tot}_{\boldsymbol{\pi}}(s,\boldsymbol{a})\nabla_{\theta^i}\pi^i(a^i|\tau^i)\right].
\end{equation}
In order to reduce the variance and address the credit assignment issue, COMA \citep{foerster2018counterfactual} replace $Q^{tot}$ with the counterfactual advantage:
$A^{\boldsymbol{\pi}}(s, \boldsymbol{a})=Q^{\boldsymbol{\pi}}(s, (a^i, \boldsymbol{a}^{-i}))-\mathbb{E}_{\hat{a}^i\sim\pi^i}[Q^{\boldsymbol{\pi}}(s, (\hat{a}^i, \boldsymbol{a}^{-i}))]$.
This implies that fixing the actions of other agents (i.e. $\boldsymbol{a}^{-i}$), an agent will evaluate the action it has actually taken (i.e. $a^i$) by comparing with the average effect of other actions it may have taken.

\section{Coordinated Proximal Policy Optimization}
\label{Coordinated Proximal Policy Optimization}

In policy-based methods, properly limiting the policy update step size is proven to be effective in single-agent settings \citep{Schulman2015TrustRP,Schulman2017ProximalPO}.
In cases when there are multiple policies, it is also crucial for each agent to take other agents' update into account when adjusting its own step size. 
Driven by this insight, we propose the CoPPO algorithm to adaptively adjust the step sizes during the update of the policies of multiple agents.
%In the following subsections, a theoretical basis is first derived to perform coordinated adaptation in step size .

\subsection{Monotonic Joint Policy Improvement} \label{sec:Monotonic Joint Policy Improvement}

The performance of joint policy $\boldsymbol{\pi}$ is defined as: $J(\boldsymbol{\pi})\doteq\mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}, s\sim\rho^{\boldsymbol{\pi}}}\left[\sum_{t=0}^\infty\gamma^tR_{t+1}(s, \boldsymbol{a}) \right],$
where $\rho^{\boldsymbol{\pi}}$ is the unnormalized discounted visitation frequencies when the joint actions are chosen from $\boldsymbol{\pi}$.
Then the difference between the performance of two joint policies, say $\boldsymbol{\pi}$ and $\tilde{\boldsymbol{\pi}}$, can be expressed as the accumulation of the global advantage over timesteps (see Appendix~\ref{sec:appA1} for proof):
\begin{equation}
\label{eq:perf_diff}
    J(\tilde{{\boldsymbol \pi}})-J({\boldsymbol \pi})=\mathbb{E}_{{\boldsymbol a}\sim\tilde{{\boldsymbol \pi}},  s\sim\rho^{\tilde{{\boldsymbol \pi}}}}\left[ A^{{\boldsymbol \pi}}(s, \boldsymbol{a}) \right],
\end{equation}
where $A^{{\boldsymbol \pi}}(s, \boldsymbol{a})=Q^{\boldsymbol{\pi}}(s, \boldsymbol{a})-V^{\boldsymbol{\pi}}(s)$ is the joint advantage function.
This equation indicates that if the joint policy $\boldsymbol{\pi}$ is updated to $\tilde{\boldsymbol{\pi}}$, then the performance will improve when the update increases the probability of taking "good" joint actions so that $\sum_{\boldsymbol{a}}\tilde{\boldsymbol{\pi}}(\boldsymbol{a}|s)A^{{\boldsymbol \pi}}(s, \boldsymbol{a})>0$ for every $s$.
Modeling the dependency of $\rho^{\tilde{{\boldsymbol \pi}}}$ on $\tilde{\boldsymbol{\pi}}$ involves the complex dynamics of the environment, so we extend the approach proposed in \citep{Kakade2002ApproximatelyOA} to derive an approximation of $J(\tilde{\boldsymbol{\pi}})$,  denoted as $\tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}})$:
\begin{align}
\label{eq:approx}
    \tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}})&\doteq J(\boldsymbol{\pi})+\mathbb{E}_{\boldsymbol{a}\sim\tilde{\boldsymbol{\pi}}, s\sim\rho^{\boldsymbol{\pi}}}\left[ A^{\boldsymbol{\pi}}(s, \boldsymbol{a}) \right].
\end{align}
Note that if the policy is differentiable, then $\tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}})$ matches $J(\tilde{\boldsymbol{\pi}})$ to first order (see Appendix~\ref{sec:firstorder} for proof).
Quantitatively, we measure the difference between two joint policies using the \emph{maximum total variation divergence} \citep{Schulman2015TrustRP}, which is defined by:
$D_{TV}^{\max}[\pi\|\tilde{\pi}]\doteq\max_sD_{TV}[\pi(\cdot|s)\|\tilde{\pi}(\cdot|s)], $
where $D_{TV}[\pi(\cdot|s)\|\tilde{\pi}(\cdot|s)]=\frac{1}{2}\int_{\mathcal{A}}|\pi(a|s)-\tilde{\pi}(a|s)|d a$
(the definition for the discrete case is simply replacing the integral with a summation, and our results remain valid in such case).
Using the above notations, we can derive the following theorem:
\begin{theorem}
    Let $\epsilon=\max_{s, \boldsymbol{a}}\left|A^{\boldsymbol{\pi}}(s, \boldsymbol{a})\right|,\alpha_i=\sqrt{\frac{1}{2}D_{TV}^{\max}[\pi^i||\tilde{\pi}^i]}, 1\leq i\leq N$, and $N$ be the total number of agents, then the error of the approximation in Eq.~(\ref{eq:approx}) can be explicitly bounded as follows:

    \begin{equation}
    \label{eq:bound}
        \left| J(\boldsymbol{\tilde{\pi}})-\tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}}) \right|\leq 4\epsilon\left[\frac{1-\gamma \prod_{i=1}^N (1-\alpha_i)}{1-\gamma}-1\right].
    \end{equation}
\end{theorem}
\begin{proof}
    See Appendix \ref{sec:appA2}.
\end{proof}

As shown above, the upper bound is influenced by $\alpha_i, N$ and $\epsilon$.
By definition, we have $\alpha_i\leq 1$ and $\epsilon\geq 0$,
thus the upper bound will increase when $\alpha_i$ increases for any $i$, implying that it becomes harder to make precise approximation when any individual of the agents dramatically updates their policies.
Also, the growth in the number of agents can raise the difficulty for approximation.
As for $\epsilon$, from Eq.~(\ref{eq:bound}) we can roughly conclude that a larger advantage value can cause higher approximation error,
and this is reasonable because $\tilde{J}_{\boldsymbol{\pi}}(\tilde{\boldsymbol{\pi}})$ approximates  $J(\tilde{\boldsymbol{\pi}})$ by approximating the expectation over $A^{\boldsymbol{\pi}}$.
Transforming the inequality in Eq.~(\ref{eq:bound}) leads to
$J(\boldsymbol{\tilde{\pi}}) \geq \tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}}) - 4\epsilon\left(\frac{1-\gamma\prod_{i=1}^N(1-\alpha_i)}{1-\gamma}-1\right)$.
Thus the joint policy can be iteratively updated by:
\begin{equation}
\label{eq:idealupdate}
    \boldsymbol{\pi}_{new} = \mathop{\arg\max}_{\tilde{\boldsymbol{\pi}}}\left[\tilde{J}_{\boldsymbol{\pi}_{old}}(\boldsymbol{\tilde{\pi}})- 4\epsilon\left(\frac{1-\gamma\prod_{i=1}^N(1-\alpha_i)}{1-\gamma}-1\right)\right].
\end{equation}
Eq.~(\ref{eq:idealupdate}) involves a complete search in the joint observation space and action space for computing $\epsilon$ and $\alpha_i$, making it difficult to be applied to large-scale settings.
In the next subsection, several transformations and approximations are employed to this objective to achieve better scalability.

\subsection{The Final Algorithm}
\label{sec:Final Objective}

Notice that the complexity of optimizing the objective in Eq.~(\ref{eq:idealupdate}) mainly lies in the second term, i.e. $4\epsilon\left(\frac{1-\gamma\prod_{i=1}^N(1-\alpha_i)}{1-\gamma}-1\right)$.
While $\epsilon$ has nothing to do with $\tilde{\boldsymbol{\pi}}$, it suffices to control this second term only by limiting the variation divergence of agents' policies (i.e. $\alpha_i$),
because it increases monotonically as $\alpha_i$ increases.
Then the objective is transformed into $\tilde{J}_{\boldsymbol{\pi}_{old}}(\boldsymbol{\tilde{\pi}})$ that can be optimized subject to a trust region constraint: $\alpha_i\leq\delta, i=1,\ldots,N$.
For higher scalability, $\alpha_i$ can be replaced by the mean Kullback-Leibler Divergence between agent $i$'s two consecutive policies, i.e.
$\mathbb{E}_{s\sim\rho^{\boldsymbol{\pi}}}\left[D_{KL}[\pi^i(\cdot|\tau^i)||\tilde{\pi}^i(\cdot|\tau^i)]\right]$.

As proposed in \citep{Schulman2015TrustRP}, solving the above trust region optimization problem requires repeated computation of Fisher-vector products for each update,
which is computationally expensive in large-scale problems,
especially when there are multiple constraints.
In order to reduce the computational complexity and simplify the implementation,
importance sampling can be used to incorporate the trust region constraints into the objective
of $\tilde{J}_{\boldsymbol{\pi}_{old}}(\boldsymbol{\tilde{\pi}})$,
resulting in the maximization of $\mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left[\min\left(\boldsymbol{r}A^{\boldsymbol{\pi}_{old}}, \text{clip}\left(\boldsymbol{r}A^{\boldsymbol{\pi}_{old}}, 1-\epsilon, 1+\epsilon\right) \right)\right]$ w.r.t $\boldsymbol{\pi}$,
where $\boldsymbol{r}=\frac{\boldsymbol{\pi}(\boldsymbol{a}|s)}{\boldsymbol{\pi}_{old}(\boldsymbol{a}|s)}$,
and $A^{\boldsymbol{\pi}_{old}}(s, \boldsymbol{a})$ is denoted as $A^{\boldsymbol{\pi}_{old}}$ for brevity.
The clip function prevents the joint probability ratio from going beyond $[1-\epsilon, 1+\epsilon]$, thus approximately limiting the variation divergence of the joint policy.
Since the policies are independent during the fully decentralized execution,
it is reasonable to assume that $\boldsymbol{\pi}(\boldsymbol{a}|\boldsymbol{\tau})=\prod_{i=1}^N\pi^i(a^i|\tau^i)$.
Based on this factorization, the following objective can be derived:
\begin{equation}
  \label{eq:jointob}
    \mathop{\mbox{maximize}\ }\limits_{\theta^1,\ldots,\theta^N}\ \mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left\{\min \left[\left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}, \text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{\boldsymbol{\pi}}\right]\right\},
\end{equation}
where $\theta^j$ is the parameter of agent $j$'s policy, and $r^j=\frac{\pi^j\left(a^j|\tau^j;\theta^j\right)}{\pi^j_{old}\left(a^j|\tau^j;\theta^j_{old}\right)}$.
While $A^{\boldsymbol{\pi}}$ is defined as $Q^{\boldsymbol{\pi}}(s, \boldsymbol{a})-V^{\boldsymbol{\pi}}(s)$, the respective contribution of each individual agent cannot be well distinguished.
To enable credit assignment, the joint advantage function is decomposed to some local ones of the agents as:
$A^{\boldsymbol{\pi}}(s, \boldsymbol{a})=\sum_{i=1}^N c^i\cdot A^i(s, (a^i,\boldsymbol{a}^{-i})),$
where $A^i(s, (a^i,\boldsymbol{a}^{-i}))=Q^{\boldsymbol{\pi}}(s, (a^i, \boldsymbol{a}^{-i}))-\mathbb{E}_{\hat{a}^i}[Q^{\boldsymbol{\pi}}(s, (\hat{a}^i, \boldsymbol{a}^{-i})) ]$ is the counterfactual advantage and $c^i$ is a non-negative weight.

During each update, multiple epochs of optimization are performed on this joint objective to improve sample efficiency.
Due to the non-negative decomposition of $A^{\boldsymbol{\pi}}$,
there is a monotonic relationship between the global optimum and the local optima,
suggesting a transformation from $\mathop{\arg\max}_{\theta^1, \ldots, \theta^N}$ to $\{\mathop{\arg\max}_{\theta^1}, \ldots, \mathop{\arg\max}_{\theta^N}\}$ (see Appendix~\ref{app:local argmax} for the proof).
The optimization of Eq.~(\ref{eq:jointob}) then can be transformed to maximizing each agent's own objective:
\begin{equation}
  \label{eq:respectob}
    L(\theta^i) = \mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left\{\min \left[\left(\prod_{j\neq i} r^j\right)r^i A^{i}, \text{clip}\left(\left(\prod_{j\neq i} r^j\right)r^i, 1-\epsilon, 1+\epsilon\right)A^{i}\right]\right\}.
\end{equation}
However, the ratio product in Eq.~(\ref{eq:respectob}) raises a potential risk of high variance due to Proposition~\ref{propo:var}:
\begin{propo}
\label{propo:var}
  Assuming that the agents are fully independent during execution, then the following inequality holds:
  \begin{equation}
    \label{eq:var}
    \textnormal{\large Var}_{\boldsymbol{a}^{-i}\sim\boldsymbol{\pi}^{-i}_{old}}\left[\prod_{j\neq i} r^j\right] \geq \prod_{j\neq i}\textnormal{\large Var}_{a^j\sim\pi^j_{old}}\bigl[r^j\bigr].
  \end{equation}
\end{propo}
\begin{proof}
  See Appendix~\ref{app:variance ineq}.
\end{proof}
According to the inequality above, the variance of the product grows at least exponentially with the number of agents.
Intuitively, the existence of other agents' policies introduces instability in the estimate of each agent's policy gradient. This may further cause suboptimatlity in individual policies due to the centralized-decentralized mismatch issue mentioned in \citep{wang2020off}. To be concrete, when $A^{i}>0$, the external $\min$ operation in Eq.~(\ref{eq:respectob})  can prevent the gradient of $L(\theta^i)$ from exploding when $\prod_{j\neq i} r^j$ is large, thus limiting the variance raised from other agents; but when $A^{i}<0$, the gradient can grow rapidly in the negative direction, because $L(\theta^i)=\mathbb{E}\left[\left(\prod_{j\neq i} r^j\right)r^i A^{i}\right]$ when $\left(\prod_{j\neq i} r^j \right)r^i \geq 1 + \epsilon$. 
%Moreover, in each update, the probability ratio $r^i$ of agent $i$ increases or decreases monotonically from $1$ towards the clipping threshold. 
Moreover, the learning procedure in Eq.~(\ref{eq:respectob}) can cause a potential exploration issue, that is, different agents might be granted unequal opportunities to update their policies. Consider a scenario when the policies of some agents except agent $i$ are updated rapidly, and thus the product of these agents' ratios might already be close to the clipping threshold, then a small optimization step of agent $i$ will cause $\prod_{j=1}^N r^j$ to reach the threshold and thus being clipped. In this case, agent $i$ has no chance to update its policy, while other agents have updated their policies significantly, leading to unbalanced exploration among the agents. To address the above issues, we propose a double clipping trick to modify Eq.~(\ref{eq:respectob}) as follows:
\begin{align}
  \label{eq:finalob}
  L(\theta^i)=\mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left\{\min\left[g(\boldsymbol{r}^{-i}) r^iA^{i},
  \text{clip}\left(g(\boldsymbol{r}^{-i})r^i, 1-\epsilon_{1}, 1+\epsilon_1\right)A^{i}\right] \right\},
\end{align}
where $g(\boldsymbol{r}^{-i})=\text{clip}\bigl(\prod_{j\neq i}r^j, 1-\epsilon_{2}, 1+\epsilon_{2}\bigr),\ \epsilon_2<\epsilon_1$.
%The probability ratio $r^i$ indicates the update trend of agent $i$ on the current action $a^i$. If $r^i>1$, then $\pi^i(a^i|\tau^i)$ will increase and vice versa.
In Eq.~(\ref{eq:respectob}), the existence of $\prod_{j\neq i}r^j$ imposes an influence on the objective of agent $i$ through a weight of $\prod_{j\neq i}r^j$.
Therefore, the clipping on $\prod_{j\neq i}r^j$ ensures that the influence from the update of other agents on agent $i$ is limited to $[1-\epsilon_2, 1+ \epsilon_2]$, thus controlling the variance caused by other agents.
Note that from the theoretical perspective, clipping separately on each individual probability ratio (i.e. $\prod_{j=1}^N\text{clip}(r^j,\cdot,\cdot)$)  can also reduce the variance.
Nevertheless, the empirical results show that clipping separately performs worse than clipping jointly.
The detailed results and analysis for this comparison are presented in Appendix~\ref{app:clipping_separately}.
In addition, this trick also prevents the update step of each agent from being too small, because $r^i$ in Eq.~(\ref{eq:finalob}) can at least increase to $\frac{1+\epsilon_1}{1+\epsilon_2}r^i$ or decrease to $\frac{1-\epsilon_1}{1-\epsilon_2}r^i$ before being clipped in each update.

In the next subsection, we will show that the presence of other agents' probability ratio also enables a dynamic credit assignment among the agents in order to promote coordination, and thus the inner clipping threshold (i.e. $\epsilon_2$) can actually function as a balance factor to trade off between facilitating coordination and reducing variance, which will be studied empirically in Section~\ref{sec:ex}. A similar trick was proposed in~\citep{ye2020mastering,fullmoba} to handle the variance induced by distributed training in the single-agent setting. Nonetheless, since multiple policies are updated in different directions in MARL, the inner clipping here is carried out on the ratio product of other agents instead of the entire ratio product, in order to distinguish the update of different agents. The overall CoPPO algorithm with the double clipping trick is shown in Appendix~\ref{app:alg}.


\subsection{Interpretation: Dynamic Credit Assignment}
\label{sec:Interpre}

The COMA~\citep{foerster2018counterfactual} algorithm tries to address the credit assignment issue in CoMARL using the counterfactual advantage. Nevertheless, miscoordination and suboptimatlity can still arise since the credit assignment in COMA is conditioned on the fixed actions of other agents, but these actions are continuously changing and thus cannot precisely represent the actual policies. While CoPPO also makes use of the counterfactual advantage,
the overall update of other agents is taken into account dynamically during the multiple epochs in each update. This process can adjust the advantage value in a coordinated manner and alleviate the miscoordination issue caused by the fixation of other agents' joint action. Note that the theoretical reasoning for CoPPO in Section~\ref{sec:Monotonic Joint Policy Improvement} and~\ref{sec:Final Objective} originally aims at monotonic joint policy improvement,
yet the resulted objective ultimately realizes coordination among agents through a dynamic credit assignment among the agents in terms of coordinating over the step sizes of the agents' policies.

% To illustrate the efficacy of this dynamic credit assignment, we make an analysis on the difference between CoPPO and MAPPO~\citep{Yu2021TheSE}, a recently proposed policy-based CoMARL method. MAPPO generalizes PPO to  multi-agent settings by centralizing the value functions, with an optimization objective of $\mathbb{E}_{\boldsymbol{\pi}_{old}}\left[\min \left[r^i_kA^{i}, \text{clip}\left(r^i_k, 1 - \epsilon, 1 + \epsilon\right)\right]\right]$, which is a lower bound of $\mathbb{E}_{\boldsymbol{\pi}_{old}}\left[r^i_kA^{i}\right]$
To illustrate the efficacy of this dynamic credit assignment, we make an analysis on the difference between CoPPO and  MAPPO~\citep{Yu2021TheSE} which generalizes PPO to  multi-agent settings simply by centralizing the value functions with an optimization objective of $\mathbb{E}_{\boldsymbol{\pi}_{old}}\left[\min \left[r^i_kA^{i}, \text{clip}\left(r^i_k, 1 - \epsilon, 1 + \epsilon\right)\right]\right]$, which is a lower bound of $\mathbb{E}_{\boldsymbol{\pi}_{old}}\left[r^i_kA^{i}\right]$
where $r^i_k$ represents the probability ratio of agent $i$ at the $k_{th}$ optimization epoch during each update.
Denoting $\left(\prod_{j\neq i}r^j_k\right)A^{i}$ as $\tilde{A}^{i}_{k}$, the CoPPO objective then becomes approximately a lower bound of $\mathbb{E}_{\boldsymbol{\pi}_{old}}\bigl[r^i_k\tilde{A}^{i}_{k}\bigr]$.
The discussion then can be simplified to analyzing the two lower bounds (see Appendix~\ref{app:interprete simplify} for the details of this simplification).

Depending on whether $A^{i}>0$ and whether $\prod_{j\neq i}r^j_k > 1$, four different cases can be classified. For brevity, only two of them are discussed below while the rest are similar. The initial parameters of the two methods are assumed to be the same.

Case (1): $A^{i}>0,\ \prod_{j\neq i}r^j_k>1$.
In this case $\bigl|\tilde{A}^i_k\bigr| > \left|A^i\right|$,
thus $\bigl\|\tilde{A}^i_k\nabla r^i_k\bigr\| > \bigl\|A^i\nabla r^i_k\bigr\|$,
indicating that CoPPO takes a larger update step towards increasing $\pi^i(a^i|\tau^i)$ than MAPPO does. %#TODO update 要不要加？下面同理
Concretely, $A^{i}>0$ means that $a^i$ is considered (by agent $i$) positive for the whole team when fixing $\boldsymbol{a}^{-i}$ and under similar observations.
Meanwhile, $\prod_{j\neq i}r^j_k>1$ implies that after this update epoch,
$\boldsymbol{a}^{-i}$ are overall more likely to be performed by the other agents when encountering similar observations (see Appendix~\ref{app:trend for other agents} for the details).
This makes fixing $\boldsymbol{a}^{-i}$ more reasonable when estimating the advantage of $a^i$, thus explaining CoPPO's confidence to take a larger update step.

Case (2): $A^{i}<0,\ \prod_{j\neq i}r_k^j<1$.
Similarly, in this case
$\bigl|\tilde{A}^i_k\bigr| < \bigl|A^i\bigr|$
and hence
$\bigl\|\tilde{A}^i_k\nabla r^i_k\bigr\| < \bigl\|A^i\nabla r^i_k\bigr\|$,
indicating that CoPPO takes a smaller update step to decrease $\pi^i(a^i|\tau^i)$ than MAPPO does.
To be specific, $a^i$ is considered (by agent $i$) to have a negative effect on the whole team since $A^{i}<0$,
and $\prod_{j\neq i}r_k^j<1$ suggests that after this optimization epoch, other agents are overall less likely to perform $\boldsymbol{a}^{-i}$ given similar observations. 
While the evaluation of $a^i$ is conditioned on $\boldsymbol{a}^{-i}$, it is reasonable for agent $i$ to rethink the effect of $a^i$ and slow down the update of decreasing the probability of taking $a^i$, thus giving more chance for this action to be evaluated.
% At this time, it will be more reasonable for agent $i$ to slow down the update of decreasing the probability of taking $a^i$, since it is also likely for the other agents to be credited to the poor performance in the whole group. 

It is worth noting that $\tilde{A}^{i}_k$ continues changing throughout the K epochs of update and yields dynamic adjustments in the step size, while $A^{i}$ will remain the same during each update. Therefore, $\tilde{A}^{i}_{k}$ can be interpreted as a dynamic modification of $A^{i}$ by taking other agents' update into consideration.


\section{Experiments}
\label{sec:ex}

In this section, we evaluate CoPPO on a modified matrix penalty game and the StarCraft Multi-Agent Challenge (SMAC) \citep{Samvelyan2019TheSM}.
The matrix game results enable interpretative observations, while the evaluations on SMAC verify the efficacy of CoPPO in more complex domains.

\subsection{Cooperative Matrix Penalty Game}
\label{sec:matgame}

The \emph{penalty game} is a representative of problems with miscoordination penalties and multiple equilibria selection among optimal joint actions. It has been used as a challenging test bed for evaluating CoMARL algorithms \citep{claus1998dynamics,spiros2002reinforcement}. To further increase the difficulty of achieving coordination, we modify the two-player \emph{penalty game} to four agents with nine actions for each agent. The agents will receive a team reward of 50 when they have played the same action, but be punished by -50 if any three agents have acted the same while the other does not. In all other cases, the reward is -40 for all the agents. The \emph{penalty game} provides a verifying metaphor to show the importance of adaptive adjustment in the agent policies in order to achieve efficient coordinated behaviors. Thinking of the case when the agents have almost reached one of the optimal joint actions, yet at the current step they have received a miscoordination penalty due to the exploration of an arbitrary agent. Then smaller update steps for the three matching agents would benefit the coordinated learning process of the whole group, since agreement on this optimal joint action would be much easier to be reached than any other optimal joint actions. Therefore, adaptively coordinating over the agent policies and properly assigning credits among the agents are crucial for the agents to achieve efficient coordination in this kind of game.




%The difficulty of this game lies not only in avoiding heavy penalties for miscoordination, but also in reaching an agreement on one of the multiple optimal joint actions.
%The two difficulties interact with each other and can result in suboptimatlity.
% because when the agents are trying to agree on an optimal joint action,
% the risk of being penalized will also increase,
% and the agreement becomes harder to reach if the agents struggle to avoid the penalty.

 
% In this regard, an effective credit assignment mechanism can help indicate a proper step size for each agent after distinguishing their respective contributions.
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.95\textwidth]{figures/matrix_main.pdf}
  \caption{\footnotesize Upper left: average rewards; Upper right: average advantages after a penalty; Lower left: the variation of the average advantages within $K$ (here $K=8$) optimization epochs every time after a penalty; Lower right: running policy gradient variance.}
  \label{fig:matrix}
\end{figure}

We train CoPPO, COMA~\citep{foerster2018counterfactual}, MAPPO~\citep{Yu2021TheSE} and DOP~\citep{wang2020off} for 10,000 timesteps, and the final results are averaged over 100 runs.
The hyperparameters and other implementation details are described in Appendix~\ref{app:matrix implement}.
From Fig.~\ref{fig:matrix}-upper left, we can see that CoPPO significantly outperforms other methods in terms of average rewards.
Fig.~\ref{fig:matrix}-upper right presents an explanation of the result by showing the local advantages averaged among the three matching agents every time after receiving a miscoordination penalty. Each point on the horizontal axis represents a time step after a miscoordination penalty. While the times of penalties in a single run vary for different algorithms, we take the minimum times of 70 over all runs. 
The vertical axis represents  $\frac{1}{3}\sum_{j\neq i}A^j$ for COMA, MAPPO and DOP, and represents the mean of $K$ epochs during one update, i.e., $\frac{1}{3}\sum_{j\neq i}\frac{1}{K}\sum_{k=1}^K \tilde{A}^{j}_{k}$, for CoPPO ($i$ indicates the unmatching agent). Note that CoPPO can obtain the smallest local advantages that are close to 0 compared to other methods, indicating the smallest step sizes for the three agents in the direction of changing the current action.
% In contrast, the other methods suffer from the unsteadily large update step after a miscoordination,
% though sometimes this step is on the positive direction.
Fig.~\ref{fig:matrix}-lower left shows the overall variation of the average advantages within $K$ optimization epochs after receiving a miscoordination penalty. We can see that as the number of epochs increases, the absolute value of
the average advantage of the three matching agents gradually decreases by considering the update of other agents. Since the absolute value actually determines the step size of update, a smaller value indicates a small adaptation in their current actions.
% We can see that as the number of epochs increases, the three matching agents make a relatively small adaptation in their current actions, which
This is consistent with what we have discussed in Section~\ref{sec:Interpre}. Fig.~\ref{fig:matrix}-lower right further implies that through this dynamic process, the agents succeed in learning to coordinate their update steps carefully, yielding the smallest gradient variance among the four methods.



\paragraph{Ablation study 1} Fig.~\ref{fig:matrix_ab} provides an ablation study of the double clipping trick. We can see that a proper intermediate inner clipping threshold improves the global performance, and the double clipping trick indeed reduces the variance of the policy gradient. In contrast to DOP, which achieves low gradient variance at the expense of lack of direct coordination over the policies, CoPPO can strike a nice balance between reducing variance and achieving coordination, by taking other agents' policy update into consideration. To make our results more convincing, experiments on more cooperative matrix games with different varieties are also conducted in Appendix~\ref{app:additional results(matrix)}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{figures/matrix_ablation.pdf}
  \caption{\footnotesize Ablation study of the double clipping trick. The numbers $0.05, 0.10, 0.15$ represent the inner clipping threshold, and "without DC" represents the case when the trick is not used. Left: average rewards; Right: running policy gradient variance.}
  \label{fig:matrix_ab}
\end{figure}

\subsection{StarCraft II}
\label{sec:StarCraft}

We evaluate CoPPO in SMAC against various state-of-the-art methods, including policy-based methods (COMA \citep{foerster2018counterfactual}, MAPPO \citep{Yu2021TheSE} and DOP \citep{wang2020off}) and value-based methods (QMIX \citep{Rashid2018QMIXMV} and QTRAN \citep{Son2019QTRANLT}).
The implementation of these baselines follows the original versions. The win rates are tested over 32 evaluation episodes after each training iteration. The hyperparameter settings and other implementation details are presented in Appendix~\ref{app:smac implement}. The results are averaged over 6 different random seeds for easy maps (the upper row in Fig.~\ref{fig:smac}), and 8 different random seeds for harder maps (the lower row in Fig.~\ref{fig:smac}).
Note that CoPPO outperforms several strong baselines including the latest multi-agent PPO (i.e., MAPPO) method in SMAC across various types and difficulties, especially in \textbf{Hard} (3s5z, 10m\_vs\_11m) and \textbf{Super Hard} (MMM2) maps. Moreover, as an on-policy method, CoPPO shows better stability across different runs, which is indicated by a narrower confidence interval around the learning curves.
\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figures/smac_camera_ready.pdf}
  \caption{\footnotesize Comparisons against baselines on SMAC.}
  \label{fig:smac}
\end{figure}

\paragraph{Ablation study 2}  The first row in Fig.~\ref{fig:smac_ab} shows the ablation study of double clipping in SMAC, and we can see that the results share the same pattern as in Section~\ref{sec:matgame}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/smac_ablations.pdf}
  \caption{\footnotesize Ablation studies on the double clipping (the upper row) and the way of advantage decomposition (the lower row), evaluated on two maps respectively. In the upper row, the numbers "$0.05, 0.10, 0.15$" represent the values of the inner clipping threshold, and  "without DC" represents the case where the double clipping trick is not utilized. In the lower row, "Amix" refers to a non-negative-weighted neural network, and "Asum" refers to an arithmetic summation.
  }
  \label{fig:smac_ab}
\end{figure}
\paragraph{Ablation study 3} In Section~\ref{sec:Final Objective}, the global advantage is decomposed into a weighted sum of local advantages. We also compare it to a mixing network with non-negative weights and the results are shown in Fig.~\ref{fig:smac_ab}. Similar to QMIX~\citep{Rashid2018QMIXMV}, the effectiveness of the mixing network may largely owe to the improvement in the representational ability for the global advantage function.


\section{Related Work}
\label{sec:related}

In recent years, there has been significant progress in CoMARL. Fully centralized methods suffer from scalability issues due to the exponential growth of joint action space, 
and applying DQN to each agent independently while treating the other agents as part of environment \citep{tampuu2017multagent} suffers from the non-stationary issue~\citep{HernandezLeal2017ASO, papoudakis2019dealing}.
The CTDE paradigm~\citep{Foerster2016LearningTC} reaches a compromise between centralized and decentralized approaches, assuming a laboratory setting where each agent's policy can be trained using extra global information while maintaining scalable decentralized execution.

A series of work have been developed in the CTDE setting, including both value-based and policy-based methods. 
Most of the value-based MARL methods estimate joint action-value function by mixing local value functions.
VDN~\citep{Sunehag2018ValueDecompositionNF} first introduces value decomposition to make the advantage of centralized training and mixes the local value functions via arithmetic summation. 
To improve the representational ability of the joint action-value function, QMIX~\citep{Rashid2018QMIXMV} proposes to mix the local action-value functions via a non-negative-weighted neural network.
QTRAN~\citep{Son2019QTRANLT} studies the decentralization \& suboptimatlity trade-off and introduces a corresponding penalty term in the objective to handle it, which further enlarges the class of representable value functions.
As for the policy-based methods, COMA~\citep{foerster2018counterfactual} presents the counterfactual advantage to address the credit assignment issue. 
MADDPG~\citep{Lowe2017MultiAgentAF} extends DDPG~\citep{Lillicrap2016ContinuousCW} by learning centralized value functions which are conditioned on additional global information, such as other agents' actions. 
DOP~\citep{wang2020off} introduces value decomposition into the multi-agent actor-critic framework, which enables off-policy critic learning and addresses the centralized-decentralized mismatch issue. 
MAPPO~\citep{Yu2021TheSE} generalizes PPO \citep{Schulman2017ProximalPO} to multi-agent settings using a global value function.


The most relevant works are MAPPO \citep{Yu2021TheSE}, MATRPO \citep{Li2020MultiAgentTR} and MATRL \citep{wen2021multagent}. 
MAPPO  extends PPO to multi-agent settings simply by centralizing the critics. 
With additional techniques such as Value Normalization, MAPPO achieves promising performance compared to several strong baselines.
Note that our implementation is built on the one of MAPPO (please refer to Appendix~\ref{app:smac implement} for more details).

As for MATRPO and MATRL, they both try to extend TRPO \citep{Schulman2015TrustRP} to multi-agent settings.
MATRPO focuses on fully decentralized training, which is realized through splitting the joint TRPO objective into $N$ independent parts for each agent and transforming it into a consensus optimization problem; while MATRL computes independent trust regions for each agent assuming that other agents' policies are fixed, and then solves a meta-game in order to find the best response to the predicted joint policy of other agents derived by independent trust region optimization. 
Different from our  work, they adopt the settings where agents have separate local reward signals. 
% \textcolor{red}{We still need to elaborate the uniqueness of CoPPO here. By comparision, our CoPPO algorithm xxxxxx. }
By comparison, CoPPO does not directly optimize the constrained objective derived in Section~\ref{sec:Monotonic Joint Policy Improvement}, but instead  incorporates the trust region constraint into the optimization objective, in order to reduce the computational complexity and simplify the implementation. CoPPO can sufficiently take advantage of the centralized training and enable a coordinated adaptation of step size among agents during the policy update process.

\section{Conclusion}
\label{sec:conclu}


In this paper, we extend the PPO algorithm to the multi-agent setting and propose an algorithm named CoPPO through a theoretically-grounded derivation that ensures approximately monotonic policy improvement. CoPPO can properly address the issues of scalability and credit assignment, which is interpreted both theoretically and empirically. 
We also introduce a double clipping trick to strike the balance between reducing variance and achieving coordination by considering other agents' update.
Experiments on specially designed cooperative matrix games and the SMAC benchmark verify that CoPPO outperforms several strong baselines and is competitive with the latest multi-agent methods. 

\begin{ack}

% The  work is supported by the National Natural Science Foundation of China under Grant 62076259. The authors would like to thank Wenxuan Zhu for pointing out some of the mistakes in the proof, Xingzhou Lou and Xianjie Zhang for running some of the experiments, as well as Siling Chen for proofreading the manuscript. 
% Finally, the reviewers and metareviewer are highly appreciated for their constructive feedback on the paper.
The  work is supported by the National Natural Science Foundation of China (No. 62076259) and the Tencent AI Lab Rhino-Bird Focused Research Program (No. JR202063).
The authors would like to thank Wenxuan Zhu for pointing out some of the mistakes in the proof, Xingzhou Lou and Xianjie Zhang for running some of the experiments, as well as Siling Chen for proofreading the manuscript. 
Finally, the reviewers and metareviewer are highly appreciated for their constructive feedback on the paper.


\end{ack}



\bibliographystyle{unsrtnat}
\bibliography{neurips_2021}


% \section*{Checklist}

% %%% BEGIN INSTRUCTIONS %%%
% The checklist follows the references.  Please
% read the checklist guidelines carefully for information on how to answer these
% questions.  For each question, change the default \answerTODO{} to \answerYes{},
% \answerNo{}, or \answerNA{}.  You are strongly encouraged to include a {\bf
% justification to your answer}, either by referencing the appropriate section of
% your paper or providing a brief inline description.  For example:
% \begin{itemize}
%   \item Did you include the license to the code and datasets? \answerYes{See Section~\ref{gen_inst}.}
%   \item Did you include the license to the code and datasets? 
%   \item Did you include the license to the code and datasets? \answerNA{}
% \end{itemize}
% Please do not modify the questions and only use the provided macros for your
% answers.  Note that the Checklist section does not count towards the page
% limit.  In your paper, please delete this instructions block and only keep the
% Checklist section heading above along with the questions/answers below.
% %%% END INSTRUCTIONS %%%
% \begin{enumerate}

% \item For all authors...
% \begin{enumerate}
%   \item Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope?
%     \answerYes{}
%   \item Did you describe the limitations of your work?
%     \answerNA{}
%   \item Did you discuss any potential negative societal impacts of your work?
%     \answerNA{}
%   \item Have you read the ethics review guidelines and ensured that your paper conforms to them?
%     \answerYes{}
% \end{enumerate}

% \item If you are including theoretical results...
% \begin{enumerate}
%   \item Did you state the full set of assumptions of all theoretical results?
%     \answerYes{}
% 	\item Did you include complete proofs of all theoretical results?
%     \answerYes{See Appendix~\ref{app:math}.}
% \end{enumerate}

% \item If you ran experiments...
% \begin{enumerate}
%   \item Did you include the code, data, and instructions needed to reproduce the main experimental results (either in the supplemental material or as a URL)?
%     \answerYes{See Appendix~\ref{app:implement} and \ref{app:alg}.}
%   \item Did you specify all the training details (e.g., data splits, hyperparameters, how they were chosen)?
%     \answerYes{See Appendix~\ref{app:implement}.}
% 	\item Did you report error bars (e.g., with respect to the random seed after running experiments multiple times)?
%     \answerYes{See Section~\ref{sec:ex}.}
% 	\item Did you include the total amount of compute and the type of resources used (e.g., type of GPUs, internal cluster, or cloud provider)?
%     \answerYes{See Appendix~\ref{app:implement}.}
% \end{enumerate}

% \item If you are using existing assets (e.g., code, data, models) or curating/releasing new assets...
% \begin{enumerate}
%   \item If your work uses existing assets, did you cite the creators?
%     \answerYes{}
%   \item Did you mention the license of the assets?
%     \answerNA{}
%   \item Did you include any new assets either in the supplemental material or as a URL?
%     \answerNA{}
%   \item Did you discuss whether and how consent was obtained from people whose data you're using/curating?
%     \answerNA{}
%   \item Did you discuss whether the data you are using/curating contains personally identifiable information or offensive content?
%     \answerNA{}
% \end{enumerate}

% \item If you used crowdsourcing or conducted research with human subjects...
% \begin{enumerate}
%   \item Did you include the full text of instructions given to participants and screenshots, if applicable?
%     \answerNA{}
%   \item Did you describe any potential participant risks, with links to Institutional Review Board (IRB) approvals, if applicable?
%     \answerNA{}
%   \item Did you include the estimated hourly wage paid to participants and the total amount spent on participant compensation?
%     \answerNA{}
% \end{enumerate}

% \end{enumerate}
\clearpage

\appendix

\section{Mathematical Details}
\label{app:math}

\subsection{Difference between the performance of two joint policies}
\label{sec:appA1}

In Section~\ref{sec:Monotonic Joint Policy Improvement}, the difference between the performance of two joint policies is expressed as follows:
\begin{equation}
  \label{eq:perf_diff_app}
      J(\tilde{{\boldsymbol \pi}})-J({\boldsymbol \pi})=\mathbb{E}_{{\boldsymbol a}\sim\tilde{{\boldsymbol \pi}},  s\sim\rho^{\tilde{{\boldsymbol \pi}}}}\left[ A^{{\boldsymbol \pi}}(s, \boldsymbol{a}) \right], 
  \end{equation}
where $\rho^{\tilde{{\boldsymbol \pi}}}$ is the unnormalized discounted visitation frequencies, i.e. $\sum_{t=0}^\infty\gamma^t\sum_s\text{Pr}(s_t=s|\tilde{\boldsymbol{\pi}})$. The proof is a multi-agent version of the proof in \citep{Kakade2002ApproximatelyOA}. Now we provide the mathematical detail formally.

\begin{proof}
  \begin{align}
    J(\tilde{\boldsymbol{\pi}})-J(\boldsymbol{\pi})&=\mathbb{E}_{\tilde{\boldsymbol{\pi}}}\left[\sum_{t=0}^\infty\gamma^t R_{t+1}-V^{\boldsymbol{\pi}}(s_0)\right]\\
    &=\mathbb{E}_{\tilde{\boldsymbol{\pi}}}\left[R_1+\gamma V^{\boldsymbol{\pi}}(s_1)-V^{\boldsymbol{\pi}}(s_0)+\gamma[R_2+\gamma V^{\boldsymbol{\pi}}(s_2)-V^{\boldsymbol{\pi}}(s_1)]+\cdots \right]\\
    &=\mathbb{E}_{\tilde{\boldsymbol{\pi}}}\left[\sum_{t=0}^\infty\gamma^t A^{\boldsymbol{\pi}}(s_t, \boldsymbol{a}) \right]\\
    &=\sum_{t=0}^\infty\gamma^t\sum_s\text{Pr}(s_t=s|\tilde{\boldsymbol{\pi}})\sum_{\boldsymbol{a}}\tilde{\boldsymbol{\pi}}(\boldsymbol{a}|s)\left[Q^{\boldsymbol{\pi}}(s, \boldsymbol{a}) - V^{\boldsymbol{\pi}}(s)\right] \\
    &=\mathbb{E}_{\boldsymbol{a}\sim\tilde{\boldsymbol{\pi}}, s\sim\rho^{\tilde{\boldsymbol{\pi}}}}\left[ A^{\boldsymbol{\pi}}(s,\boldsymbol{a}) \right]
\end{align}
\end{proof}

\subsection{Approximation that matches the true value to first order}
\label{sec:firstorder}

In Section~\ref{sec:Monotonic Joint Policy Improvement}, we claim that $\tilde{J}_{\boldsymbol{\pi}}(\tilde{\boldsymbol{\pi}})$ matches $J(\tilde{\boldsymbol{\pi}})$ to first order.
Intuitively, this means that a sufficiently small update of the joint policy which improves $\tilde{J}_{\boldsymbol{\pi}}(\tilde{\boldsymbol{\pi}})$ will also improve $J(\tilde{\boldsymbol{\pi}})$.
Now we prove it formally.
\begin{proof}
We represent the policy using its parameter, i.e. $\theta$ for $\boldsymbol{\pi}$ and $\tilde{\theta}$ for $\boldsymbol{\tilde{\pi}}$. 
Because $\tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\pi})=J(\boldsymbol{\pi})$, there are $\tilde{J}_{\theta}(\theta)=J(\theta)$. 
Furthermore, we have:
\begin{align}
  \nabla_{\tilde{\theta}} \tilde{J}_{\theta}(\tilde{\theta})\big|_{\theta}
  &= \nabla_{\tilde{\theta}}\left(J(\theta)+\mathbb{E}_{\boldsymbol{a}\sim\tilde{\boldsymbol{\pi}}, s\sim\rho^{\boldsymbol{\pi}}}\left[ A^{\boldsymbol{\pi}}(s, \boldsymbol{a}) \right]\right) \\ 
  &= \sum_{t}\gamma^t\sum_s\text{Pr}(s_t=s|\boldsymbol{\pi})\sum_{\boldsymbol{a}}\nabla_{\tilde{\theta}}\tilde{\boldsymbol{\pi}}(\boldsymbol{a}|s)\big|_{\theta}A^{\boldsymbol{\pi}}(s, \boldsymbol{a}) \\
  &= \nabla_{\tilde{\theta}} J(\tilde{\boldsymbol{\pi}})\big|_{\theta},
\end{align}
where the last step is indicated by Theorem 1 in \citep{sutton1999policy}. 

\end{proof}

\subsection{Upper bound for the error of joint policy approximation}
\label{sec:appA2}

\begin{theorem*}
  Let $\epsilon=\max_{s, \boldsymbol{a}}\left|A^{\boldsymbol{\pi}}(s, \boldsymbol{a})\right|,\alpha_i=\sqrt{\frac{1}{2}D_{TV}^{\max}[\pi^i||\tilde{\pi}^i]}, 1\leq i\leq N$, and $N$ be the total number of agents, then the error of the approximation in Eq. \ref{eq:approx} can be explicitly bounded as follows:
  
  \begin{equation}
      \left| J(\boldsymbol{\tilde{\pi}})-\tilde{J}_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}}) \right|\leq 4\epsilon\left[\frac{1-\gamma \prod_{i=1}^N (1-\alpha_i)}{1-\gamma}-1\right]. 
  \end{equation}
\end{theorem*}

\begin{proof}
  We first prove that for a fixed $s$, the following inequality holds:
  \begin{equation}
    \label{eq:lemma2}
    \left|\mathbb{E}_{\boldsymbol{a}\sim\tilde{\boldsymbol{\pi}}}\left[A^{\boldsymbol{\pi}}(s, \boldsymbol{a})\right]  \right|\leq 2\epsilon\left[1-\prod_{i=1}^N(1-\alpha_i)\right].
  \end{equation}
  Note that
  \begin{align}
    \mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}}[A^{\boldsymbol{\pi}}(s, \boldsymbol{a})]&=\boldsymbol{\pi}(\boldsymbol{a}|s)\left[ Q(s, \boldsymbol{a})-V(s)\right]\\
    &=V(s)-V(s)\\
    &=0. 
    \end{align}
  Therefore, 
  \begin{align}
    \mathbb{E}_{\tilde{\boldsymbol{a}}\sim\tilde{\boldsymbol{\pi}}}[A^{\boldsymbol{\pi}}(s, \tilde{\boldsymbol{a}})]&=\mathbb{E}_{(\boldsymbol{a}, \tilde{\boldsymbol{a}}) \sim(\boldsymbol{\pi}, \tilde{\boldsymbol{\pi}})}[A^{\boldsymbol{\pi}}(s, \tilde{\boldsymbol{a}})-A^{\boldsymbol{\pi}}(s, \boldsymbol{a})]\\
    &=\text{Pr}(\boldsymbol{a}\neq\tilde{\boldsymbol{a}})\cdot\mathbb{E}_{(\boldsymbol{a}, \tilde{\boldsymbol{a}}) \sim(\boldsymbol{\pi}, \tilde{\boldsymbol{\pi}})}[A^{\boldsymbol{\pi}}(s, \tilde{\boldsymbol{a}})-A^{\boldsymbol{\pi}}(s, \boldsymbol{a})] \\
    &=\left[1-\prod_{i=1}^N\left(1-\text{Pr}\left(a^i\neq \tilde{a}^{-i}\right)\right) \right]\mathbb{E}_{(\boldsymbol{a}, \tilde{\boldsymbol{a}}) \sim(\boldsymbol{\pi}, \tilde{\boldsymbol{\pi}})}[A^{\boldsymbol{\pi}}(s, \tilde{\boldsymbol{a}})-A^{\boldsymbol{\pi}}(s, \boldsymbol{a})] \\
    &\leq \left[1-\prod_{i=1}^N(1-\eta_i) \right]\mathbb{E}_{(\boldsymbol{a}, \tilde{\boldsymbol{a}}) \sim(\boldsymbol{\pi}, \tilde{\boldsymbol{\pi}})}[A^{\boldsymbol{\pi}}(s, \tilde{\boldsymbol{a}})-A^{\boldsymbol{\pi}}(s, \boldsymbol{a})] \\
    &\leq \left[1-\prod_{i=1}^N(1-\eta_i) \right]\cdot 2\max_{s,\boldsymbol{a}}|A^{\boldsymbol{\pi}}(s, \boldsymbol{a})| \\
    &=2\epsilon\left[1-\prod_{i=1}^N(1-\eta_i) \right],
    \label{eq:30}
\end{align}
where $\eta_i=\max_{\tau^i}\text{Pr}(a^i\neq\tilde{a}^i|\tau^i)$, and $(\boldsymbol{\pi}, \tilde{\boldsymbol{\pi}})$ represents $\{(\pi^1,\tilde{\pi}^1), \ldots, (\pi^N, \tilde{\pi}^N) \}$, $(\pi^i, \tilde{\pi}^i)$ is an $\alpha_i$-coupled policy pair for $i=1, 2, \ldots, N$. 
The definition of $\alpha_i$-coupled policy pair in \citep{Schulman2015TrustRP} implies that $(\pi^i, \tilde{\pi}^i)$ is a joint distribution $p(a^i, \tilde{a}^i|\tau^i)$ satisfying $\text{Pr}(a^i\neq \tilde{a}^i|\tau^i)\leq \alpha_i$. 

From Proposition 4.7 in \citep{levin2017markov}, if we have two distributions $p_X, p_Y$ that satisfy $D_{TV}(p_X\|p_Y)=\alpha$, then there exists a joint distribution $P(X, Y)$ whose marginals are $p_X, p_Y$, such that:
\begin{equation}
  \text{Pr}(X=Y)=1-\alpha
\end{equation}
Furthermore, note that there is a relationship between the total variation divergence and the KL divergence \citep{Pollard2000Asymptopia}: $D_{TV}(p\|q)^2\leq \frac{1}{2}D_{KL}(p\|q)$. 
Now let $\alpha_i = \max_{\tau^i}\sqrt{\frac{1}{2}D_{KL}\left[\pi^i(\cdot|\tau^i)\|\tilde{\pi}^i(\cdot|\tau^i)\right]}$, then there exists a joint distribution $(\pi^i,\tilde{\pi}^i)$ whose marginals are $\pi^i, \tilde{\pi}^i$, satisfying: 
\begin{equation}
  \text{Pr}(a^i = \tilde{a}^i|\tau^i)\geq 1-\alpha_i.
\end{equation}
Thus $\eta_i\leq\alpha_i$. 
Since $\eta_i,\alpha_i\leq 1$, $\left[1-\prod_{i=1}^N(1-\eta_i)\right]$ will increase as $\eta_i$ increases. 
Then Eq.~(\ref{eq:lemma2}) can be derived by replacing $\eta_i$ with $\alpha_i$ in Eq.~(\ref{eq:30}). 

For simplification, we denote $\mathbb{E}_{\tilde{\boldsymbol{a}}\sim\tilde{\boldsymbol{\pi}}}[A^{\boldsymbol{\pi}}(s, \tilde{\boldsymbol{a}})]$ as $\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s)$ and use $n_t$ to represent the times $\boldsymbol{a}\neq\tilde{\boldsymbol{a}}$ before timestep $t$. Then there is:
\begin{align}
  &\quad\left|\mathbb{E}_{s_t\sim\rho^{\tilde{\boldsymbol{\pi}}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]-\mathbb{E}_{s_t\sim\rho^{\boldsymbol{\pi}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]\right| \\
  &=\text{Pr}(n_t>0)\cdot\left|\mathbb{E}_{s_t\sim\rho^{\tilde{\boldsymbol{\pi}}}}[\bar{A}^{\tilde{\boldsymbol{\pi}},\boldsymbol{\pi}}(s_t)]-\mathbb{E}_{s_t\sim\rho^{\boldsymbol{\pi}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]\right|\\
   &=\left(1-\text{Pr}(n_t=0)\right)\cdot \left|\mathbb{E}_{s_t\sim\rho^{\tilde{\boldsymbol{\pi}}}|n_t>0}[\bar{A}^{\tilde{\boldsymbol{\pi}},\boldsymbol{\pi}}(s_t)]-\mathbb{E}_{s_t\sim\rho^{\boldsymbol{\pi}}|n_t>0}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]\right|\\
   &=\left(1-\prod_{t'=0}^t\prod_{i=1}^N \text{Pr}(a^i_t=\tilde{a}^i_t|\tau^i)\right)\cdot|\cdots| \\
   &\leq\left(1-\prod_{i=1}^N\left(1-\alpha_i\right)^{t}\right)\cdot\left|\cdots\right|\\
   &\leq\left(1-\prod_{i=1}^N\left(1-\alpha_i\right)^{t}\right)\cdot2\max_s\left|\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s)\right|,
\end{align}
where $|\cdots|$ denotes $\left|\mathbb{E}_{s_t\sim\rho^{\tilde{\boldsymbol{\pi}}}|n_t>0}[\bar{A}^{\tilde{\boldsymbol{\pi}},\boldsymbol{\pi}}(s_t)]-\mathbb{E}_{s_t\sim\rho^{\boldsymbol{\pi}}|n_t>0}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]\right|$ for brevity.
Then, the following can be derived using Eq.~(\ref{eq:lemma2}):
\begin{align}
  &\quad\ \left|\mathbb{E}_{s_t\sim\rho^{\tilde{\boldsymbol{\pi}}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]-\mathbb{E}_{s_t\sim\rho^{\boldsymbol{\pi}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]\right|\\
   &\leq 2\left(1-\prod_{i=1}^N\left(1-\alpha_i\right)^{t}\right)\left[1-\prod_{i=1}^N\left(1-\alpha_i\right) \right]\max_{s,\boldsymbol{a}}|A^{\boldsymbol{\pi}}(s, \boldsymbol{a})|\\
   &\leq 4\epsilon\left[1-\prod_{i=1}^N\left(1-\alpha_i\right) \right]\left[1-\prod^N_{i=1}\left(1-\alpha_i\right)^{t}\right],
\end{align}
Finally we reach our conclusion:
\begin{align}
  \left| J(\boldsymbol{\tilde{\pi}})-L_{\boldsymbol{\pi}}(\boldsymbol{\tilde{\pi}}) \right|
  &=\left|\mathbb{E}_{\boldsymbol{a}\sim\tilde{\boldsymbol{\pi}}, s\sim\rho^{\tilde{\boldsymbol{\pi}}}}\left[ A^{\boldsymbol{\pi}}(s,\boldsymbol{a}) \right]-\mathbb{E}_{\boldsymbol{a}\sim\tilde{\boldsymbol{\pi}}, s\sim\rho^{\boldsymbol{\pi}}}\left[ A^{\boldsymbol{\pi}}(s,\boldsymbol{a}) \right]\right|\\
  &=\Biggl| \sum_s\sum_{t=0}^\infty\gamma^t\text{Pr}(s_t=s|\tilde{\boldsymbol{\pi}})\sum_{\boldsymbol{a}}\tilde{\boldsymbol{\pi}}(\boldsymbol{a}|s)A^{\boldsymbol{\pi}}(s,\boldsymbol{a})- \nonumber\\
  &\quad\sum_s\sum_{t=0}^\infty\gamma^t\text{Pr}(s_t=s|\boldsymbol{\pi})\sum_{\boldsymbol{a}}\tilde{\boldsymbol{\pi}}(\boldsymbol{a}|s)A^{\boldsymbol{\pi}}(s,\boldsymbol{a})\Biggr|\\ 
  &\leq\sum_{t=0}^\infty\gamma^t\left|\mathbb{E}_{s_t\sim\rho^{\tilde{\boldsymbol{\pi}}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]-\mathbb{E}_{s_t\sim\rho^{\boldsymbol{\pi}}}[\bar{A}^{\tilde{\boldsymbol{\pi}}, \boldsymbol{\pi}}(s_t)]\right|\\
  &\leq\sum_{t=0}^\infty\gamma^t\cdot 4\epsilon\left[1-\prod_{i=1}^N(1-\alpha_i) \right]\left[1-\prod_{i=1}^N(1-\alpha_i)^{t}\right]\\
  &=4\epsilon\left[1-\prod_{i=1}^N(1-\alpha_i) \right]\left[\frac{1}{1-\gamma}-\frac{1}{1-\gamma\prod_{i=1}^N(1-\alpha_i)}\right]\\
  &\leq 4\epsilon\left[\frac{1-\gamma\prod_{i=1}^N(1-\alpha_i)}{1-\gamma}-1 \right].
\end{align}

\end{proof}

\subsection{Transformation from the joint objective into the local objectives}
\label{app:local argmax}

In Section~\ref{sec:Final Objective}, the joint objective is derived as:
\begin{equation}
  \label{appeq:jointob}
    \mathop{\mbox{maximize}\ }\limits_{\theta^1,\ldots,\theta^N}\ \mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left\{\min \left[\left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}, \text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{\boldsymbol{\pi}}\right]\right\},
\end{equation}
where $\theta^j$ is the parameter of agent $j$'s policy, 
and $r^j=\frac{\pi^j\left(a^j|\tau^j;\theta^j\right)}{\pi^j_{old}\left(a^j|\tau^j;\theta^j_{old}\right)}$.
After a linear decomposition on $A^{\boldsymbol{\pi}}$ with non-negative weights (i.e. $A^{\boldsymbol{\pi}} = \sum_{j}c^jA^j$), the objective above then can be transformed into:
\begin{equation}
  \label{appeq:respectob}
  \mathop{\mbox{maximize}\ }\limits_{\theta^i}\ \mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left\{\min \left[\left(\prod_{j\neq i} r^j\right)r^i A^{i}, \text{clip}\left(\left(\prod_{j\neq i} r^j\right)r^i, 1-\epsilon, 1+\epsilon\right)A^{i}\right]\right\},
\end{equation}
where $i=1, \ldots, N$.
Now we provide a detailed proof.
\begin{proof}
If 
\begin{align}
\min \left[\left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}, \text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{\boldsymbol{\pi}}\right] = 
\text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{\boldsymbol{\pi}},
\end{align}
then the objective is actually $(1 - \epsilon)A^{\boldsymbol{\pi}}$ or $(1 + \epsilon)A^{\boldsymbol{\pi}}$, 
and no gradient will be backpropagated as none of $\theta^1, \ldots, \theta^N$ is in the objective.
Furthermore, there is 
  \begin{align}
    &\min \left[\left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}, \text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{\boldsymbol{\pi}}\right] \\
    = &\min \left[\sum_ic^i\left(\prod_{j=1}^N r^j\right) A^{i}, \sum_ic^i\text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{i}\right].
  \end{align}
Thus, the discussion can be simplified to the case where 
\begin{equation}
\min \left[\left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}, \text{clip}\left(\left(\prod_{j=1}^N r^j\right), 1-\epsilon, 1+\epsilon\right)A^{\boldsymbol{\pi}}\right] = 
\left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}. 
\end{equation}
While $\tfrac{\partial \left(\prod_{j=1}^N r^j\right)A^{\boldsymbol{\pi}}}{\partial \left(\prod_{j=1}^N r^j\right)A^i} = c^i $ and $c^i\geq 0$, there is
\begin{align}
  \mathop{\mbox{max}\ }\limits_{\theta^1, \ldots, \theta^N}\ \left(\prod_{j=1}^N r^j\right) A^{\boldsymbol{\pi}}
  &= \mathop{\mbox{max}\ }\limits_{\theta^1, \ldots, \theta^N}\ \sum_ic^i\left(\prod_{j=1}^N r^j\right) A^{i}\\
  &= \sum_i c^i \mathop{\mbox{max}\ }\limits_{\theta^i}\ \left(\prod_{j=1}^N r^j\right) A^{i}
\end{align}
Therefore, the transformation from Eq.~(\ref{appeq:jointob}) to Eq.~(\ref{appeq:respectob}) is proved. 

\end{proof}


\subsection{The potential high variance of probability ratio product}
\label{app:variance ineq}

Section~\ref{sec:Final Objective} mentions that there exists a risk of high variance in estimating the policy gradient when optimizing Eq.~(\ref{eq:jointob}), due to the following proposition:
\begin{propo*}
  Assuming that the agents are fully independent during execution, then the following inequality holds:
\begin{equation}
  \label{eq:appA2}
  \text{\large Var}_{\boldsymbol{a}^{-i}\sim\boldsymbol{\pi}^{-i}_{old}}\left[\prod_{j\neq i} r^j\right] \geq \prod_{j\neq i}\text{\large Var}_{a^j\sim\pi^j_{old}}\bigl[r^j\bigr],
\end{equation}
where $r^j=\frac{\pi^j(a^j|\tau^j;\theta^j)}{\pi^j_{old}(a^j|\tau^j;\theta^j_{old})}$. 
\end{propo*}
Because the agents execute the actions based only on locally observable information, it is reasonable to assume that $\pi^i$ and $\pi^j$ is independent when $i\neq j$. 
Now we present a detailed proof for this proposition. 

\begin{proof}
  
  Because the agents are fully independent during execution,
  there is a decomposition that $\boldsymbol{\pi}^{-i}(\boldsymbol{a}^{-i}|\boldsymbol{\tau}^{-i})=\prod_{j\neq i}\pi^j(a^j|\tau^j)$. 

  Now we use mathematical induction to prove the fact. 
  First, we assume that there are 3 agents, and let $i=3$ without loss in generality. 
  Then there is:
  \begin{align}
    \label{eq:vardecom}
    \text{\large Var}_{a^1, a^2}\left[r_1r_2\right]
    &= \mathbb{E}_{a^1, a^2}\left[\left(r_1r_2\right)^2\right] - \left(\mathbb{E}_{a^1,a^2}\left[r_1r_2\right]\right)^2 \\
    &= \mathbb{E}_{a^1}\left[r_1^2\right]\mathbb{E}_{a^2}\left[r_2^2\right] - \left(\mathbb{E}_{a^1}\left[r_1\right]\mathbb{E}_{a^2}\left[r_2\right]\right)^2.
  \end{align}
  Hence, there is: 
  \begin{align}
    &\text{\large Var}_{a^1, a^2}\left[r_1r_2\right] - \text{\large Var}_{a^1}\left[r_1\right]\text{\large Var}_{a^2}\left[r_2\right]\\
    = &\mathbb{E}_{a^1}\left[r_1^2\right]\mathbb{E}_{a^2}\left[r_2^2\right] - \left(\mathbb{E}_{a^1}\left[r_1\right]\mathbb{E}_{a^2}\left[r_2\right]\right)^2 - \nonumber \\ 
    &\left[\mathbb{E}_{a^1}\left[r_1^2\right]- \left(\mathbb{E}_{a^1}\left[r_1\right]\right)^2 \right] \left[\mathbb{E}_{a^2}\left[r_2^2\right]- \left(\mathbb{E}_{a^2}\left[r_2\right]\right)^2 \right] \\
    =&\left(\mathbb{E}_{a^1}\left[r_1\right]\right)^2\mathbb{E}_{a^2}\left[r_2^2\right] + \left(\mathbb{E}_{a^2}\left[r_2\right]\right)^2\mathbb{E}_{a^1}\left[r_1^2\right] -
    2 \left(\mathbb{E}_{a^1}\left[r_1\right] \mathbb{E}_{a^2}\left[r_2\right]\right)^2 \\
    =&\left(\mathbb{E}_{a^1}\left[r_1\right]\right)^2 \text{\large Var}_{a^2}\left[r_2\right] + \left(\mathbb{E}_{a^2}\left[r_2\right]\right)^2 \text{\large Var}_{a^1}\left[r_1\right]\geq 0.
  \end{align}
  By now we have proven $\text{\large Var}_{a^1, a^2}\left[r_1r_2\right] \geq \text{\large Var}_{a^1}\left[r_1\right]\text{\large Var}_{a^2}\left[r_2\right]$. 
  Then if Eq.~(\ref{eq:appA2}) holds for the case of $N$ agents, then obviously there is:
  \begin{align}
    \prod_{j\neq i}^{N+1}\text{\large Var}\left[r^j\right]
    &= \left(\prod_{j\neq i}^N\text{\large Var}\left[ r^j \right]\right) \text{\large Var}_{a^{N+1}}\left[r^{N+1}\right] \\
    &\leq \text{\large Var}\left[\prod_{j\neq i}^Nr^j\right] \text{\large Var}_{a^{N+1}}\left[r^{N+1}\right] \\
    &\leq \text{\large Var}\left[\prod_{j\neq i}^{N+1}r^j\right],
  \end{align}
  thus proving the proposition.

\end{proof}

\subsection{The simplification in the analysis of CoPPO and MAPPO}
\label{app:interprete simplify}

In Section~\ref{sec:Interpre}, the difference between CoPPO and MAPPO is simplified to the difference between 
$\mathbb{E}_{\boldsymbol{\pi}_{old}}\left[r^i_kA^{i}\right]$ 
and
$\mathbb{E}_{\boldsymbol{\pi}_{old}}\bigl[r^i_k\tilde{A}^{i}_{k}\bigr]$. 
Now we detail the rationality of this simplification.

In each update, the value of both the two objectives start from the respective lower bounds and are updated conservatively during the optimization epochs.
The objectives monotonically increase or decrease until they reach the clipping threshold.
No update will be made when the objective is clipped, because $\theta^i$ is not in the clipped value (i.e. $(1-\epsilon_1)A^i$ or $(1+\epsilon_1)A^i$) and no gradient will be backpropagated then, 
just as discussed in Appendix~\ref{app:local argmax}.

\subsection{$\prod_{j\neq i}r_k^j$ implies the variation of the probability to take $\boldsymbol{a}^{-i}$}
\label{app:trend for other agents}

Section~\ref{sec:Interpre}  mentions that $\prod_{j\neq i}r_k^j > 1$ will cause an increase in $\boldsymbol{\pi}^{-i}(\boldsymbol{a}^{-i}|\boldsymbol{\tau}^{-i})$ and vice versa. 
Now we provide the details. 

Similar to Appendix~\ref{app:variance ineq}, the decentralized policies can be viewed independently, thus $\boldsymbol{\pi}^{-i}(\boldsymbol{a}^{-i}|\boldsymbol{\tau}^{-i})=\prod_{j\neq i}\pi^j(a^j|\tau^j)$. 
By definition, $\prod_{j\neq i}r^j_k = \prod_{j\neq i}\frac{\pi^j_k(a^j|\tau^j)}{\pi^j_{old}(a^j|\tau^j)}$. 
Synthesizing the two equations, we have $\prod_{j\neq i}r^j_k = \frac{\boldsymbol{\pi}^{-i}_k(\boldsymbol{a}^{-i}|\boldsymbol{\tau}^{-i})}{\boldsymbol{\pi}^{-i}_{old}(\boldsymbol{a}^{-i}|\boldsymbol{\tau}^{-i})}$ which
suggests that if $\prod_{j\neq i}r^j_k>1$, $\boldsymbol{a}^{-i}$ will be more likely to be jointly performed by the other agents given similar observations, and vice versa. 

\section{Pseudo Code}
The details of our CoPPO algorithm are given in Algorithm~\ref{algo}.
\label{app:alg}
\begin{algorithm}
  \caption{The CoPPO Algorithm} 
  \label{algo}
	\begin{algorithmic}[1]
    \State Initialize policies $\pi^1_{old},\ldots,\pi^N_{old}$ for $N$ agents respectively;
		\For {$iteration=1,2,\ldots$}
			\For {$rollout\ thread=1,2,\ldots,R$}
				\State Run policies $\pi^{1:N}_{old}$ in environment for $T$ time steps;
				\State Compute advantage estimates $\hat{A}_{1:T}^{\pi_{old}^{j}},\ldots,\hat{A}_{1:T}^{\pi_{old}^{j}}, \ j=1, 2, \ldots, N$;
			\EndFor
      \For {$k=0, 1,\ldots,K-1$}
        \For {$i=1, 2,\ldots,N$}
          \State Optimize the objective
          \State $L(\theta^i)=\mathbb{E}_{\boldsymbol{a}\sim\boldsymbol{\pi}_{old}}\left\{\min\left[g(\boldsymbol{r}^{-i}) r^iA^{i},
  \text{clip}\left(g(\boldsymbol{r}^{-i})r^i, 1-\epsilon_{1}, 1+\epsilon_1\right)A^{i}\right] \right\}$
          \State to update the policy $\pi^i$ w.r.t. $\theta^i$;
          % \State $\theta^i_{k}\leftarrow\theta^i$
        \EndFor
      \EndFor
      \State $\theta_{old}^{j}\leftarrow\theta_{K}^{j},\ j=1, 2, \ldots N$;
		\EndFor
	\end{algorithmic} 
\end{algorithm}

\section{Implementation Details}
\label{app:implement}

Experiments are conducted on NVIDIA Quadro RTX 5000 GPUs.
The network architectures, optimizers, hyperparameters and environment settings in the cooperative matrix game and SMAC are described respectively in the following subsections.

\subsection{Cooperative matrix game}
\label{app:matrix implement}

We utilize the same actor-critic network architecture for all the algorithms. 
The actor consists of two 18-dimensional fully-connected layers with $\tanh$ activation. 
For the critic, two 72-dimensional fully-connected layers are adopted with $\tanh$ activation.
For the hyper network in DOP which is used to derive the weights and biases for local value mixing, 
we use two 36-dimensional fully-connected layers with $\tanh$ activation for both the weights and biases deriving.
The optimization of both the actors and critics is conducted using RMSprop with the learning rate of $5\times 10^{-4}$ and $\alpha$ of $0.99$. 
No momentum or weight decay is used in the optimizers.
The discounted factor is set to $0.99$; 
the number of the optimization epochs (i.e. $K$) for CoPPO and MAPPO is set to $8$;
the outer clipping threshold (i.e. $\epsilon$ for MAPPO and $\epsilon_1$ for CoPPO) is set to $0.20$.
For the inner clipping threshold in CoPPO,
we consider $\epsilon_2\in\{0.05, 0.10, 0.15\}$ and adopt $0.10$ in the comparison with baselines.
For exploration, we use $\epsilon$-greedy with $\epsilon$ annealed linearly from $0.9$ to $0.02$ over $6k$ timesteps.


\subsection{SMAC}
\label{app:smac implement}

The same actor-critic network architecture are utilized for all maps we have evaluated on. 
Both the actor and critic networks consist of two fully-connected layers, one GRU layer and one fully-connected layer sequentially with ReLU activation.
For the mixing network mentioned in Section~\ref{sec:Final Objective}, 
we adopt the hyper network in \citep{Rashid2018QMIXMV} to derive the weights and bias for local advantages, 
and enforce the weights to be non-negative. 
Similar to QMIX, the input of the hyper network is the global state. 
The dimensions of these layers are all set to 64, except for the 32-dimensional hidden layers of the mixing network.

For the evaluation on different maps, all the hyperparameters are fixed except for the number of optimization epochs which is set to 15  for 2s3z, 3s\_vs\_3z, and 1c3s5z, 10 for 3s5z and 10m\_vs\_11m, and 8 for MMM2.
The number of epochs overall decreases as the difficulty of the map increases, ranging from $5$ to $15$.
The optimization of both the actors and critics is conducted using RMSprop with the learning rate of $5\times 10^{-4}$ and $\alpha$ of $0.99$. 
No momentum or weight decay is used in the optimizers. 
The discounted factor $\gamma$ is set to 0.99. 
For advantage estimation, the generalized advantage estimation \citep{Schulman2016HighDimensionalCC} is adopted and the corresponding hyperparameter $\lambda$ is set to 0.90. 
Note that state value functions instead of state-action value functions are estimated in SMAC.
The inner clipping threshold (i.e. $\epsilon_2$ for CoPPO) is set to   $0.10$, while the outer clipping threshold (i.e. $\epsilon$ for MAPPO and $\epsilon_1$ for CoPPO) is set to $0.20$.
8 parallel environments are run for data collecting. 

Overall, our implementation builds upon the one of \citep{Yu2021TheSE}.
Note that MAPPO uses hand-coded states  (i.e. Feature-Pruned Agent-Specific Global State) as the input of value functions, while in our implementation these states are modified into the concatenation of the Environment-Provided Global State and the Local Observation, in order to make the comparison with baselines fair.
For the other baselines, we adopt the official implementations and their default hyperparameter settings that have been fine-tuned on this benchmark.


\section{Additional Results}
\subsection{Cooperative matrix games}
\label{app:additional results(matrix)}

Section~\ref{sec:matgame} shows the results on a modification of the two-player penalty game.
Now we present the results on other matrix games  across different types and different difficulties in Fig.~\ref{fig:matrix additional}, and CoPPO outperforms the other methods in almost all the games, thus showing the general effectiveness.
For evaluation, the results are also averaged over 100 runs.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figures/matrix_additional.pdf}
  \caption{\footnotesize Performance comparisons in six matrix games.
  }
  \label{fig:matrix additional}
\end{figure}

These games are all 4-agent, 9-action cooperative games.
The respective reward settings are as follows.
The "miscoordination" mentioned below all refers to the case where any three agents act the same while the other does not.
Fig.~\ref{fig:matrix additional}-upper left and middle are both  simplifications of the penalty game presented in Section~\ref{sec:matgame}.
In Fig.~\ref{fig:matrix additional}-upper left, there is no penalty for miscoordination; in Fig.~\ref{fig:matrix additional}-upper middle, the team reward becomes larger (100) when the agents play the same action. 
The other rewards are set the same with the one in Section~\ref{sec:matgame}.
In Fig.~\ref{fig:matrix additional}-upper right, there is only one optimal joint action and the difficulty lies mainly in exploration.
The agents will receive the reward of 50 if agent $i$ plays action $i$ and -50 otherwise. 
Fig.~\ref{fig:matrix additional}-lower left is the result on a modification of the \emph{climbing game} that has been used as another challenging test bed for CoMARL algorithms \citep{claus1998dynamics}, where the reward is $i\cdot 10$ if the agents all play action $i$ and -40 otherwise.
Fig.~\ref{fig:matrix additional}-lower middle and right gradually increase the difficulty of the climbing game by setting obstacles in the way of climbing.
In Fig.~\ref{fig:matrix additional}-lower middle, the agents will be punished by -50 for miscoordination.
As for Fig.~\ref{fig:matrix additional}-lower right, the miscoordination penalty increases as the matching reward increases, i.e. $-i\cdot 10$ for miscoordination on action $i$, hence the risk will become higher and higher when the agents are "climbing" to the optimal joint action.


\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/smac_clippingseparately.pdf}
  \caption{\footnotesize Ablation study on the methods of clipping.}
  \label{fig:smac_clippingseparately}
\end{figure}



\subsection{SMAC}

\subsubsection{Comparison of clipping jointly and separately}
\label{app:clipping_separately}
We empirically evaluate two clipping approaches mentioned in Section~\ref{sec:Final Objective}, i.e.  clipping jointly ($\text{clip}(\prod_{j=1}^Nr^j,\cdot,\cdot)$) and clipping separately ($\prod_{j=1}^N\text{clip}(r^j,\cdot,\cdot)$). 
The results shown in Fig.~\ref{fig:smac_clippingseparately} demonstrate that clipping separately performs  worse than clipping jointly. 
To find the cause resulting in this performance discrepancy,  an empirical analysis is conducted on the value of policy gradients and ratio products w.r.t. the two clipping methods, 
and the results are presented in Fig.~\ref{fig:smac_clippingseparately_ratiograd}.
Obviously clipping jointly yields more stable ratio product and policy gradients than clipping separately, implying that the performance discrepancy might be owing to the stability in the policy update.


\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/smac_clipseparate_ratiograd.pdf}
  \caption{\footnotesize Comparison of two clipping methods on ratio product and mean policy gradients, evaluated on 3s\_vs\_3z.}
  \label{fig:smac_clippingseparately_ratiograd}
\end{figure}

\subsubsection{Results on three more maps of SMAC}
Some additional results for further verification of the effectiveness of CoPPO in SMAC are given in Fig.~\ref{fig:smac_additional}.
Note that CoPPO outperforms all the baselines in the maps we have evaluated on, except for the MMM map where CoPPO achieves competitive performance against MAPPO.
\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{figures/smac_additional.pdf}
  \caption{\footnotesize Additional results on SMAC.}
  \label{fig:smac_additional}
\end{figure}

\end{document}