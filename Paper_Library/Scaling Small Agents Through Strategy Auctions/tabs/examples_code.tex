\vspace{5pt}
\PlanTriple{%
  Write a function to verify validity of a string of parentheses. Your code should pass the following test: \texttt{assert is\_valid\_parenthese("(){}[]")==True}
}{%
  1. Implement a function using a stack to track opening brackets.\\
  2. Create a mapping of closing brackets to their corresponding opening brackets.\\
  3. Iterate through each character in the input string.\\
  4. Push opening brackets onto the stack.\\
  5. For closing brackets, check if the stack is empty or the top element does not match the expected opening bracket.\\
  6. Return True if the stack is empty after processing all characters, otherwise return False.
}{%
  1. Analyze the task: Create a function to validate balanced parentheses using a stack-based approach. \\ 
  2. Define a mapping of closing brackets to their corresponding opening brackets.\\  
  3. Iterate through each character in the input string, pushing opening brackets onto the stack and checking for matches when encountering closing brackets.\\  
  4. Return \texttt{True} if the stack is empty after processing all characters (indicating balanced parentheses), otherwise \texttt{False}.\\  
  5. Validate the function with the test case \texttt{assert is\_valid\_parenthese("(){}[]") == True}.\\  
  6. Use the \texttt{final\_answer} tool to submit the implemented code.  
}{%
  Explicit focus on returning the correct artifact, systematic testing and edge-case coverage 
}\label{ex:parentheses}

\newpage
\PlanTriple{%
  Write a function to calculate magic square. Your code should pass the following test: \texttt{assert magic\_square\_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True}
}{%
  1. Verify the input matrix is a square (all rows have the same length as the number of rows).\\
  2. Check all elements are unique and within the range 1 to $n^2$.\\
  3. Calculate the magic constant as the sum of the first row.\\
  4. Validate all rows, columns, and both diagonals sum to the magic constant.\\
  5. Return True if all checks pass, otherwise False.
}{%
  1. Define the function \texttt{magic\_square\_test} that takes a matrix as input.
  2. Verify the matrix is a square (all rows have the same length as the number of rows).\\
  3. Check all elements are unique and within the range 1 to $n^2$ (where $n$ is the size of the matrix).\\
  4. Calculate the magic constant using the formula \texttt{n * (n**2 + 1) // 2}.\\
  5. Validate all rows, columns, and both diagonals sum to the magic constant.\\
  6. Return \texttt{True} if all checks pass, otherwise \texttt{False}.\\
  7. Use the \texttt{final\_answer} tool to submit the implemented function as the solution. 
}{%
  Precise function and helper signatures, explicit focus on returning the correct artifact
}\label{ex:magic_square}

\vspace{20pt}
\PlanTriple{%
  Write a function to sort a list of elements using comb sort. Your code should pass the following tests: assert \texttt{comb\_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]}
}{%
  1. Create a copy of the input list to avoid modifying the original.\\
  2. Initialize the gap as the length of the list divided by 1.3, then cast to an integer.\\
  3. While the gap is greater than 1, iterate through the list with the current gap, comparing elements i and i + gap. If they are out of order, swap them.\\
  4. After each pass, update the gap by dividing it by 1.3 and casting to an integer.\\
  5. Once the gap is 1, perform a final bubble sort pass to ensure the list is fully sorted.\\
  6. Return the sorted list.
}{%
  1. Implement the \texttt{comb\_sort} function to sort a list using the comb sort algorithm.\\  
  2. Initialize the gap as the length of the list divided by 1.3, then cast to an integer.\\  
  3. While the gap is greater than 1, iterate through the list and compare elements \texttt{i} and  \texttt{i + gap}. Swap them if they are out of order.\\  
  4. After each pass, reduce the gap by dividing it by 1.3 and cast to an integer, ensuring it does not fall below 1.\\  
  5. Once the gap is 1, perform a final pass to ensure the list is fully sorted (similar to bubble sort).\\  
  6. Return the sorted list.\\  
  7. Use the \texttt{final\_answer} tool to submit the implemented function as the solution.
}{%
  Precise function and helper signatures, explicit focus on returning the correct artifact
}\label{ex:comb_sort}

\newpage
\vspace*{100pt}
\PlanTriple{%
  Write a python function to find the sum of common divisors of two given numbers. Your code should pass the following test: \texttt{assert sum(10,15) == 6}
}{%
  1. Compute the greatest common divisor (GCD) of the two input numbers.\\
  2. Find all divisors of the GCD by iterating from 1 to the GCD and checking for divisibility.\\
  3. Sum all the divisors found in step 2.\\
  4. Return the computed sum as the result of the function.
}{%
  1. **Understand the problem**: Create a Python function \texttt{sum(a, b)} that returns the sum of all common divisors of \texttt{a} and \texttt{b}.\\
  \\
  2. **Compute GCD**: Use Euclidean algorithm to find the greatest common divisor (GCD) of the two numbers, as all common divisors of \texttt{a} and \texttt{b} are divisors of their GCD.\\
  \\
  3. **Find divisors of GCD**: Efficiently find all divisors of the GCD by iterating up to its square root. For each divisor \texttt{i}, add both \texttt{i} and \texttt{gcd // i} to the sum (if they are distinct).\\
  \\
  4. **Handle edge cases**: Ensure the function works for inputs where GCD is 0 (though inputs are positive integers as implied by the test case).\\
  \\
  5. **Implement the function** in Python using the described logic.\\
  \\
  6. **Verify correctness** with the provided test case \texttt{sum(10, 15) == 6}.\\
  \\
  7. **Provide the final answer** using the \texttt{final\_answer} tool.
}{%
  Precise function and helper signatures, systematic testing and edge-case coverage, clearer/more structured layout 
}\label{ex:common_divisors}


