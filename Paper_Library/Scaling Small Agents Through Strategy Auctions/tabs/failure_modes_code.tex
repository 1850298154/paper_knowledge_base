\vspace{100pt}
\begin{examplebox}[label=ex:1_coding]{Coding Example 6}
    \exquestion{%
        You are an expert Python programmer, and here is your task: Write a function to convert a tuple of string values to a tuple of integer values. Your code should pass the following test: \texttt{assert tuple\_int\_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))}
    }
    \incorrectresponse{%
        \\
        1. Analyze the task: Create a function that converts nested tuples of strings to integers.\\
        2. Implement a solution using nested tuple comprehensions to recursively convert each string element to an integer.\\
        3. Validate the solution against the provided test case to ensure correctness. 
        }  
        {%
        }
    \correctresponse{4}{%
        \\
        The plan is to create a function that converts each string in the input tuple of tuples to an integer, preserving the nested structure.\\ 
        This is achieved by using a generator expression within a \texttt{tuple()} to iterate over each inner tuple, convert each string to an integer, and collect the results into a new tuple of tuples.   
    }{%
    }
\end{examplebox} % issue: 32B plan says "recursively convert" but the problem only shows fixed 2-level nesting. This over-generalization suggests the model may be solving a harder problem than what's asked, which can introduce unnecessary complexity and potential edge case failures. (in contrast, the 4B plan explicitly mentions "inner tuple", showing it correctly understood the specific structure: a tuple of tuples of strings).


\newpage
\begin{examplebox}[label=ex:2_coding]{Coding Example 7}
    \exquestion{%
        You are an expert Python programmer, and here is your task: Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm. Your code should pass the following tests: \texttt{assert merge\_sorted\_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]}
    }
    \incorrectresponse{%
        \\
        1. Import the \texttt{heapq} module to utilize the merge function for efficiently combining sorted iterables.\\
        2. Define a function \texttt{merge\_sorted\_list} that accepts multiple lists as input.\\
        3. For each input list, sort it individually to ensure they are in ascending order.\\
        4. Use \texttt{heapq.merge} to merge the sorted lists into a single sorted iterator.\\
        5. Convert the merged iterator to a list and return it as the final result.
        }  
        {%
        }
    \correctresponse{14}{%
        \\
        1. Define the function \texttt{merge\_sorted\_list} to accept multiple lists as input.\\
        2. Sort each input list individually to ensure they are in ascending order.\\
        3. Initialize a min-heap to track the smallest elements from each sorted list, storing tuples of (value, list index, element index).\\
        4. While the heap is not empty, extract the smallest element, append it to the result, and push the next element from the same list into the heap if available.\\
        5. Return the merged sorted list as the final result. 
    }{%
    }
\end{examplebox} % issue: 32B plan includes importing a specific library function (heapq.merge) that is not an available import, ignoring the available import list, and without a fallback. The 14B plan doesn't even use a real heapâ€”it uses a simpler, less optimal approach which is however more robust than attempting an elegant solution and failing.

\vspace{20pt}
\begin{examplebox}[label=ex:3_coding]{Coding Example 8}
    \exquestion{%
    You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\\
    \\
    \#\#\# Question:\\
    You are given an array of integers nums of size \texttt{n} and a positive integer threshold.\\
    There is a graph consisting of n nodes with the \texttt{i}th node having a value of \texttt{nums[i]}. Two nodes \texttt{i} and \texttt{j} in the graph are connected via an undirected edge if \texttt{lcm(nums[i], nums[j]) <= threshold}.\\
    Return the number of connected components in this graph.\\
    A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\\
    The term \texttt{lcm(a, b)} denotes the least common multiple of \texttt{a} and \texttt{b}.\\
    \\
    Example 1:\\
    \\
    Input: \texttt{nums = [2,4,8,3,9], threshold = 5}\\
    Output: \texttt{4}\\
    Explanation:\\
    The four connected components are \texttt{(2, 4), (3), (8), (9)}.\\
    \\
    Example 2:\\
    \\
    Input: \texttt{nums = [2,4,8,3,9,12], threshold = 10}\\
    Output: \texttt{2}\\
    Explanation:\\
    The two connected components are \texttt{(2, 3, 4, 8, 9)}, and \texttt{(12)}.\\
    \\
    \\
    Constraints:\\
    \\
    \texttt{1 <= nums.length <= 105}\\
    \texttt{1 <= nums[i] <= 109}\\
    All elements of nums are unique.\\
    \texttt{1 <= threshold <= 2 * 105}\\
    \\
    \\
    \#\#\# Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\\
    \\
    \texttt{\textasciigrave\textasciigrave\textasciigrave python final\_answer("""\\
    class Solution:\\
    \hspace*{25pt}def countComponents(self, nums: List[int], threshold: int) -> int:\\
    \\
    """)\textasciigrave\textasciigrave\textasciigrave}\\
    \\
    \#\#\# Answer: (use the provided format with backticks)
    }
    \incorrectresponse{%
    \\
    To solve this problem, we need to determine the number of connected components in a graph where nodes are connected if the least common multiple (LCM) of their corresponding values is less than or equal to a given threshold. The solution involves efficiently using Union-Find (Disjoint Set Union, DSU) to group connected nodes.\\
    \\
    \#\#\# Approach\\
    \\
    1. **Filter and Sort**: First, filter out elements from the input array that are greater than the threshold and sort the remaining elements.\\
    2. **Union-Find Data Structure**: Use a Union-Find (DSU) structure to manage the connected components.\\
    3. **Process Multiples**: For each number in the filtered list, connect it with all its multiples that are also in the list and within the threshold.\\
    4. **Process Pairs with LCM Check**: For each number, check pairs where the LCM is within the threshold and connect them if they meet the condition.\\
    5. **Count Components**: After processing all connections, count the number of unique connected components using the DSU structure and add components from elements that were filtered out due to exceeding the threshold.\\
    \\
    \#\#\# Solution Code\\
    \\
    \texttt{\textasciigrave\textasciigrave\textasciigrave python\\
    import bisect\\
    from math import gcd\\
    from typing import List\\
    \\
    class Solution:\\
    \hspace*{25pt}def countComponents(self, nums: List[int], threshold: int) -> int:\\
        \hspace*{50pt}\# Filter and sort the numbers that are <= threshold\\
        \hspace*{50pt}filtered = [x for x in nums if x <= threshold]\\
        \hspace*{50pt}filtered.sort()\\
        \hspace*{50pt}n = len(filtered)\\
        \hspace*{50pt}if n == 0:\\
            \hspace*{75pt}return len(nums)\\
        \\
        \hspace*{50pt}\# Map each value to its index in the filtered list\\
        \hspace*{50pt}value\_to\_index = \{v: i for i, v in enumerate(filtered)\}\\
        \\
        \hspace*{50pt}\# Define DSU (Disjoint Set Union) structure\\
        \hspace*{50pt}class DSU:\\
            \hspace*{75pt}def \_\_init\_\_(self, size):\\
                \hspace*{100pt}self.parent = list(range(size))\\
                \hspace*{100pt}self.rank = [0] * size\\
                \\
            \hspace*{75pt}def find(self, x):\\
                \hspace*{100pt}if self.parent[x] != x:\\
                    \hspace*{125pt}self.parent[x] = self.find(self.parent[x])\\
                \hspace*{100pt}return self.parent[x]\\
                \\
            \hspace*{75pt}def union(self, x, y):\\
                \hspace*{100pt}x\_root = self.find(x)\\
                \hspace*{100pt}y\_root = self.find(y)\\
                \hspace*{100pt}if x\_root == y\_root:\\
                    \hspace*{125pt}return\\
                \hspace*{100pt}if self.rank[x\_root] < self.rank[y\_root]:\\
                    \hspace*{125pt}self.parent[x\_root] = y\_root\\
                \hspace*{100pt}else:\\
                    \hspace*{125pt}self.parent[y\_root] = x\_root\\
                    \hspace*{125pt}if self.rank[x\_root] == self.rank[y\_root]:\\
                        \hspace*{150pt}self.rank[x\_root] += 1\\
            \\
            \hspace*{50pt}dsu = DSU(n)\\
            \\
            \hspace*{50pt}\# Process each element in the filtered list\\
            \hspace*{50pt}for i in range(n):\\
                \hspace*{75pt}x = filtered[i]\\
                \hspace*{75pt}\# Connect with multiples of x\\
                \hspace*{75pt}m = 2 * x\\
                \hspace*{75pt}while m <= threshold:\\
                    \hspace*{100pt}if m in value\_to\_index:\\
                        \hspace*{125pt}idx = value\_to\_index[m]\\
                        \hspace*{125pt}dsu.union(i, idx)\\
                    \hspace*{100pt}m += x\\
                \hspace*{75pt}\# Connect with other numbers where LCM(x, y) <= threshold\\
                \hspace*{75pt}upper = threshold // x\\
                \hspace*{75pt}if upper >= x:\\
                    \hspace*{100pt}left = i + 1\\
                    \hspace*{100pt}right\_idx = bisect.bisect\_right(filtered, upper) - 1\\
                    \hspace*{100pt}if left <= right\_idx:\\
                        \hspace*{125pt}for j in range(left, right\_idx + 1):\\
                            \hspace*{150pt}y = filtered[j]\\
                            \hspace*{150pt}if (x * y) // gcd(x, y) <= threshold:\\
                                \hspace*{175pt}dsu.union(i, j)\\
            \\
            \hspace*{50pt}\# Count the number of unique roots in DSU\\
            \hspace*{50pt}roots = set()\\
            \hspace*{50pt}for i in range(n):\\
                \hspace*{75pt}roots.add(dsu.find(i))\\
            \\
            \hspace*{50pt}\# Total components is the number of roots in DSU plus elements > threshold\\
            \hspace*{50pt}return len(roots) + (len(nums) - n)\\
    \textasciigrave\textasciigrave\textasciigrave}\\
    \\
    \#\#\# Explanation\\
    \\
    1. **Filtering and Sorting**: The input array is filtered to include only values that are less than or equal to the threshold. This helps in reducing unnecessary computations.\\
    2. **Union-Find Structure**: The DSU structure is used to efficiently manage and merge connected components.\\
    3. **Multiples Processing**: For each number, we connect it with all its multiples within the threshold. This ensures that all direct connections based on multiples are considered.\\
    4. **LCM Check for Pairs**: For each number, we check pairs where the LCM is within the threshold. This ensures that even non-multiples that meet the LCM condition are connected.\\
    5. **Component Counting**: After processing all connections, the number of unique roots in the DSU structure gives the number of connected components for the filtered values. Components from values exceeding the threshold are added separately.\\
    \\
    This approach efficiently handles the constraints and ensures that all valid connections are considered, leading to the correct count of connected components.
    }  
      {%
       }
    \correctresponse{14}{%
    \\
    1. **Sort the input array \textsc{nums}** to facilitate efficient processing of multiples.\\
    2. **Create a mapping from values to their indices** to quickly check if a number exists in the array.\\
    3. **Use a Disjoint Set Union (DSU) structure** to manage connected components.\\
    4. **For each number in \textsc{nums}**, iterate through its multiples up to the threshold and connect the number with its multiples if they exist in the array.\\
    5. **Count the number of unique parents** in the DSU to determine the number of connected components.\\
    6. **Return the count of connected components** as the result. 
    }{%
    }
\end{examplebox} %LC Hard. issue: 32B puts code in plan and the code contains a mathematical error (that is, an extra optimization where the LCM pair checking with threshold // x bound. this is mathematically incorrect). the 14B plan avoids this over complication and uses only the multiples approach (Simpler algorithms have fewer places to introduce bugs) also it does not rush into producing code and produces a high level plan as required by the instructions.

\newpage
\begin{examplebox}[label=ex:4_coding]{Coding Example 9}
    \exquestion{%
    You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\\
    \\
    \#\#\# Question:\\
    You are given a string \texttt{initialCurrency}, and you start with 1.0 of \texttt{initialCurrency}.\\
    You are also given four arrays with currency pairs (strings) and rates (real numbers):\\
    \\
    \texttt{pairs1[i] = [startCurrencyi, targetCurrencyi]} denotes that you can convert from \texttt{startCurrencyi} to \texttt{targetCurrencyi} at a rate of \texttt{rates1[i]} on day 1.\\
    \texttt{pairs2[i] = [startCurrencyi, targetCurrencyi]} denotes that you can convert from \texttt{startCurrencyi} to \texttt{targetCurrencyi} at a rate of \texttt{rates2[i]} on day 2.\\
    Also, each \texttt{targetCurrency} can be converted back to its corresponding \texttt{startCurrency} at a rate of \texttt{1 / rate}.\\
    \\
    You can perform any number of conversions, including zero, using \texttt{rates1} on day 1, followed by any number of additional conversions, including zero, using \texttt{rates2} on day 2.\\
    Return the maximum amount of \texttt{initialCurrency} you can have after performing any number of conversions on both days in order.\\
    Note: Conversion rates are valid, and there will be no contradictions in the rates for either day. The rates for the days are independent of each other.\\
    \\
    Example 1:\\
    \\
    Input: \texttt{initialCurrency = "EUR", pairs1 = [["EUR","USD"],["USD","JPY"]], rates1 = [2.0,3.0], pairs2 = [["JPY","USD"],["USD","CHF"],["CHF","EUR"]], rates2 = [4.0,5.0,6.0]}\\
    Output: \texttt{720.00000}\\
    Explanation:\\
    To get the maximum amount of EUR, starting with 1.0 EUR:\\
    \\
    On Day 1:\\
    \\	
    Convert EUR to USD to get 2.0 USD.\\
    Convert USD to JPY to get 6.0 JPY.\\
    \\
    On Day 2:\\
    \\
    Convert JPY to USD to get 24.0 USD.\\
    Convert USD to CHF to get 120.0 CHF.\\
    Finally, convert CHF to EUR to get 720.0 EUR.\\
    \\
    \\
    Example 2:\\
    \\
    Input: \texttt{initialCurrency = "NGN", pairs1 = [["NGN","EUR"]], rates1 = [9.0], pairs2 = [["NGN","EUR"]], rates2 = [6.0]}\\
    Output: \texttt{1.50000}\\
    Explanation:\\
    Converting NGN to EUR on day 1 and EUR to NGN using the inverse rate on day 2 gives the maximum amount.\\
    \\
    \\
    Example 3:\\
    \\
    Input: \texttt{initialCurrency = "USD", pairs1 = [["USD","EUR"]], rates1 = [1.0], pairs2 = [["EUR","JPY"]], rates2 = [10.0]}\\
    Output: \texttt{1.00000}\\
    Explanation:\\
    In this example, there is no need to make any conversions on either day.\\
    \\
    \\
    Constraints:\\
    \\
    \texttt{1 <= initialCurrency.length <= 3}\\
    \texttt{initialCurrency} consists only of uppercase English letters.\\
    \texttt{1 <= n == pairs1.length <= 10}\\
    \texttt{1 <= m == pairs2.length <= 10}\\
    \texttt{pairs1[i] == [startCurrencyi, targetCurrencyi]}\\
    \texttt{pairs2[i] == [startCurrencyi, targetCurrencyi]}\\
    \texttt{1 <= startCurrencyi.length, targetCurrencyi.length <= 3}\\
    \texttt{startCurrencyi} and \texttt{targetCurrencyi} consist only of uppercase English letters.\\
    \texttt{rates1.length == n}\\
    \texttt{rates2.length == m}\\
    \texttt{1.0 <= rates1[i], rates2[i] <= 10.0}\\
    The input is generated such that there are no contradictions or cycles in the conversion graphs for either day.\\
    The input is generated such that the output is at most \texttt{5 * 1010}.\\
    \\
    \\
    \#\#\# Format: You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\\
    \texttt{\textasciigrave\textasciigrave\textasciigrave python final\_answer("""\\
    class Solution:\\
    \hspace*{25pt} def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:\\
    \\
""")\textasciigrave\textasciigrave\textasciigrave}
    \\
    \\
    \#\#\# Answer: (use the provided format with backticks)
    }
    \incorrectresponse{%
    \\
    \texttt{\textasciigrave\textasciigrave\textasciigrave python\\
    class Solution:\\
    \hspace*{25pt}def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:\\
        \hspace*{50pt}def bellman\_ford(start, edges, all\_currencies):\\
            \hspace*{75pt}max\_amounts = {currency: -float('inf') for currency in all\_currencies}\\
            \hspace*{75pt}max\_amounts[start] = 1.0\\
            \hspace*{75pt}V = len(all\_currencies)\\
            \hspace*{75pt}for \_ in range(V - 1):\\
                \hspace*{100pt}updated = False\\
                \hspace*{100pt}for (u, v, rate) in edges:\\
                    \hspace*{125pt}if max\_amounts[u] != -float('inf'):\\
                        \hspace*{150pt}if max\_amounts[u] * rate > max\_amounts[v]:\\
                            \hspace*{175pt}max\_amounts[v] = max\_amounts[u] * rate\\
                            \hspace*{175pt}updated = True\\
                \hspace*{100pt}if not updated:\\
                    \hspace*{125pt}break\\
            \hspace*{75pt}return max\_amounts\\
        \\
        \hspace*{50pt}\# Process day1\\
        \hspace*{50pt}edges1 = []\\
        \hspace*{50pt}for i in range(len(pairs1)):\\
            \hspace*{75pt}a, b = pairs1[i]\\
            \hspace*{75pt}rate = rates1[i]\\
            \hspace*{75pt}edges1.append((a, b, rate))\\
            \hspace*{75pt}edges1.append((b, a, 1.0 / rate))\\
        \hspace*{50pt}currencies\_day1 = set()\\
        \hspace*{50pt}for a, b in pairs1:\\
            \hspace*{75pt}currencies\_day1.add(a)\\
            \hspace*{75pt}currencies\_day1.add(b)\\
        \hspace*{50pt}currencies\_day1.add(initialCurrency)\\
        \hspace*{50pt}day1\_max = bellman\_ford(initialCurrency, edges1, currencies\_day1)\\
        \\
        \hspace*{50pt}\# Process day2\\
        \hspace*{50pt}edges2 = []\\
        \hspace*{50pt}for i in range(len(pairs2)):\\
            \hspace*{75pt}a, b = pairs2[i]\\
            \hspace*{75pt}rate = rates2[i]\\
            \hspace*{75pt}edges2.append((a, b, rate))\\
            \hspace*{75pt}edges2.append((b, a, 1.0 / rate))\\
        \hspace*{50pt}currencies\_day2 = set()\\
        \hspace*{50pt}for a, b in pairs2:\\
            \hspace*{75pt}currencies\_day2.add(a)\\
            \hspace*{75pt}currencies\_day2.add(b)\\
        \hspace*{50pt}max\_result = 1.0  \# initial amount\\
        \\
        \hspace*{50pt}for c in day1\_max:\\
            \hspace*{75pt}amount\_c = day1\_max[c]\\
            \hspace*{75pt}if amount\_c == -float('inf'):\\
                \hspace*{100pt}continue\\
            \hspace*{75pt}all\_currencies\_day2\_run = currencies\_day2.copy()\\
            \hspace*{75pt}all\_currencies\_day2\_run.add(c)\\
            \hspace*{75pt}day2\_max = bellman\_ford(c, edges2, all\_currencies\_day2\_run)\\
            \hspace*{75pt}current\_value = day2\_max.get(initialCurrency, -float('inf'))\\
            \hspace*{75pt}if current\_value > max\_result:\\
                \hspace*{100pt}max\_result = current\_value\\
        \\
        \hspace*{50pt}return max\_result\textasciigrave\textasciigrave\textasciigrave}
        }  
        {%
        }
    \correctresponse{8}{%
        \\
        To solve the problem of maximizing the amount of the initial currency after performing conversions on two days, we need to model the conversion process as a graph traversal problem. The key steps involve:\\
        \\
        1. **Building the Conversion Graphs**: For each day, construct a graph where nodes represent currencies and edges represent conversion rates (both forward and reverse).\\
        \\
        2. **Topological Sorting**: Since the input guarantees no cycles, we can perform a topological sort on the graph to process nodes in an order that ensures all dependencies are resolved.\\
        \\
        3. **Maximizing Currency Amounts**: Using dynamic programming on the topologically sorted nodes, compute the maximum amount of each currency achievable after each day's conversions.\\
        \\
        4. **Combining Results**: After processing both days, compute the maximum amount of the initial currency by considering all possible paths from the currencies obtained after day 2 back to the initial currency.\\
        \\
        ---\\
        \\
        \#\#\# Step-by-Step Plan\\
        \\
        1. **Build the Graph for Day 1**:\\
        - Construct a graph where each currency pair from \texttt{pairs1} and \texttt{rates1} is represented as bidirectional edges (forward and reverse conversions).\\
        2. **Compute Day 1 Amounts**:\\
        - Starting with 1.0 of the initial currency, use topological sorting to compute the maximum amount of each currency achievable after day 1 conversions.\\
        3. **Build the Graph for Day 2**:\\
        - Construct a similar graph using \texttt{pairs2} and \texttt{rates2}.\\
        4. **Compute Day 2 Amounts**:\\
        - Use the results from day 1 as the starting point for day 2 conversions. Again, use topological sorting to compute the maximum amount of each currency after day 2.\\
        5. **Convert Back to Initial Currency**:\\
         - For each currency obtained after day 2, compute the maximum amount of the initial currency that can be obtained by converting through day 2's graph.\\
        6. **Return the Maximum Result**:\\
        - The final answer is the maximum value among all possible conversions back to the initial currency.\\
        \\
        ---\\
        \\
        \#\#\# Final Plan\\
        \\
        1. **Build the day1 graph** using \texttt{pairs1} and \texttt{rates1}, including both forward and reverse conversions.\\
        2. **Compute day1\_amounts** by traversing the graph in topological order, starting from the initial currency.\\
        3. **Build the day2 graph** using \texttt{pairs2} and \texttt{rates2}, including both forward and reverse conversions.\\
        4. **Compute day2\_amounts** by traversing the day2 graph in topological order, starting from the day1\_amounts.\\
        5. **For each currency in day2\_amounts**, compute the maximum amount of the initial currency by traversing the day2 graph again, starting from that currency.\\
        6. **Return the maximum value** among all computed results.
    }{%
    }
\end{examplebox} % LC medium. issue: the 32B plan already shows the code, which is propagated to the final answer without using the python shell tool for tests. indeed the code is wrong, it returns only current_value (the day 2 multiplier), completely ignoring the day 1 gains. Whereas the 8B plan explicitly accounts for it ("Use the results from day 1 as the starting point for day 2 conversions." and "Compute day2_amounts by traversing the day2 graph in topological order, starting from the day1_amounts."). Note that 8B plan is better but not perfect, it mention topological sort which is inaccurate, but the model corrects this while doing the trace and still obtains the correct final answer (ie correct code).


\newpage


\begin{examplebox}[label=ex:5_coding]{Coding Example 10}
    \exquestion{%
        You are an expert Python programmer, and here is your task: Write a function to find the first duplicate element in a given array of integers. Your code should pass the following test: \texttt{assert find\_first\_duplicate(([1, 2, 3, 4, 4, 5]))==4}
    }
    \incorrectresponse{%
        \\
        1. Create a function \texttt{find\_first\_duplicate} that takes an array as input.\\
        2. Initialize an empty set to track seen elements.\\
        3. Iterate through each element in the array:\\
        a. If the element is already in the set, return it immediately.\\
        b. Otherwise, add the element to the set.\\
        4. Use the \texttt{final\_answer} tool to return the implemented function code.  
        }  
        {%
            % def find_first_duplicate(arr):
            %     seen = set()
            %     for num in arr:
            %         if num in seen:
            %             return num
            %         seen.add(num)
            %     return None
        }
    \correctresponse{14}{%
        \\
        The task is to write a Python function that identifies the first duplicate element in an array of integers. The approach involves iterating through the array while tracking seen elements using a set. When a duplicate is encountered, it is immediately returned as the result.\\
        \\
        1. Initialize an empty set to keep track of elements that have been encountered.\\
        2. Iterate through each element in the input array.\\
        3. For each element, check if it is already in the set:\\
         - If it is, return the element as it is the first duplicate.\\
         - If it is not, add the element to the set.\\
        4. If no duplicates are found during the iteration, return a default value (e.g., -1) to indicate the absence of duplicates.\\
        \\
        This method ensures that the first duplicate is identified efficiently with a time complexity of $O(n)$ and a space complexity of $O(n)$, where n is the number of elements in the array.    
    }{%
        % def find_first_duplicate(arr):
        %     seen = set()
        %     for num in arr:
        %         if num in seen:
        %             return num
        %         seen.add(num)
        %     return -1
    }
\end{examplebox} % issue: 32B plan does not deal with what to do if the loop completes without finding a duplicate. Leading to an incorrect return type for the "no duplicate found" edge case that breaks one of the (hidden) tests.