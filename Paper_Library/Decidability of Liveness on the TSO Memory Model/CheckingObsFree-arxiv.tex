%\vspace{-5pt}
\section{Checking Obstruction-Freedom}
\label{sec:checking obstruction-freedom}

%In this section, we prove that obstruction-freedom is decidable.

\forget{
In this section, we prove that obstruction-freedom is decidable.
We first introduce the basic TSO concurrent systems (the TSO concurrent systems of \cite{DBLP:conf/popl/AtigBBM10}) and the state reachability problem.
Then, we propose a notion called blocking pairs, and reduce checking obstruction-freedom on TSO, which considers infinite executions, into the state reachability problem of basic TSO concurrent systems, which is known to be decidable.
}

\forget{
In this section, we prove that obstruction-freedom is decidable.
We first introduce the basic TSO concurrent systems (the TSO concurrent systems of \cite{DBLP:conf/popl/AtigBBM10}) and the state reachability problem. Then, we propose a notion called blocking pairs, and reduce checking obstruction-freedom on TSO, which considers infinite executions, into checking if some
finite execution reaches a configuration containing a blocking pair.
Finally, we reduce checking blocking pairs into the state reachability problem of
basic TSO concurrent systems, which is known to be decidable.
}



\forget{
In this section, we prove that obstruction-freedom is decidable. We first
introduce the notion of $(S,k)$-(lossy) channel machines
\cite{DBLP:conf/popl/AtigBBM10}.
{Then, we propose a notion called blocking pairs, and slightly extend the TSO semantics to detect blocking pairs. We reduce checking obstruction-freedom on TSO,
which considers infinite executions, into checking if some
finite execution reaches a configuration containing a blocking pair on the extended TSO semantics.}
%Then, we reduce checking obstruction-freedom,
%{\color {blue}which considers infinite length executions,} into checking if some
%finite execution reaches some configuration that ``contains a blocking pair'',
%and then reduce the latter
The latter problem is further reduced into a control state reachability problem of lossy
channel machines, which is known to be decidable.
{We slightly extend the lossy channel machine of \cite{DBLP:conf/popl/AtigBBM10} to detect blocking pairs.}
%{\color {blue}We slightly
%  extend the operational semantics of libraries on TSO and the lossy channel
%  machines of \cite{DBLP:conf/popl/AtigBBM10} to detect blocking pairs.}
}


%\vspace{-5pt}
%\subsection{The TSO Concurrent System of \cite{DBLP:conf/popl/AtigBBM10}}
\subsection{The Basic TSO Concurrent Systems}
\label{subsec:the TSO concurrent system of DBLP:conf/popl/AtigBBM10}


Atig \emph{et al.} \cite{DBLP:conf/popl/AtigBBM10} considers the following concurrent systems on TSO: Each process runs a finite control state program that can do internal, %$\textit{checkPID}$,
read, write and $\textit{cas}$ actions, and different processes communicate via shared memory.
We use \emph{basic TSO concurrent systems} to denote such concurrent systems.
%We obtain the decidability of obstruction-freedom by reducing it to the state reachability problem of basic TSO concurrent systems \cite{DBLP:conf/popl/AtigBBM10}. %Our concurrent systems is similar to the concurrent system of \cite{DBLP:conf/popl/AtigBBM10}.
%Since their concurrent systems do not consider libraries and thus do not need to deal with call and return actions, we transform call and return actions into internal actions. %Since our concurrent systems additionally introduce $\textit{checkPID}$ command,
%We additionally introduce the $\textit{checkPID}$ command to their concurrent systems, and use \emph{basic TSO concurrent systems} to denote such concurrent systems.
% , except two points. First, they do not consider libraries, and thus do not need to deal with call and return actions; second, we additionally introduce $\textit{checkPID}$ command. The first difference can be solved by transforming call and return actions into internal actions. To deal with the second difference, we introduce $\textit{checkPID}$ command into their concurrent systems, and use \emph{basic TSO concurrent systems} do denote such concurrent systems.

%This is similar to our concurrent system, except that they do not consider libraries, and thus do not need to deal with call and return actions. {\color {red}Another difference is that we additionally introduce $\textit{checkPID}$ command.} %When no confusion occur we call the concurrent system of \cite{DBLP:conf/popl/AtigBBM10} a TSO concurrent system of \cite{DBLP:conf/popl/AtigBBM10}, or TSO concurrent system for short.
%{\color {red}We use \emph{basic TSO concurrent systems} to denote the extensions of their concurrent systems by introducing $\textit{checkPID}$ command.}
%To explicitly distinguish their concurrent systems from ours, we denote their concurrent systems as \emph{basic TSO concurrent systems}. %to call their concurrent systems.

Formally, let $\Sigma(proc,\mathcal{D},\mathcal{X})$ be the set containing the $\tau$
(internal) action, %command,
%the $\textit{checkPID}$ actions, %commands,
the read actions, %commands,
the write actions %commands
and the $\textit{cas}$ actions %commands
over memory locations $\mathcal{X}$ with data domain $\mathcal{D}$ and of process $proc$. A basic TSO concurrent system %of \cite{DBLP:conf/popl/AtigBBM10}
is a tuple $(P_1,\ldots,P_n)$, where each $P_i$ is a tuple $(Q_i,\Delta_i)$,
such that $Q_i$ is a finite control state set and $\Delta_i \subseteq Q_i \times
\Sigma(i,\mathcal{D},\mathcal{X}) \times Q_i$ is the transition relation. They
define an operational semantics similar to the one presented in Section
\ref{sec:concurrent systems}. Each configuration is also a tuple $(p,d,u)$,
where $p$ stores control state of each process, $d$ is a memory valuation and
$u$ stores buffer content of each process. We refer the reader to
\cite{DBLP:conf/popl/AtigBBM10} for a detailed description of the operational
semantics on TSO which is unsurprising, and hence omitted here.


Given a basic TSO concurrent system $(P_1,\ldots,P_n)$, two functions $p$ and
$p'$ that store control states of each process and two memory valuations $d$ and
$d'$, the state reachability problem requires to determine whether there is a
path from $(p,d,u_{\textit{init}})$ to $(p',d',u_{\textit{init}})$ in the
operational semantics, where $u_{\textit{init}}$ initializes each process with an empty buffer. Atig \emph{et al.} \cite{DBLP:conf/popl/AtigBBM10} prove
that the state reachability problem is decidable. %in this TSO semantics.



\forget{
\subsection{$(S,k)$-(Lossy) Channel Machines}
\label{subsec:(S,k)-(lossy) channel machines}

In this subsection we introduce the $(S,k)$-(lossy) channel machines of \cite{DBLP:conf/popl/AtigBBM10}, which extend classical (lossy) channel machines of Section \ref{sec:undecidability of lock-freedom and wait-freedom} in the following ways:

\begin{itemize}
\item[-] Each transition is guarded by a condition about whether the content of
  a channel belongs to a regular language.

\item[-] A substitution of the content of a channel may be performed before send operations.

\item[-] We introduce a set of symbols, called ``strong symbols'', which are not
  allowed to be lost. We ensure that the number of strong symbols in a channel
  is always bounded.
\end{itemize}


For a  given channel $c \in \mathcal{CH}$, a regular guard on channel $c$ is a constraint of the form $c \in L$, where
$L \subseteq \Sigma_{\mathcal{CH}}^*$ is a regular set of sequences. For a sequence $u \in \Sigma_{\mathcal{CH}}^*$ and a guard $c \in L$, we write $u \models c \in L$ if $u \in L$.
For notational convenience, we write $a \in c$ instead of $c \in \Sigma_{\mathcal{CH}}^* \cdot a \cdot \Sigma_{\mathcal{CH}}^*$,
$c = \epsilon$ instead of $c \in \{ \epsilon \}$ and $c:\Sigma'$ instead of $c \in \Sigma'^*$ for any subset $\Sigma'$ of $\Sigma_{\mathcal{CH}}$.
A regular guard over $\mathcal{CH}$ associates a regular guard for each channel of $\mathcal{CH}$.
Let $\textit{Guard}(\mathcal{CH})$ be the set of regular guards over $\mathcal{CH}$. The definition of
$\models$ can be extended as follows: for $g \in \textit{Guard}(\mathcal{CH})$ and $u \in \mathcal{CH} \rightarrow \Sigma_{\mathcal{CH}}^*$,
we write $ u \models g$, if $u(c) \models g(c)$ for each $c \in \mathcal{CH}$.

We extend channel operations and introduce substitutions in send operations.
A send operation is of the form $c[\sigma]!a$, where $\sigma$ is a substitution over $\Sigma_{\mathcal{CH}}$.
We write $c ! a$ instead of $c [\sigma] ! a$ when $\sigma$ is the identity substitution.
For every $u \in \Sigma_{\mathcal{CH}}^*$, we have %\\[-5pt]
%\[\llbracket c[\sigma]!a \rrbracket(u,a \cdot u(c)[\sigma])\]
$\llbracket c[\sigma]!a \rrbracket(u,a \cdot u(c)[\sigma])$. The cases $\llbracket c?a \rrbracket(u,u')$ and $\llbracket nop
  \rrbracket(u,u')$ remain unchanged from the previous lossy channel machines.


The notion of channel machine is now extended with guards and substitutions. A channel machine is formally defined as a tuple $\textit{CM} = (Q,\mathcal{CH},\Sigma_{\mathcal{CH}},\Lambda,\Delta)$, where (1) $Q$ is a finite set of states, (2) $\mathcal{CH}$ is a finite set of channel names, (3) $\Sigma_{\mathcal{CH}}$ is a finite alphabet for channel contents, (4) $\Lambda$ is a finite set of transition labels, and (5) $\Delta \subseteq Q \times (\Lambda\cup\{\epsilon\}) \times \textit{Guard}(\mathcal{CH}) \times \textit{Op}(\mathcal{CH}) \times Q$ is a finite set of transitions.


Let $S \subseteq \Sigma$ be a finite set of ``strong symbols'' that must be kept
in each transition (that is, cannot be lost), and $k$ be a positive integer
bounding the numbers of strong symbols in a channel.
For sequences $u,v \in \Sigma_{\mathcal{CH}}^*$, $u \preceq_S^k v$ holds if $u$ is a subword of $v$, $u \uparrow_{S} = v \uparrow_{S}$ and $\vert u \uparrow{S} \vert \leq k$.
This relation can be extended as follows: For every $u,v \in \mathcal{CH} \rightarrow \Sigma_{\mathcal{CH}}^*$, $u \preceq_S^k v$ holds,
if $u(c) \preceq_S^k v(c)$ holds for each $c \in \mathcal{CH}$.


A $\textit{(S,k)-(perfect) channel machine}$ (abbreviated as $\textit{(S,k)-CM}$) is a channel machine $\textit{CM} = (Q,\mathcal{CH},\Sigma_{\mathcal{CH}},\Lambda,\Delta)$ with the strong symbol restriction $(S,k)$. Its semantics is defined as an LTS $(\textit{Conf}_{\textit{CM}}, \Lambda,\rightarrow_{\textit{CM}},\textit{initConf}_{\textit{CM}})$.
A configuration of $\textit{Conf}_{\textit{CM}}$ is a pair $(q,u)$ where $q \in Q$, $u:\mathcal{CH} \rightarrow \Sigma_{\mathcal{CH}}^*$, and it satisfies the strong symbol restriction $(S,k)$, i.e., for each $c$, $\vert u(c) \uparrow{S} \vert \leq k$.
The transition relation $\rightarrow_{\textit{CM}}$ is defined as follows: given $q,q' \in Q$ and $u,u' \in \mathcal{CH} \rightarrow \Sigma_{\mathcal{CH}}^*$,
$(q,u) \overset{\alpha}{\longrightarrow}_{\textit{CM}} (q',u')$,
if there exists $g$ and $op$, such that $(q,\alpha,g,\textit{op},q') \in \Delta$, $u \models g$ and $\llbracket \textit{op} \rrbracket (u,u')$.
Similarly, a $\textit{(S,k)-lossy channel machine}$ (abbreviated as $\textit{(S,k)-LCM}$) is a channel machine $\textit{CM}$ with lossy channels and the strong symbol restriction $(S,k)$.
Its semantics is defined as an LTS $(\textit{Conf}_{\textit{CM}}, \Lambda,\rightarrow_{\textit{(\textit{CM},S,k)}},\textit{initConf}_{\textit{CM}})$.
The transition relation $\rightarrow_{\textit{(\textit{CM},S,k)}}$ is defined as follows:
$(q,u) \overset{\alpha}{\longrightarrow}_{\textit{(\textit{CM},S,k)}} (q',u')$,
if there exists $v,v' \in \mathcal{CH} \rightarrow \Sigma_{\mathcal{CH}}^*$,
such that $v \preceq_S^k u$, $(q,v) \overset{\alpha}{\longrightarrow}_{\textit{CM}} (q',v')$ and $u' \preceq_S^k v'$.
%Let $\rightarrow_M^*$ and $\rightarrow_{\textit{(M,S,K)}}^*$ be the transition closure of $\rightarrow_M$ and $\rightarrow_{\textit{(M,S,K)}}$.


Given a channel machine $\textit{CM}$, we say that $(q_0,u_0) \cdot \alpha_1 \cdot (q_1,u_1) \cdot \ldots \cdot \alpha_w \cdot (q_w,u_w)$ is a finite run of $\textit{CM}$ from $(q,u)$ to $(q',u')$,
if (1) $(q_0,u_0)=(q,u)$, (2) $(q_i,u_i) \overset{ \alpha_{\textit{i+1}} }{\longrightarrow}_{\textit{CM}} (q_{\textit{i+1}},u_{\textit{i+1}})$
for each $i$ and (3) $(q_w,u_w) = (q',u')$.
We say that $l$ is a trace of a finite run $\rho$ if $l = \rho \uparrow_{\Lambda}$.
Given $q,q' \in Q$, let $\textit{T}_{q,q'}^{S,k}(\textit{CM})$ denote the set of traces of all finite runs of a $(S,k)$-$\textit{CM}$ $\textit{CM}$ from the configuration $(q,c_{\textit{init}})$ to the configuration $(q',c_{\textit{init}})$. Here $c_{\textit{init}}$ is a function that maps each channel name to an empty channel $\epsilon$.
For $(S,k)-\textit{LCM}$ $\textit{CM}$, the notations of finite run and its trace are defined as in the non-lossy case by replacing $\rightarrow_{\textit{CM}}$ with $\rightarrow_{(\textit{CM},S,k)}$.
Let $\textit{LT}_{q,q'}^{S,k}(\textit{CM})$ denote the set of traces of all finite runs of $(S,K)\textit{-LCM}$ $\textit{CM}$ from the configuration $(q,c_{\textit{init}})$ to the configuration $(q',c_{\textit{init}})$.

For channel machines $\textit{CM}_1 =
(Q_1,\mathcal{CH}_1,\Sigma_{\mathcal{CH}},\Lambda,\Delta_1 )$ and $\textit{CM}_2 =
(Q_2,\mathcal{CH}_2,\Sigma_{\mathcal{CH}}$, $\Lambda,$ $\Delta_2)$ such that
$\mathcal{CH}_1 \cap \mathcal{CH}_2 = \emptyset$, the product of $\textit{CM}_1$ and $\textit{CM}_2$
is %also
a channel machine $\textit{CM}_1 \otimes \textit{CM}_2 = (Q_1 \times Q_2,\mathcal{CH}_1 \cup
\mathcal{CH}_2,\Sigma_{\mathcal{CH}},\Lambda,\Delta_{12} )$, where $\Delta_{12}$
is defined by synchronizing transitions sharing the same label in $\Lambda$
under the conjunction of their guards, and letting other transitions be
asynchronous. The following lemma holds as in \cite{DBLP:conf/popl/AtigBBM10}.

\begin{lemma}
\label{proposition:relation bewteen LT of M1 and M2 and (LT of M1 and LT of M2)}
Given channel machines $\textit{CM}_1 = (Q_1,\mathcal{CH}_1,\Sigma_{\mathcal{CH}},\Lambda,\Delta_1 )$ and $\textit{CM}_2 = (Q_2,$ $\mathcal{CH}_2,\Sigma_{\mathcal{CH}},\Lambda,\Delta_2 )$, let $q_1,q'_1 \in Q_1$, $q_2,q'_2 \in Q_2$, $q=(q_1,q_2)$, $q'=(q'_1,q'_2)$, then $\textit{LT}_{q,q'}^{S,K}(\textit{CM}_1 \otimes \textit{CM}_2)$ = $\textit{LT}_{q_1,q_1'}^{S,K}(\textit{CM}_1) \cap \textit{LT}_{q_2,q'_2}^{S,K}(\textit{CM}_2)$ and $T_{q,q'}^{S,K}(\textit{CM}_1 \otimes \textit{CM}_2)$ = $T_{q_1,q_1'}^{S,K}(\textit{CM}_1) \cap T_{q_2,q'_2}^{S,K}(\textit{CM}_2)$.
\end{lemma}


Given a $(S,k)\textit{-LCM}$ $\textit{CM}$ and two states $q,q' \in Q$, a control state reachability problem of $\textit{CM}$ is to determine whether $\textit{LT}_{q,q'}^{S,k}(\textit{CM}) \neq \emptyset$. Atig \emph{et al.} \cite{DBLP:conf/popl/AtigBBM10} prove that the control state reachability problem is decidable for $(S,k)\textit{-LCM}$.


%Given a $(S,k)\textit{-CM}$ (respectively, $(S,k)\textit{-LCM}$) $M$ and two states $q,q'\in Q$, a control state reachability problem of $M$ is to determine whether $\textit{T}_{q,q'}^{S,k}(M) \neq \emptyset$ (respectively, $\textit{LT}_{q,q'}^{S,k}(M) \neq \emptyset$). \cite{POPL2010} proves that the control state reachability problem is decidable for $(S,k)\textit{-LCM}$.
}


\subsection{Verification of Obstruction-Freedom}
\label{subsec:equivlant characterization of obstruction-freedom}
\forget{
\subsection{Equivalent Characterization of Obstruction-Freedom}
\label{subsec:equivlant characterization of obstruction-freedom}
}

\forget{
The definition of obstruction-freedom requires checking infinite executions. We propose an equivalent characterization of obstruction-freedom, which checks finite executions instead of infinite executions. This equivalent characterization is based on a notion called blocking pairs, which captures potential obstruction-freedom violations.
}
%It is hard to check obstruction-freedom directly using its definition, since
%each obstruction-freedom violation is of infinite length.
%We propose an equivalent characterization of obstruction-freedom, which
%considers executions of finite length, and is thus easier to check.
% that requires dealing with infinite executions of infinite state systems.
%To deal with that problem, we propose a equivalent characterization of obstruction-freedom, which consider only finite length executions.

\forget{
We propose an equivalent characterization of obstruction-freedom, which
checks finite executions instead of infinite executions, which are required in the definition of obstruction-freedom.
To reduce obstruction-freedom checking to control state reachability checking
for lossy channel machines, we slightly extend the TSO semantics and propose
a second equivalent characterization, also as a finite execution problem. Both
of our equivalent characterizations are based on a notion called blocking pairs,
which capture potential obstruction-freedom violation, and both of them require
detecting blocking pairs, which in turn requires reading a memory valuation and
the buffer contents atomically. This can not be done in the original TSO memory
model.}

The definition of obstruction-freedom requires checking infinite executions,
while the state reachability problem considers finite executions reaching
specific configurations. To bridge this gap, we propose a notion called
blocking pairs, which is defined on concurrent systems on the SC memory model
and captures potential obstruction-freedom violations.
%\redt{The notion of blocking pairs is defined on concurrent systems on SC memory model.}
Let $\llbracket \mathcal{L}, n \rrbracket_{sc}$ be the operational semantics of a concurrent system that runs on the SC memory model and contains $n$ processes.
The configurations of $\llbracket \mathcal{L}, n \rrbracket_{sc}$ coincide with the configurations of $\llbracket \mathcal{L}, n \rrbracket$ that preserve the buffer empty for each process.
When performing a write action $\llbracket \mathcal{L}, n \rrbracket_{sc}$ does
not put the item into the buffer, but directly updates the memory instead. $\llbracket \mathcal{L}, n \rrbracket_{sc}$ does not have flush actions, while other actions are unchanged from $\llbracket \mathcal{L}, n \rrbracket$. Since we use finite program positions, finite memory locations, a finite data domain, finite method names and a finite number of processes, and since we essentially do not use buffers, we observe that $\llbracket \mathcal{L}, n \rrbracket_{sc}$ is a finite state LTS.

\forget{
The notion blocking pair is defined on the operational semantics of the SC
memory model. Let $\llbracket \mathcal{L}, n \rrbracket_{sc}$ be the operational
semantics of a concurrent system that runs on the SC memory model and contains
$n$ processes. The configurations of $\llbracket \mathcal{L}, n \rrbracket_{sc}$
coincide with the configurations of $\llbracket \mathcal{L}, n \rrbracket$ that
preserve the buffer empty for each process. The transition relation of
$\llbracket \mathcal{L}, n \rrbracket_{sc}$ is generated from $\llbracket
\mathcal{L}, n \rrbracket$ by modifying the transition rule of the write action
as shown below, and by removing the transition rule for flush actions, while keeping the transition rules of all other actions unchanged:
\[
  \begin{array}{l c}
    \bigfrac{ p(i)=(q_i,q'_c) \quad q_i\
    {\xrightarrow{\textit{write}(x,a)}}_{\mathcal{L}}\ q'_i} { ( p,d,u)\ {\xrightarrow{\textit{write}(i,x,a)}}\
    ( p[i:(q'_i,q'_c)],d[x:a],u)}
  \end{array}
\]
Since we use finite program positions, finite memory locations, a finite data
domain, finite method names and a finite number of processes, and since we
  essentially do not use buffers, we observe that $\llbracket \mathcal{L}, n
\rrbracket_{sc}$ is a finite state LTS.
%It is easy to give the operational semantics $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$ of concurrent system that runs on SC memory model and contains only one process. In each configuration of $\llbracket \mathcal{L},1 \rrbracket$, the only process must have a empty buffer. Therefore, $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$ is a finite state LTS.
}



Let us now propose the notion of blocking pairs. Given a state $q \in \{\textit{in}_{\textit{clt}}\} \cup (Q_{\mathcal{L}} \times \{\textit{in}_{\textit{lib}}\})$ (recall that $Q_{\mathcal{L}}$ is the set of program positions of library, $\textit{in}_{\textit{clt}}$ and $\textit{in}_{\textit{lib}}$ are the states of the most general client) and a memory valuation $d$,
$(q,d)$ is a blocking pair, if in $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$
there exists a configuration $(p,d,u)$, such that the state of process 1 of $p$ is $q$ ($p(1)=q$), %(recall that $p$ is a function and thus $q \in \{q_c\} \cup (Q_{\mathcal{L}} \times \{q'_c\})$),
and there exists an infinite execution from $(p,d,u)$ and such
execution does not have a return action. This property can be expressed by
the %CTL$^{*}$
%LTL
CTL$^*$ formula $E ( (G\ \neg P_{\textit{ret}}) \wedge (G\ X\ P_{\textit{any}})
)$, where $E$ is the usual modality of CTL$^*$,
%\redt{where $E$ is the path quantifier of ``for some computation paths'' of CTL$^*$,}
$P_{\textit{ret}}$ is a predicate that checks if the transition label is a
return action, %(defined in Section \ref{sec:liveness}),
and $P_{\textit{any}}$ returns
true %if the transition label is not empty.
{for any transition label.}
The following lemma reduces checking obstruction-freedom into the state reachability problem.

\forget{
{\color {blue}Given a library $\mathcal{L}$, we generate a library
  $\mathcal{L}_{in}$ as follows: Intuitively, $\mathcal{L}_{in}$ extends
  $\mathcal{L}$ by nondeterministically doing a $\textit{cas}(x,0,0)$ action
  between any two actions of $\mathcal{L}$. Formally, if $q_1
  {\xrightarrow{\alpha}} q_2$ is a transition of $\mathcal{L}$, then
  $\mathcal{L}_{in}$ adds state $q_{(1,2)}$ and transitions $q_1
  {\xrightarrow{\textit{cas}(x,0,0)}} q_{(1,2)}$ and $q_{(1,2)}
  {\xrightarrow{\alpha}} q_2$. We call the newly added states (e.g.,
  $q_{(1,2)}$) intermediate states. We can see that $\mathcal{L}_{in}$
  essentially has the ``same behavior'' as $\mathcal{L}$, since
  $\textit{cas}(x,0,0)$ does not change the memory valuation. The
  $\textit{cas}(x,0,0)$ transition of $\mathcal{L}_{in}$ can be understand as
  $\mathcal{L}$ doing several flush actions.}
  }



\forget{
  The following lemma provides an equivalent characterization of
  obstruction-freedom as a reachability problem of configurations that contain
  blocking pairs. Refer to Appendix \ref{subsec:appendix proof of lemma lemma:equivalent characterization of obstruction-freedom} %\ref{sec:appendix proof of section sec:checking obstruction-freedom}
  for the proof.
}

\forget{
%We say that $(p,d)$ is a blocking pair, if in $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$, the configuration $(p,d,\epsilon^n)$ satisfies the LTL formula $E (G \neg \textit{isRet} \wedge G X \textit{true})$, where $\textit{isRet}$ is a predicate that checks if the transition label is a return action. By model checking techniques it is obvious that the set of blocking pairs are computable.
The following lemma provides an equivalent characterization of obstruction-freedom as a reachability problem of configurations that contain a blocking pair. Given a configuration $(p,d,u)$ and a process $proc$, let $d[u(proc)]$ be a memory valuation obtained from $d$ by using the buffered writes of $u(proc)$ to update $d$ one by one.
}

\begin{lemma}
\label{lemma:equivalent characterization of obstruction-freedom}
Given a library $\mathcal{L}$, there exists an infinite execution $t$ of $\llbracket \mathcal{L}, n \rrbracket$ that violates obstruction-freedom on TSO, if and only if there exists an finite execution $t'$ of $\llbracket \mathcal{L},n \rrbracket$ and a process $proc$, such that $t'$ leads to a
configuration $(p,d,u_{\textit{init}})$, where $(p(proc),d)$ is a blocking pair.
\end{lemma}

\forget{
The detailed proof can be found in Appendix \ref{subsec:appendix proof of
  lemma lemma:equivalent characterization of obstruction-freedom}. The
\emph{if} direction holds since we can obtain an obstruction-freedom violation
$t' \cdot t_1$, in which $t_1$ is the specific infinite execution in the
definition of blocking pairs. For the \emph{only if} direction, there exists
$t_1$, $t_2$ and process $proc$, such that $t=t_1 \cdot t_2$, and $t_2$
contains only actions of process $proc$. Let $\alpha_i$ be the last write
action of process $i \neq proc$ in $t_1$ that has not been flushed. Dropping
$\alpha_i$ in $t$ yields a legal execution, since $\alpha_i$ does not
influence the memory. Also, it is legal to clear buffer of process $proc$
before executing $t_2$. With the approach above, we can generate an new
execution that reaches a configuration, which has an empty buffer for each
process and contains a blocking pair, before the execution of $t_2$.
}



\begin {proof}(Sketch)
To prove the \emph{if} direction, consider the infinite executions which first act as $t'$, and then always run process $proc$ and disallowing other processes to do actions. The behaviors after $t'$ of these executions behave as the executions of $\llbracket \mathcal{L},1 \rrbracket_{sc}$ from the configuration  $(p',d,u_{\textit{init}})$, where $p'$ is a function that maps process $1$ to $p(proc)$. According to the definition of blocking pairs, there exists one such execution $t$ that violates obstruction-freedom.

The \emph{only if} direction is proved as follows: There exists $t_1$, $t_2$ and process $proc$, such that $t=t_1 \cdot t_2$, and $t_2$ contains only actions of process $proc$. Given process $i$, let $\alpha_i$ be the last write action of process $i$ in $t_1$ that has not been flushed. Let $t'_1$ be obtained from $t_1$ by removing the last non-flush action $\alpha$ of process $i$ after $\alpha_i$ for some process $i \neq proc$. $\alpha$ can not influence other process since it can not influence memory. Since the only possible actions of process $i$ after $\alpha$ is flush, the subsequent actions of process $i$ is not influenced. Therefore, $t'_1 \cdot t_2$ is an execution of $\llbracket \mathcal{L}, n \rrbracket$. By repeatedly apply above approach we obtain $t_3$ from $t_1$, such that $t_3 \cdot t_2$ violates obstruction-freedom, and for each process $i \neq proc$, all write of process $i$ has been flushed in $t_3$. Since process $proc$ runs as on SC in $t_2$ and read actions first try to read from buffer, we can see that $t_3 \cdot t_4 \cdot t_2$ is an execution of $\llbracket \mathcal{L}, n \rrbracket$, where $t_4$ flushes all the remaining items of process $proc$ in $t_1$. The configuration reached by execution $t_3 \cdot t_4$ has buffer empty for each process, and we can see that the control state and memory valuation is a blocking pair according to its definition. This completes the proof of this lemma.
\end {proof}




\forget{
\begin{lemma}
\label{lemma:equivalent characterization of obstruction-freedom}
Given a library $\mathcal{L}$, there exists an infinite execution $t$ of $\llbracket \mathcal{L}, n \rrbracket$ that violates obstruction-freedom, if and only if there exists an finite execution $t'$ of $\llbracket
%\mathcal{L}_{in},
\mathcal{L},n \rrbracket$ and a process $proc$, such that $t'$ leads to a
configuration $(p,d,u)$, where $u(proc)=\epsilon$, and $(p(proc),d)$ is a blocking pair. %Here $d[u(pro)]$ is a memory valuation obtained from $d$ by using the buffered write of $u(pro)$ to update $d$ one by one.
\end{lemma}
}
\forget{
\begin {proof}
  Let us prove the \emph{only if} direction first. Since $t$ violates
  obstruction-freedom, there exists a process $proc$ and a time $i_1$, such that
  from $i_1$ onward only the process $proc$ can launch actions on $t$. Since
  there is a finite number of write actions of $t$ from its beginning to time
  $i_1$, there exists a time $i_2$, such that after $i_2$, only the process
  $proc$ can do flush actions. Let time $i_3$ be the point of the last call
  action of process $proc$, and let $i_4 = \textit{max}(i_1,i_2,i_3)$. It is
  easy to see that from time $i_4$, process $proc$ is not influenced by any
  other processes, and the behavior of process $proc$ from then on is as on SC.
  Let us generate another execution $t_1$ as follows: $t_1$ works
  as $t$ until time $i_4$, then $t_1$ clears the store buffer of process $proc$
  (let $(p_5,d_5,u_5)$ be the configuration at this time point), and works as
  the behavior of $t$ after time $i_4$. It is easy to see that $t_1$ is also
  an execution of $\llbracket \mathcal{L}, n \rrbracket$. Since process $proc$
  is scheduled infinitely many times and does not return, and
  $d_5(proc)=\epsilon$, we can see that $(p_5(proc),d_5)$ is a blocking pair.

%Let $(p_4,d_4,u_4)$ be the configuration of time $t_4$. It is easy to see that from time $t_4$, process $proc$ is not influenced by any other process, and the behavior of process $proc$ from then on is as on SC. {\color {red}Let $d_4[u_4(pro)]$ be a memory valuation obtained from $d_4$ by using the buffered write of $u_4(pro)$ to update $d_4$ one by one. We can see that in $\llbracket \mathcal{L},1 \rrbracket_{sc}$, from $(p_4(proc),d_4[u_4(proc)],u_{\textit{init}})$, we can do the remaining transitions of $t$ from time point $t_4$. Therefore, $(p_4(proc),d_4[u_4(proc)])$ is a blocking pair.}

\forget{Let us generate an execution $t'$ as follows: $t'$ first does $t$ transitions
    from the initial configuration to $(p_4,d_4,u_4)$.
    Then, $t'$ flushes all buffered items in process $proc$'s buffer and then the
    process $proc$ goes to a intermediate state. Assume that $t'$ reaches a
    configuration $(p,d,u)$, with $p(proc)$ some intermediate state $q_{(u,v)}$.
    Finally, $t'$ does the remaining transitions of $t$. Since $t'$ also
    violates obstruction-freedom, and $t$'s behavior is as in SC after time
    $t_4$, we can see that $(q_v,d)$ is a blocking pair.}
%If $p_4(pro)$ is a intermediate state, then let $(p'_4,d'_4,u'_4)=(p_4,d_4,u_4)$. Otherwise, let $(p'_4,d'_4,u'_4)$ be obtained from $(p_4,d_4,u_4)$ by first doing several flush of process $pro$ and then let process $pro$ transit to intermediate state. The buffer of process $pro$ is empty in $(p'_4,d'_4,u'_4)$. Assume that $p'_4(pro)=(q_{(j,k)},q'_c)$.
%It is easy to see that in $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$, we could generate transitions from $(\{(P_1:(q_k,q'_c))\},d'_4,\epsilon)$ that do the $t$ transitions after $(p_4,d_4,u_4)$ (except for the flush actions and into intermediate state transition). Since $t$ is a obstruction-freedom violation, we can see that $(q_k,d'_4)$ is a blocking pair.

%Let $d_4[u_4(pro)]$ represents a memory valuation obtained from $d_4$ by using the buffered write of $u_4(pro)$ to update $d_4$ one by one. It is easy to see that

%Then, it is easy to see that, after time point $t_3$, process $pro$ runs as in SC memory model (while the memory valuation is obtained from memory valuation of the system and buffered write of process $pro$).

%Let time point $t_4$ be the time point of the last call action of process $pro$, and let $t_5 = \textit{max}(t_3,t_4)$. Let $(p_5,d_5,u_5)$ be the configuration of time point $t_5$. Since $t$ is a obstruction-freedom violation, $t$ has no return action from $(p_5,d_5,u_5)$.
%The execution of $t$ from time point $t_5$ is the same as the execution from $(p_5, d_5[u_5(pro)], \epsilon)$ in $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$. Therefore, $(p_5(pro), d_5[u_5(pro)])$ is a blocking pair.


%and let $(p_5,d_5,u_5)$ be the configuration of time point $t_5$. Since $t$ is a obstruction-freedom violation, $t$ contains finite number of return actions, and thus, from time point $t_5$, no method of $t$ returns. Since from time point $t_5$, $t$ runs as in SC memory model, only process $pro$ can run, and ``the memory valuation used at time point $t_5$'' is $d_5[u_5(pro)]$, we can see that $(p_5(pro),d_5[u_5(pro)])$ is a blocking pair.

%\gpnote{What is $i$ here? Should it be $t_1$?}
  To prove the \emph{if} direction, %given an execution $t'$, a process $proc$ and integer $i$ as above
  % exists. %from time $i$, we can generate another execution $t''$
  we generate an execution $t$ by first doing $t'$ transitions from the initial configuration to %time $i$,
  $(p,d,u)$ and then continuing to run process $proc$, and disallowing other processes to do actions (including flush actions). %and flush each buffered item as soon as it is inserted into buffer.
% {\color {blue}It is easy to see that from time point $i$, process $pro$ runs
% as in SC memory model (while the memory valuation is obtained from memory
% valuation of the system and buffered write of process $pro$).}
%Executions obtained by such manner will run as in SC memory model.
It is easy to see %this kind of executions behaves as on SC.
that such executions of $t$ from %time $i$
$(p,d,u)$ behaves as the executions of $\llbracket \mathcal{L},1 \rrbracket_{sc}$ from the configuration %$(p',d[u(proc)],u_{\textit{init}})$,
$(p',d,u_{\textit{init}})$, where $p'$ is a function that maps process $1$ to $p(proc)$.
Moreover, we require the execution of $t$ from %time $i$
$(p,d,u)$ to satisfy $(G\ \neg P_{\textit{ret}})
\wedge (G\ X\ P_{\textit{any}})$. This %is feasible
holds since %$(p(proc),d[u(proc)])$
$(p(proc),d)$ is a blocking
pair. Thus, we can see that $t$ has infinite length and does not contain
any return action after %its $i$-th transition,
it reaches configuration $(p,d,u)$, which implies that $t$ violates
obstruction-freedom. \qed
\end {proof}
}


\forget{
\begin{lemma}
\label{lemma:equivalent characterization of obstruction-freedom}
Given a library $\mathcal{L}$, there exists an infinite execution $t$ of
$\llbracket \mathcal{L}, n \rrbracket$ that violates obstruction-freedom, if and
only if there exists an infinite execution $t'$ of $\llbracket
%\mathcal{L}_{in},
\mathcal{L},n \rrbracket$, a process $proc$ and an integer $i$, such that
the $i$-th transition of $t'$ leads to a configuration $(p,d,u)$, such
that %$p(pro)=(q_{(u,v)},q'_c)$ is a intermediate state, and
% $(p(pro),d[u(pro)])$
%$(p(pro),d[u(pro)])$
%$(q_v,d)$
$(p(proc),d[u(proc)])$ is a blocking pair. %Here $d[u(pro)]$ is a memory valuation obtained from $d$ by using the buffered write of $u(pro)$ to update $d$ one by one.
\end{lemma}
\begin {proof}
  Let us prove the only if direction. Since $t$ violates
    obstruction-freedom, there exists a process $proc$ and a time $t_1$, such that
    from $t_1$ only the process $proc$ can launch actions on $t$.
    Since there is a finite number of write actions of $t$ from its beginning to
    time $t_1$, there exists a time $t_2$, such that after $t_2$, only the
    process $proc$ can do flush actions.
    Let time $t_3$ be the point of the last call action of process
    $proc$, and let $t_4 = \textit{max}(t_1,t_2,t_3)$.
    Let $(p_4,d_4,u_4)$ be the configuration of time $t_4$.
    {It is easy to see that from time $t_4$, process $proc$ is not
      influenced by any other process, and the behavior of process $proc$ from then on is as on SC.}
    Therefore, in $\llbracket \mathcal{L},1 \rrbracket_{sc}$, from $(p_4(proc),d_4[u_4(proc)],u_{\textit{init}})$, we can do the remaining transitions of $t$ from time point $t_4$. We can see that $t'=t$, $i=t_4$, and $(p_4(proc),d_4[u_4(proc)])$ is a blocking pair.

    \forget{Let us generate an execution $t'$ as follows: $t'$ first does $t$ transitions
    from the initial configuration to $(p_4,d_4,u_4)$.
    Then, $t'$ flushes all buffered items in process $proc$'s buffer and then the
    process $proc$ goes to a intermediate state. Assume that $t'$ reaches a
    configuration $(p,d,u)$, with $p(proc)$ some intermediate state $q_{(u,v)}$.
    Finally, $t'$ does the remaining transitions of $t$. Since $t'$ also
    violates obstruction-freedom, and $t$'s behavior is as in SC after time
    $t_4$, we can see that $(q_v,d)$ is a blocking pair.}
%If $p_4(pro)$ is a intermediate state, then let $(p'_4,d'_4,u'_4)=(p_4,d_4,u_4)$. Otherwise, let $(p'_4,d'_4,u'_4)$ be obtained from $(p_4,d_4,u_4)$ by first doing several flush of process $pro$ and then let process $pro$ transit to intermediate state. The buffer of process $pro$ is empty in $(p'_4,d'_4,u'_4)$. Assume that $p'_4(pro)=(q_{(j,k)},q'_c)$.
%It is easy to see that in $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$, we could generate transitions from $(\{(P_1:(q_k,q'_c))\},d'_4,\epsilon)$ that do the $t$ transitions after $(p_4,d_4,u_4)$ (except for the flush actions and into intermediate state transition). Since $t$ is a obstruction-freedom violation, we can see that $(q_k,d'_4)$ is a blocking pair.

%Let $d_4[u_4(pro)]$ represents a memory valuation obtained from $d_4$ by using the buffered write of $u_4(pro)$ to update $d_4$ one by one. It is easy to see that

%Then, it is easy to see that, after time point $t_3$, process $pro$ runs as in SC memory model (while the memory valuation is obtained from memory valuation of the system and buffered write of process $pro$).

%Let time point $t_4$ be the time point of the last call action of process $pro$, and let $t_5 = \textit{max}(t_3,t_4)$. Let $(p_5,d_5,u_5)$ be the configuration of time point $t_5$. Since $t$ is a obstruction-freedom violation, $t$ has no return action from $(p_5,d_5,u_5)$.
%The execution of $t$ from time point $t_5$ is the same as the execution from $(p_5, d_5[u_5(pro)], \epsilon)$ in $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$. Therefore, $(p_5(pro), d_5[u_5(pro)])$ is a blocking pair.


%and let $(p_5,d_5,u_5)$ be the configuration of time point $t_5$. Since $t$ is a obstruction-freedom violation, $t$ contains finite number of return actions, and thus, from time point $t_5$, no method of $t$ returns. Since from time point $t_5$, $t$ runs as in SC memory model, only process $pro$ can run, and ``the memory valuation used at time point $t_5$'' is $d_5[u_5(pro)]$, we can see that $(p_5(pro),d_5[u_5(pro)])$ is a blocking pair.

%\gpnote{What is $i$ here? Should it be $t_1$?}
To prove the if direction, given an execution $t'$, a process $proc$ and integer $i$ as above
exists. %from time $i$, we can generate another execution $t''$
We generate an execution $t$ by first doing $t'$ transitions from the initial configuration to time $i$, and then continuing to run process $proc$, and disallowing other processes to do actions
or flush. %and flush each buffered item as soon as it is inserted into buffer.
% {\color {blue}It is easy to see that from time point $i$, process $pro$ runs
% as in SC memory model (while the memory valuation is obtained from memory
% valuation of the system and buffered write of process $pro$).}
%Executions obtained by such manner will run as in SC memory model.
It is easy to see %this kind of executions behaves as on SC.
that such executions of $t$ from time $i$ behave as the executions of $\llbracket \mathcal{L},1 \rrbracket_{sc}$ from the configuration $(p',d[u(proc)],u_{\textit{init}})$, where $p'$ is a function that maps process $1$ to $p(proc)$.
Moreover, we require the execution of $t$ from time $i$ to satisfy $G \neg P_{\textit{ret}}
\wedge G X P_{\textit{any}}$. This is feasible since $(p(proc),d[u(proc)])$ is a blocking
pair. Thus, we can see that $t$ has infinite length and does not contain
any return action after its $i$-th transition, which implies that $t$ violates
obstruction-freedom. \qed
\end {proof}
}

\forget{
\begin {proof}
To prove the only if direction, since $t$ violates obstruction-freedom, there exists process $pro$ and time point $t_1$, such that from time point $t_1$, only process $pro$ can launch active on $t$. Since the total number of write actions of non-$pro$ process is finite, there exists a time point $t_2$, such that after time point $t_2$, only process $pro$ can do flush operation and all non-$pro$ process can not do flush operation. Let $t_3 = \textit{max}(t_1,t_2)$. Then, after time point $t_3$, we can see that in the concurrent system, only one process $pro$ can run while all other process can not either do action nor do flush. It is easy to see that, in this situation, process $pro$ runs as in SC memory model. Let time point $t_4$ be the time point of the last call action of process $pro$, let $t_5 = \textit{max}(t_3,t_4)$. Let $(p_5,d_5,u_5)$ be the configuration of time point $t_5$. Since $t$ is a obstruction-freedom violation, we can see that from time point $t_5$, (1) only process $pro$ can run, and its behavior is as one process run in SC memory model from control state $p_5(pro)$ and memory valuation $d_5[u_5(pro)]$, (2) there is infinite number of actions but no return actions. Here $d_5[u_5(pro)]$ represents a memory valuation obtained from $d_5$ by using the buffered write of $u_5(pro)$ to update $d_5$ one by one. Therefore, we can see that $(p_5(pro), d_5[u_5(pro)])$ is a blocking pair. We could generate another execution $t'$ from $t$, and the behavior of $t'$ is as follows: $t'$ first do behavior of $t$ till time point $t_5$, then $t'$ flush all buffered write of process $pro$, and then $t'$ do behavior of $t$ after time point $t_5$. It is easy to see that $t'$ belongs to $\llbracket \mathcal{L}, n \rrbracket$, and it reaches a configuration $(p_5,d_5[u_5(pro)],u_5[pro:\epsilon])$ with $(p_5(pro), d_5[u_5(pro)])$ being a blocking pair.


%and let $(p_5,d_5,u_5)$ be the configuration of time point $t_5$. Since $t$ is a obstruction-freedom violation, $t$ contains finite number of return actions, and thus, from time point $t_5$, no method of $t$ returns. Since from time point $t_5$, $t$ runs as in SC memory model, only process $pro$ can run, and ``the memory valuation used at time point $t_5$'' is $d_5[u_5(pro)]$, we can see that $(p_5(pro),d_5[u_5(pro)])$ is a blocking pair.

To prove the if direction, assume that such process $pro$ and integer $i$ exists. Then, from time point $i$, we can generate another execution $t'$ by continuing run process $pro$ and do not let other processes to do action or do flush. Executions obtained by such manner will run as in SC memory model. Moreover, we require the execution $t'$ to satisfy $E (G \neg \textit{isRet} \wedge G X \textit{true})$. This is feasible since $(p(pro),d[u(pro)])$ is a blocking pair. Therefore, we can see that $t'$ has infinite length and does not contain any return action after its $i$-th transition, which implies that $t'$ violates obstruction-freedom. \qed
\end {proof}
}

\forget{
Given a library $\mathcal{L}$, let $\llbracket \mathcal{L}, n \rrbracket_{of}$ be an LTS that extends $\llbracket \mathcal{L}, n \rrbracket$ by remembering if a configuration that contains a blocking pair has already been reached. Each configuration of $\llbracket \mathcal{L}, n \rrbracket_{of}$ is a tuple $(p,d,u,bpflag)$ where $(p,d,u)$ is a configuration of $\llbracket \mathcal{L}, n \rrbracket$ and $bpflag \in \{ 0,1 \}$ records if the execution already reach a configuration that contains a blocking pair. The transition rule of $\llbracket \mathcal{L}, n \rrbracket_{of}$ is generated from that of $\llbracket \mathcal{L}, n \rrbracket$ as follows: Let $\rightarrow_{of}$ be the transition relation of $\llbracket \mathcal{L}, n \rrbracket_{of}$ and $\rightarrow$ be the transition relation of $\llbracket \mathcal{L}, n \rrbracket$: If $(p,d,u) {\xrightarrow{ \alpha }} (p',d',u)$, then we have $(p,d,u,bpflag) {\xrightarrow{ \alpha }}_{of}$ $(p',d',u',bpflag')$. $bpflag'$ is obtained as follows: if $bpflag$ is $0$ and  %$p'(pro)=q_{(u,v)}$ and $(q_v,d')$
$(p'(proc),d'[u'(proc)])$ is a blocking pair for some process $proc$, %$q_u$ and $q_v$,
then $bpflag'$ is set to $1$; Otherwise, $bpflag'$ equals $bpflag$.
The initial configuration of $\llbracket \mathcal{L}, n \rrbracket_{of}$ is
$(p_{\textit{init}}, d_{\textit{init}}, u_{\textit{init}},0)$.
}

%\begin{itemize}
%\item[-] For $\tau$, read, write, $\textit{cas-fail}$, call and return actions, we have $(p,d,u,bflag) {\xrightarrow{ \alpha }}_o (p',d'$, $u',bflag)$, if we have $(p,d,u) {\xrightarrow{ \alpha }} (p',d',u)$.

%\item[-] For flush and $\textit{cas-suc}$ actions, if $(p,d,u) {\xrightarrow{ \alpha }} (p',d',u)$, then we have $(p,d,u,bflag) {\xrightarrow{ \alpha }}_o$ $(p',d',u',bflag')$. Here if $bflag=0$ and $(p'(pro),d'[u'(pro)])$ is a blocking pair for some process $pro$, then $bflag'=1$; Otherwise, $bflag'=bflag$.
%\end{itemize}

\forget{
Lemma \ref{lemma:equivalent characterization of obstruction-freedom} reduces checking obstruction-freedom into checking if any configuration contains a blocking pair.
Given a finite execution $t$ of $\llbracket \mathcal{L}, n \rrbracket_{of}$ from
the initial configuration to a configuration $(p,d,u,bpflag)$, some intermediate
configuration of $t$ contains a blocking pair,
if and only if $bpflag=1$. This implies the following lemma, which reduces
checking obstruction-freedom into the finite trace reachability problem for
$\llbracket \mathcal{L}, n \rrbracket_{of}$.
}

\forget{
We can see that
given an finite execution $t$ of $\llbracket \mathcal{L}, n
\rrbracket_{of}$ from the initial configuration to a configuration
$(p,d,u,$ $bpflag)$, some intermediate configuration of $t$ contains blocking pair,
if and only if $bpflag=1$. This implies the following lemma, which reduces
checking obstruction-freedom into the finite trace reachability problem for
$\llbracket \mathcal{L}, n \rrbracket_{of}$.
}

\forget{
\begin{lemma}
\label{lemma:reducing obstruction free to a reachability problem of ObsSem(L,n)}
Given a library $\mathcal{L}$, there exists an infinite execution of $\llbracket \mathcal{L}, n \rrbracket$ that violates obstruction-freedom, if and only if there is a finite trace of $\llbracket \mathcal{L}, n \rrbracket_{of}$ that reaches a configuration $(p,d,u_{\textit{init}},1)$ for some $p$ and $d$.
\end{lemma}
\begin {proof}
  % Directly consequence of %Lemma \ref{lemma:equivalent characterization of obstruction-freedom} and the construction of $\llbracket \mathcal{L}, n \rrbracket_{of}$.
  By Lemma \ref{lemma:equivalent characterization of obstruction-freedom} and the construction of $\llbracket \mathcal{L},n \rrbracket_{of}$, we reduce obstruction-freedom into reachability of $(p,d',u,1)$ in $\llbracket \mathcal{L},n \rrbracket_{of}$. Since flushing items does not influence $bpflag$, we further reduce it into reachability of $(p,d,u_{\textit{init}},1)$ in $\llbracket \mathcal{L},n \rrbracket_{of}$. \qed
\end {proof}
}



\forget{
\subsection{Construction of \redt{$\textit{CM}_i$}}
\label{lemma:channel Machines Mi}

%Let us new use the channel machine to simulate a single process of $\llbracket \mathcal{L}, n \rrbracket_{of}$.
We now construct a channel machine \redt{$\textit{CM}_i$} to simulate process $i$ of $\llbracket \mathcal{L}, n \rrbracket_{of}$. %is a channel machine that is used to simulate process $i$ on TSO.
Its construction is similar to the channel machines of Atig \emph{et al.} \cite{DBLP:conf/popl/AtigBBM10} and our previous work \cite{DBLP:conf/sofsem/WangLW16}.
Our work extends the channel machines of \cite{DBLP:conf/popl/AtigBBM10} and
\cite{DBLP:conf/sofsem/WangLW16} by allowing to read %the control state,
a memory valuation updated by process $i$'s buffer content atomically to detect blocking pairs.
In \redt{$\textit{CM}_i$}, call and return actions are treated as $\epsilon$ transitions.
%\redt{In the next subsection, we use $M_i$ to solve the equivalent characterization of obstruction-freedom of Lemma \ref{lemma:reducing obstruction free to a reachability problem of ObsSem(L,n)}.}
%With this extension, we are able to use $M_i$ to solve the equivalent characterization of obstruction-freedom of Lemma %\ref{lemma:equivalent characterization of obstruction-freedom}.
%\ref{lemma:reducing obstruction free to a reachability problem of ObsSem(L,n)}.

Let $\textit{Val}$ be the set of memory valuations, and each memory valuation is a function that maps a memory location in $\mathcal{X}_{\mathcal{L}}$ to a value in $\mathcal{D}_{\mathcal{L}}$. The $(S,k)$-channel machine \redt{$\textit{CM}_i$} ($1 \leq i \leq n$) is a tuple $(Q_i,\{c_i\}, \Sigma, \Lambda,\Delta_i)$, where $c_i$ is name of the single channel of \redt{$\textit{CM}_i$}. $Q_i$, $c_i$, $\Sigma$, $\Lambda$ and $\Delta_i$ are defined as follows: Let $Q_{\mathcal{L}}$ be the set of program positions of $\mathcal{L}$ and $\rightarrow_{\mathcal{L}}$ be the transition relation of $\mathcal{L}$,
$Q_i=( \{q_c\} \cup (Q_{\mathcal{L}} \times \{q'_c\}) ) \times \textit{Val} \times \textit{Val} \times \textit{Val} \times \{ 0,1 \}$ is the state set.
A state $(q,d_c,d_g,d_b,bpflag)\in Q_i$ consists of a control state $q$,
a valuation $d_c$ of the current memory, a valuation $d_g$ of the memory with
all the stored items in $c_i$ applied, a valuation $d_b$ of the memory with
all the stored items of process $i$ in $c_i$ applied, and a flag $bpflag$ that is used to
detect if the current execution %of process $i$
has already reached a
configuration that contains a blocking pair of process $i$. %, and a $tflag$ that is used to detect if the channel contains no strong symbols. Note that we can set $tflag$ at a random time, and when it is set, the execution is terminated.

$\Sigma=\Sigma_1 \cup \Sigma_2$ is the alphabet of channel contents with
$\Sigma_1=\{ (i,x,d) \vert 1 \! \leq \! i \! \leq \! n, x \in
\mathcal{X}_{\mathcal{L}}, d \in \textit{Val} \}$ and $\Sigma_2 = \{ (a,\sharp)
\vert a \in \Sigma_1 \}$. $\Sigma_1$ represents a buffered write and it stores the whole memory valuation. $\Sigma_2$ is used to represent the newest write of a variable. In case that \redt{$\textit{CM}_i$} is interpreted with a lossy channel, $\Sigma_2$ are the sets of strong symbols of \redt{$\textit{CM}_i$} and the number of strong symbols is less or equal to the size of $\mathcal{X}_{\mathcal{L}}$.
$\Lambda$ is the set of transition labels and is the union of $\{ \epsilon \}$ and $\{ \textit{write}(i,x,d), \textit{flush}(i,x,d)$, $\textit{cas}(i,x,d,d')  \vert 1 \leq i \leq n, x \in \mathcal{X}_{\mathcal{L}}, d,d' \in %\textit{Val}
\mathcal{D}_{\mathcal{L}} \}$. $\Lambda$ does not contain $\tau$, read, call or return transitions, which are seen as $\epsilon$ transition in \redt{$\textit{CM}_i$}.
$\Delta_i$ is the transition relation of \redt{$\textit{CM}_i$}, and it is the smallest set of transitions such that for each $q \in \{q_c\} \cup (Q_{\mathcal{L}} \times \{q'_c \}$, $q_1,q_2 \in Q_{\mathcal{L}}$ and $d_c,d_g,d_b \in \textit{Val}$,

\begin{itemize}[leftmargin=*]
\item[-] Nop: if $q_1 {\xrightarrow{ \tau }}_{\mathcal{L}} q_2$, then

$((q_1,q'_c),d_c,d_g,d_b,bpflag)
{\xrightarrow{ \epsilon, c_i:\Sigma,\textit{nop} }}_{\Delta_i}
((q_2,q'_c),d_c,d_g,d_b,bpflag')$

%If $q_2$ is the intermediate state for some $q_u$ and $q_v$, $(q_v,d_c)$ is a blocking pair, and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$. %The other cases of change from $bpflag$ to $bpflag'$ are similar and is omitted here.
In the destination state, if the pair of the first or fourth tuples is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$. %The other cases of change from $bpflag$ to $bpflag'$ in other transition rules are the same and is omitted here.
The other transition rules use the same approach to modify $bpflag$ and we omit such approach when showing other transition rules.

\item[-] Library write: if $q_1 {\xrightarrow{ \textit{write}(x,a) }}_{\mathcal{L}} q_2$, then for each $d \in \textit{Val}$

\vspace{-12pt}
$$((q_1,q'_c),d_c,d_g,d_b,bpflag)
{\xrightarrow{ \textit{op}, (\alpha,\sharp) \in c_i, c_i[\alpha / (\alpha,\sharp)]!\alpha' }}_{\Delta_i}
((q_2,q'_c),d_c,d'_g,d'_b,bpflag')$$
$$((q_1,q'_c),d_c,d_g,d_b,bpflag)
{\xrightarrow{ \textit{op}, c_i:\Theta,c_i!\alpha' }}_{\Delta_i}
((q_2,q'_c),d_c,d'_g,d'_b,bpflag')$$

where $\alpha=(i,x,d)$, $d'_g = d_g[x:a]$, $d'_b=d_b[x:a]$, $\alpha' = ((i,x,d'_g),\sharp)$, $\Theta = \Sigma \backslash \{ ((i,x,d'),\sharp) \vert d' \in \textit{Val}\}$ and $\textit{op} = \textit{write}(i,x,a)$. %If $((q_2,q'_c),d_c)$ is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.
%If $q_2$ is the intermediate state for some $q_u$ and $q_v$, $(q_v,d_c)$ is a blocking pair, and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.

\item[-] Guess write: if $1 \leq j \leq n$, $j \neq i$ and $x \in \mathcal{X}_{\mathcal{L}}$, then
$$(q,d_c,d_g,d_b,bpflag)
{\xrightarrow{ \textit{op}, c_i: \Sigma,c_i!\alpha }}_{\Delta_i}
(q,d_c,d'_g,d_b,bpflag')$$
where $d'_g=d_g[x:a]$, $\alpha = (j,x,d'_g)$ and  $\textit{op} = \textit{write}(j,x,a)$.

\item[-] Flush: for each $1 \leq j \leq n$ and $x \in \mathcal{D}_{\mathcal{L}}$,
$$(q,d_c,d_g,d_b,bpflag)
{\xrightarrow{ \textit{op}, c_i:\Sigma, c_i?(j,x,d) }}_{\Delta_i}
(q,d,d_g,d_b,bpflag')$$
$$(q,d_c,d_g,d_b,bpflag)
{\xrightarrow{ \textit{op}, c_i:\Sigma, c_i?((j,x,d),\sharp) }}_{\Delta_i}
(q,d,d_g,d_b,bpflag')$$
where $\textit{op}=\textit{flush}(j,x,d(x))$. %If $(q,d)$ is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.
%If $q=(q_2,q'_c)$, $q_2$ is the intermediate state for some $q_u$ and $q_v$, $(q_v,d)$ is a blocking pair, and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.

%$$(q,d_c,d_g,bflag)
%{\xrightarrow{ \textit{op}, c_i:\Sigma, c_i?(j,x,d) }}_{\Delta_i}
%(q,d'_c,d_g,bflag')$$
%$$(q,d_c,d_g,bflag)
%{\xrightarrow{ \textit{op}, c_i:\Sigma, c_i?((j,x,d),\sharp) }}_{\Delta_i}
%(q,d'_c,d_g,bflag')$$
%where $d'_c = d_c[x:d(x)]$ and $\textit{op}=\textit{flush}(j,x,d(x))$. If $(q,d'_c)$ is a blocking pair and $bflag=0$, then $bflag'=1$; Otherwise, $bflag'=bflag$.

\item[-] Library read: if $q_1 {\xrightarrow{ \textit{read}(x,a) }}_{\mathcal{L}} q_2$, then for each $d \in \textit{Val}$ with $d(x)=a$,
$$((q_1,q'_c),d_c,d_g,d_b,bpflag)
{\xrightarrow{ \epsilon, (\beta,\sharp) \in c_i,\textit{nop} }}_{\Delta_i}
((q_2,q'_c),d_c,d_g,d_b,bpflag')$$
$$((q_1,q'_c),d,d_g,d_b,bpflag)
{\xrightarrow{ \epsilon, c_i:\Theta,\textit{nop} }}_{\Delta_i}
((q_2,q'_c),d,d_g,d_b,bpflag')$$
where $\beta=(i,x,d)$ and $\Theta=\Sigma \backslash \{ ((i,x,d'),\sharp) \vert d' \in \textit{Val} \}$. %If $((q_2,q'_c),d_c)$ of the first case (resp., $((q_2,q'_c),d)$ of the second case) is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.
%If $q_2$ is the intermediate state for some $q_u$ and $q_v$, $(q_v,d_c)$ of the first case (resp., $(q_v,d)$ of the second case) is a blocking pair, and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.

\item[-] Library $\textit{cas}$: if $q_1 {\xrightarrow{ \textit{cas}\_\textit{suc}(x,a,b) }}_{\mathcal{L}} q_2$ , then for each $d \in \textit{Val}$ with $d(x)=a$,
$$((q_1,q'_c),d,d,d_b,bpflag)
{\xrightarrow{ \textit{cas}(i,x,a,b), c_i=\epsilon, \textit{nop} }}_{\Delta_i}
((q_2,q'_c),d[x:b],d[x:b],d_b[x:b],bpflag')$$


%Here if $((q_2,q'_c),d[x:b])$ is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.
%If $q_2$ is the intermediate state for some $q_u$ and $q_v$, $(q_v,d[x:b])$ is a blocking pair, and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.

If $q_1 {\xrightarrow{ \textit{cas}\_\textit{fail}(x,a,b) }}_{\mathcal{L}} q_2$ , then for each $d \in \textit{Val}$ with $d(x) \neq a$,
$$((q_1,q'_c),d,d,d_b,bpflag)
{\xrightarrow{ \textit{cas}(i,x,a,a), c_i=\epsilon, \textit{nop} }}_{\Delta_i}
((q_2,q'_c),d,d,d_b,bpflag')$$

%Here if $((q_2,q'_c),d)$ is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.
%If $q_2$ is the intermediate state for some $q_u$ and $q_v$, $(q_v,d)$ is a blocking pair, and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.

%\item[-] Set the terminate flag: $$(q,d,d,bflag,0)
%{\xrightarrow{ \epsilon, c_i:\Theta, \textit{nop} }}_{\Delta_i}
%(q,d,d,bflag,1)$$
%where $\Theta=\Sigma \backslash \{ ((i,x,d'),\sharp) \vert x \in \mathcal{X}_{\mathcal{L}}, d' \in \textit{Val} \}$.

\item[-] Call and return: the call and return actions are modelled as $\epsilon$ transitions of \redt{$\textit{CM}_i$}:

$(q_c,d_c,d_g,d_b,bpflag)
{\xrightarrow{ \epsilon, c_i:\Sigma,\textit{nop} }}_{\Delta_i}
((\textit{is}_{(\textit{m,a})},q'_c),d_c,d_g,d_b,bpflag')$.

$((\textit{fs}_{(\textit{m,a})},q'_c),d_c,d_g,d_b,bpflag)
{\xrightarrow{ \epsilon, c_i:\Sigma,\textit{nop} }}_{\Delta_i}
(q_c,d_c,d_g,d_b,bpflag')$.

%If $((\textit{is}_{(\textit{m,a})},q'_c),d_c)$ of the first case (resp., $(q_c,d_c)$ of the second case) is a blocking pair and $bpflag=0$, then $bpflag'=1$; Otherwise, $bpflag'=bpflag$.
\end{itemize}

%Note that only flush action and $\textit{cas}$ action can change the flag $z$.
}


\forget{
\subsection{Obstruction-Freedom is Decidable}
\label{lemma:obstruction-freedom is decidable}

Let \redt{$\textit{CM}_i^w$} (\redt{$\textit{CM}_i^f$}) be a channel machine that is obtained from \redt{$\textit{CM}_i$} by
replacing all of its transitions but write (flush) and $\textit{cas}$ with internal transitions, and the remaining $\textit{cas}$ actions as write (flush) actions.


%\gpnote{What does ``is the production of'' mean here?}
The following lemma reduces the finite trace reachability problem of Lemma \ref{lemma:reducing obstruction free to a reachability problem of ObsSem(L,n)} into checking emptiness of $\bigcap_{i=1}^n T_{( q_i,q'_i )}^{(S,k)} \redt{\textit{CM}_i^f}$. Such problem is equivalent to a control state reachability problem of a perfect channel machine that is the production of \redt{$\textit{CM}_1^f$} to \redt{$\textit{CM}_n^f$} by Lemma \ref{proposition:relation bewteen LT of M1 and M2 and (LT of M1 and LT of M2)}. The proof of this lemma can be found in Appendix \ref{subsec: proof of lemma lemma:reduce the existence of exeuction of ObsSem(L,n) to the reachability problem of production of M1f to Mnf}. %Given a sequence $l=a_1 \cdot a_2 \cdot \ldots \cdot a_k$, let $l(i,j)=a_i \cdot \ldots \cdot a_j$.

\begin{lemma}
\label{lemma:reduce the existence of exeuction of ObsSem(L,n) to the reachability problem of production of M1f to Mnf}
Given a library $\mathcal{L}$, $\llbracket \mathcal{L}, n \rrbracket_{of}$ has an execution from $(p_{\textit{init}}, d_{\textit{init}}, u_{\textit{init}}, 0)$ to $(p, d, u_{\textit{init}}, 1)$, if and only if $\bigcap_{i=1}^n T_{( q_i,q'_i )}^{(S,k)} \redt{\textit{CM}_i^f} \neq \emptyset$. Here for each process $1 \! \leq \!i \! \leq \! n$, $q_i=( p_{\textit{init}}(i), d_{\textit{init}}, d_{\textit{init}}, d_{\textit{init}}, 0)$, $q'_i=( p(i), d, d, d_{bi}, bpflag_i)$ for some $d_{bi}$ and $bpflag_i$. Moreover, $bpflag_j=1$ for some process $j$.
\end{lemma}


The following lemma reduces the control state reachability problem of the production of \redt{$\textit{CM}_1^f$} to \redt{$\textit{CM}_n^f$} as a perfect channel machine to the control state reachability problem of the production of \redt{$\textit{CM}_1^w$} to \redt{$\textit{CM}_n^w$} as a perfect channel machine. Its proof can be found in Appendix \ref{subsec:proof of lemma lemma:reduce the reachability problem of production of M1w to Mnw as perfect channel machine to that of M1f to Mnf}.

\begin{lemma}
\label{lemma:reduce the reachability problem of production of M1w to Mnw as perfect channel machine to that of M1f to Mnf}

$\bigcap_{i=1}^n T_{( q_i,q'_i )}^{(S,k)} \redt{\textit{CM}_i^f} \neq \emptyset$, if and only if $\bigcap_{i=1}^n T_{( q_i,q'_i )}^{(S,k)} \redt{\textit{CM}_i^w} \neq \emptyset$. Here for each process $1 \! \leq \!i \! \leq \! \textit{n+1}$, $q_i=( p_{\textit{init}}(i), d_{\textit{init}}, d_{\textit{init}}, d_{\textit{init}}, 0)$, $q'_i=( p(i), d, d, d_{bi}, bpflag_i)$ for some $d_{bi}$ and $bpflag_i$.
\end{lemma}
%\begin {proof}
%This is obvious, since the channel is perfect and FIFO, and each $M_i^w$ and $M_i^f$ have their channel empty in the end of the execution. \qed
%\end {proof}

The following lemma reduces the control state reachability problem of the
production of \redt{$\textit{CM}_1^w$} to \redt{$\textit{CM}_n^w$} as a perfect channel machine to the control
state reachability problem of the production of \redt{$\textit{CM}_1^w$} to \redt{$\textit{CM}_n^w$} as a lossy
channel machine. %Note that the latter is known to be decidable \cite{DBLP:conf/popl/AtigBBM10}.
Its proof can be found in Appendix \ref{subsec:proof of lemma lemma:reduce the reachability problem of production of M1w to Mnw as perfect channel machine to that of lossy channel machine}.

\begin{lemma}
\label{lemma:reduce the reachability problem of production of M1w to Mnw as perfect channel machine to that of lossy channel machine}

$\bigcap_{i=1}^n T_{( q_i,q'_i )}^{(S,k)} \redt{\textit{CM}_i^w} \neq \emptyset$, if and only if $\bigcap_{i=1}^n LT_{( q_i,q''_i )}^{(S,k)} \redt{\textit{CM}_i^w} \neq \emptyset$. Here for each process $1 \! \leq \!i \! \leq \! \textit{n+1}$, $q_i=( p_{\textit{init}}(i), d_{\textit{init}}, d_{\textit{init}}, d_{\textit{init}}, 0)$, $q'_i=( p(i), d, d, d_{bi}, bpflag'_i)$, $q''_i=( p(i), d, d, d_{bi}, bpflag''_i)$ for some $d_{bi}$, $bpflag'_i$ and $bpflag''_i$. Moreover, $bpflag'_j=1$ for some $j$, if and only if $bpflag''_k=1$ for some $k$.
\end{lemma}

The following theorem states that obstruction-freedom is decidable on TSO for $n$ processes. This is a direct consequence of Lemma \ref{lemma:equivalent characterization of obstruction-freedom} %, Lemma \ref{lemma:reducing obstruction free to a reachability problem of ObsSem(L,n)}, Lemma \ref{lemma:reduce the existence of exeuction of ObsSem(L,n) to the reachability problem of production of M1f to Mnf}, Lemma \ref{lemma:reduce the reachability problem of production of M1w to Mnw as perfect channel machine to that of M1f to Mnf} and
to Lemma \ref{lemma:reduce the reachability problem of production of M1w to Mnw
  as perfect channel machine to that of lossy channel machine}, as well as the
decidability result of the control state reachability problem of lossy channel
machines \cite{DBLP:conf/popl/AtigBBM10}, and the fact that there are only
a finite number of such $p$, $d$ and $d_{bi}$.

\begin{theorem}
\label{theorem:obstruction-freedom is decidable}
The problem of checking obstruction-freedom of a given library %on fixed
for bounded number of processes is decidable.
\end{theorem}
}

\forget{
Note that it seems hard to directly reduce checking blocking pairs into state
reachability, since the latter problem requires each process to have an empty
buffer. Thus, we need to force each process to clear their buffer and this may
change the memory valuation. To check blocking pairs we need to recover memory
valuations, and thus, we require each process to state its previous buffer
content, which seems infeasible on TSO.
}

\forget{
\subsection{Obstruction-Freedom is Decidable}
\label{lemma:obstruction-freedom is decidable}
}

\forget{
Checking the existence of blocking pairs requires atomically reading the whole memory valuation, while we only have commands to atomically read one memory location. Although it seems hard to atomically read the whole memory valuation, in this subsection we propose a method to generate a basic TSO concurrent system %of \cite{DBLP:conf/popl/AtigBBM10}
and reduce checking blocking pairs into the state reachability problem of this basic TSO concurrent system.
}

\forget{
Informally, the desired basic TSO concurrent system is obtained from $\llbracket
\mathcal{L}, n \rrbracket$ by transforming call and return actions into internal
actions, and additionally allowing each process to non-deterministically check
blocking pairs.
%
When a process finishes checking it records the result in a new memory location
and then terminates the whole basic TSO concurrent system.
  %
In the check procedure we need to read the whole memory
valuation, and this procedure %The read of whole memory valuation
is performed in two phases. In the first phase a process reads from each memory
location $x \in \mathcal{X}$ and writes new special values (depending on the
value of $x$ and process ID) to mark them. In the second phase the process
checks if the value of each memory location of $\mathcal{X}$ has not been
overwritten by actions (including flush actions) of other processes.
}

%another process or by flush actions.

\forget{
% Given a library $\mathcal{L}$ = $(\mathcal{X}_{\mathcal{L}},\mathcal{M}, \mathcal{D}, Q_\mathcal{L},\rightarrow_\mathcal{L})$ and $n$, we introduce the following value and new memory locatons:
Assume that the data domain $\mathcal{D}=\{a_1,\ldots,a_u\}$, then we introduce new values $\{b_{i,j}\vert 1\leq i\leq n, 1\leq j\leq u\}$ which are used to mark memory locations of $\mathcal{X}$. We introduce a new memory location $\textit{result}$ with initial value $0$ to store the result of checking blocking pairs. %We introduce new memory locations $\{s_{proc}\vert 1\leq proc\leq n\}$ to store control state of each process.
We introduce a new memory location $\textit{terFlag}$ with initial value $0$, and we use
it as a flag to denote termination of the check %phase,
procedure, as well as the whole
basic TSO concurrent system.
}

\forget{
%{\color{orange} GP: The text below is really hard to read. I recommend using displays and breaking lines so that at least formulae fall on the same line.}
Formally, the tuple $(Q_{proc}, \Delta_{proc})$ of process $proc$ of the basic
TSO concurrent system for a given library $\mathcal{L}$ =
$(\mathcal{X}_{\mathcal{L}},\mathcal{M}, \mathcal{D},
Q_\mathcal{L},\rightarrow_\mathcal{L})$ is obtained as follows. Each control
state of $Q_{proc}$ is either a tuple $(\textit{in}_{\textit{clt}},proc,x)$ or
$(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,x)$ (with $q_{\mathcal{L}} \in Q_\mathcal{L}$ and $x
\in \{1,2\}$), or states of $\textit{CheckBP}$ (described below). States with
$x=1$ can first check $\textit{terFlag}$ (and set $x$ into 2 if success) and
then do transitions according to $\rightarrow_{\mathcal{L}}$. Here
$x$ is used to check $\textit{terFlag}$ before doing ``library
transitions''. %as a flag for such intermediate step.
}

%Assume a library $\mathcal{L}$ = $(\mathcal{X}_{\mathcal{L}},\mathcal{M}, \mathcal{D}, Q_\mathcal{L},\rightarrow_\mathcal{L})$. A control state of process $proc$ of the basic TSO concurrent system is a tuple $(q_c,proc,x)$, or $(q_{\mathcal{L}},q'_c,proc,x)$, or states of $\textit{CheckBP}$ (described below). Here $q_{\mathcal{L}} \in Q_{\mathcal{L}}$ is a state of $\mathcal{L}$ and $x \in \{1,2\}$. States with $x=1$ are ``normal states'' while states with $x=2$ are ``intermediate states''. %, and states with $x=0$ are states that is checking blocking pairs, as explained in construction of $\Delta_{proc}$.

\forget{
The transition relation $\Delta_{proc}$ %of process $proc$ of the basic TSO concurrent system
is defined as follows: Here we use $q {\xrightarrow{\alpha}}_{\Delta_{proc}} q'$ to denote that $(q,\alpha,q') \in \Delta_{proc}$.

\begin{itemize}
\item[-] %$(q_c,proc,1)$ and
$(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,1)$ can first check $\textit{terFlag}$ value and then do transitions according to $\mathcal{L}$. Formally, if $\alpha$ is a $\tau$, %$\textit{checkPID}$,
read, write or $\textit{cas}$ action and $q_{\mathcal{L}} {\xrightarrow{\alpha}}_{\mathcal{L}} q'_{\mathcal{L}}$ in $\mathcal{L}$, then we have $(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,1)$ ${\xrightarrow{\textit{read}(proc, \textit{terFlag}, 0)}}_{\Delta_{proc}}$ $(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,2)$ and $(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc$, $2) {\xrightarrow{\alpha'}}_{\Delta_{proc}} (q'_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,1)$ in $\Delta_{proc}$, where $\alpha'$ is obtained from $\alpha$ by adding process ID $proc$.

\item[-] To deal with call actions, we first check $\textit{terFlag}$ and then transform call actions into $\tau$ actions. Formally, we have $(\textit{in}_{\textit{clt}},proc,1) {\xrightarrow{\textit{read}(proc, \textit{terFlag}, 0)}}_{\Delta_{proc}} (\textit{in}_{\textit{clt}},proc,2)$ and $(\textit{in}_{\textit{clt}},proc,2)$ ${\xrightarrow{\tau(proc)}}_{\Delta_{proc}} (\textit{is}_{(\textit{m,a})},\textit{in}_{\textit{lib}},proc,1) )$ in $\Delta_{proc}$. The case for return actions is similar and we have $(\textit{fs}_{(\textit{m,a})}, \textit{in}_{\textit{lib}}, proc,1) {\xrightarrow{\textit{read}(proc, \textit{terFlag}, 0)}}_{\Delta_{proc}} (\textit{fs}_{(\textit{m,a})},\textit{in}_{\textit{lib}},proc,2)$ and $(\textit{fs}_{(\textit{m,a})},\textit{in}_{\textit{lib}},proc,2)$ \\ ${\xrightarrow{\tau(proc)}}_{\Delta_{proc}}$ $(\textit{in}_{\textit{clt}},proc, 1)$ in $\Delta_{proc}$.

    %{\color {red}Recall that $\textit{is}_{(\textit{m,a})}$ and $\textit{fs}_{(\textit{m,a})}$ are two special program positions of $\mathcal{L}$}.

    %$( (\textit{fs}_{(\textit{m,a})}, q'_c$, $proc,1), \textit{read}(terFlag,0), (\textit{fs}_{(\textit{m,a})},q'_c,proc,2) ), ( (\textit{fs}_{(\textit{m,a})},q'_c,proc,2), \tau$, $(q_c,proc$, $1) ) \in \Delta_{proc}$

%When $x=1$, $(q_c,proc,1)$ and $(q_{\mathcal{L}},q'_c,proc,1)$ can do transitions according to $\mathcal{L}$ if $terFlag=0$, or stop otherwise. Formally, if $\alpha$ is a $\tau$ action, $\textit{getPID}$ action, a read, a write or $\textit{cas}$, and we have $q_{\mathcal{L}} {\xrightarrow{\alpha}}_{\mathcal{L}} q'_{\mathcal{L}}$ in $\mathcal{L}$, then we have $( (q_{\mathcal{L}},q'_c,proc,1), \textit{read}($ $\textit{terFlag}$, $0), (q_{\mathcal{L}},q'_c,proc,2) ), ( (q_{\mathcal{L}},q'_c,proc,2), \alpha, (q'_{\mathcal{L}},q'_c,proc,1) ) \in \Delta_{proc}$.

    %Call and return actions are considered as internal actions with the following transition:
    %For each $m \in \mathcal{M}$ and $a \in \mathcal{D}$, we have $( (q_c,proc,1), \textit{read}(terFlag,0), (q_c, proc,2))$, $( (q_c,proc,2), \tau, (\textit{is}_{(\textit{m,a})},q'_c,proc,1) ) \in \Delta_{proc}$ for ``call actions'', and $( (\textit{fs}_{(\textit{m,a})}, q'_c$, $proc,1), \textit{read}(terFlag,0), (\textit{fs}_{(\textit{m,a})},q'_c,proc,2) ), ( (\textit{fs}_{(\textit{m,a})},q'_c,proc,2), \tau$, $(q_c,proc$, $1) ) \in \Delta_{proc}$ for ``return actions''.

\item[-] $(\textit{in}_{\textit{clt}},proc,1)$ and $(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,1)$ can
  non-deterministically %change $x$ to $0$. Then, they operate as $\textit{CheckBP}$ (described below)
  decide to execute $\textit{CheckBP}$ (described below).
\end{itemize}

%The control state of a process records its process id and the ``current state'' $q_c$ or $(q,q'_c)$ in $\llbracket \mathcal{L}, n \rrbracket$. Call and return actions are transformed into internal actions. When process $proc$ do a ``$\llbracket \mathcal{L}, n \rrbracket$'' action, it checks the value of $terFlag$, and stop working if its value is $1$.
We denote by $\textit{CheckBP}$ the sequence of transitions that are used to check blocking pairs. %If it runs on process $proc$ and the current ``library state'' is $s$, then $\textit{CheckBP}$ works as follows:
If $\textit{CheckBP}$ is started from $(\textit{in}_{\textit{clt}},proc,1)$ (resp., $(q_{\mathcal{L}},\textit{in}_{\textit{lib}},proc,1)$), then $\textit{CheckBP}$ works as follows:
%Given $s\in \{q_c\} \cup (Q_{\mathcal{L}}\times \{q'_c\})$, if $\textit{CheckBP}$ is started by $(s,proc,1)$, then $\textit{CheckBP}$ works as follows: %the following is used to check blocking pairs, and a process can nondeterministically do $checkBP$ at any time. $checkBP$ works as follows:

\begin{itemize}
\item[-] %Obtain process id (assume it is $proc$), and then
  Perform a $\textit{cas}$ command to clear the buffer.

\item[-] For each $x \in \mathcal{X}$, read a value from $x$ (we assume the
  value is $a_j$), and then use $\textit{cas}\_\textit{suc}(%proc,
  x,a_j, $ $b_{proc,j})$ to write a special value to $x$.

\item[-] Read the value of each $x \in \mathcal{X}$ again and check if %the value of each memory location of $\mathcal{X}$
  these value belongs to $\{b_{proc,j}\vert 1\leq j\leq u\}$. If so, check if %$s$
  $\textit{in}_{\textit{clt}}$ (resp., $(q_{\mathcal{L}},\textit{in}_{\textit{lib}})$) and $f(x)$ for $x \in \mathcal{X}$ is a blocking pair. Here $f$ is a function that maps each $b_{proc,j}$ into $a_j$. If it is a blocking pair, then we set $\textit{result}$ to $1$.

\item[-] Set $\textit{terFlag}$ to $1$.
\end{itemize}
}

% Lemma \ref{lemma:equivalent characterization of obstruction-freedom} reduces checking obstruction-freedom into the state reachability problem of configurations containing blocking pairs.
Since the model checking problem for CTL$^*$ formulas is decidable for finite state LTSs \cite{DBLP:reference/mc/2018}, we could compute the set of blocking pairs by first enumerating all
configurations of $\llbracket \mathcal{L}, 1 \rrbracket_{sc}$, and then use
model checking to check each of them. Thus, the configurations of the state reachability problem of Lemma \ref{lemma:equivalent characterization of obstruction-freedom} is computable. Since the the state reachability problem is decidable, we conclude that obstruction-freedom is decidable, as stated by the following theorem.

\forget{
With this basic TSO concurrent system, we reduce checking blocking pairs into checking if some configuration with $\textit{result}=1$ is reachable on the basic TSO concurrent system, which is known decidable \cite{DBLP:conf/popl/AtigBBM10}. The following theorem states that obstruction-freedom is decidable on TSO for $n$ processes. %It is proved by reducing checking blocking pairs into the state reachability problem of the TSO concurrent system above, as well as Lemma \ref{lemma:equivalent characterization of obstruction-freedom}
The proof can be found in Appendix \ref{subsec:appendix proof of theorem theorem:obstruction-freedom is decidable}. %\ref{sec:appendix proof of section sec:checking obstruction-freedom}.
}
\begin{theorem}
  \label{theorem:obstruction-freedom is decidable}
  The problem of checking obstruction-freedom of a given library for bounded number of processes is decidable on TSO.
\end{theorem}




