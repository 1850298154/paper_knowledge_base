\section{Concurrent Systems}
\label{sec:concurrent systems}

%In this section, we present the notations of concurrent objects and concurrent systems. We then introduce their operational semantics on TSO.

\subsection{Notations}

In general, a finite sequence on an alphabet $\Sigma$ is denoted $l=a_1 \cdot a_2 \cdot \ldots \cdot a_k$, where $\cdot$ is the concatenation symbol and $a_i\in\Sigma$ for each $1 \! \leq \! i \! \leq \! k$. Let $|l|$ and $l(i)$ denote the length and the $i$-th element of $l$, respectively, i.e., $|l|=k$ and $l(i)=a_i$ for $1 \! \leq \! i \! \leq \! k$.
Let $l(i,j)$ denote the string $l(i) \cdot \ldots \cdot l(j)$. %, and $l(i,\infty)$ denote the string $l(i) \cdot \ldots$, where the size of $l$ is infinite.
Let $l \uparrow_{\Sigma'}$ denote the projection of $l$ on the alphabet $\Sigma'$. Given a function $f$, let $f[x:y]$ be the function that is the same as $f$ everywhere, except for $x$, where it has the value $y$. Let $\_$ denote an item, of which the value is irrelevant, and $\epsilon$ the empty word.

A $\textit{labelled transition system}$ (LTS) is a tuple $\mathcal{A}=(Q,\Sigma,\rightarrow,q_0)$, where $Q$ is a set of states, $\Sigma$ is an alphabet of transition labels, $\rightarrow\subseteq Q\times\Sigma\times Q$ is a transition relation and $q_0$ is the initial state.
A finite path of $\mathcal{A}$ is a finite  sequence of transitions
$q_0\xrightarrow{a_1}q_1\overset{a_2}{\longrightarrow}\ldots\overset{a_k}{\longrightarrow}q_k$ with
$k \! \geq \! 0$, and a finite trace of $\mathcal{A}$ is a finite sequence $t= a_1 \cdot a_2 \cdot
\ldots \cdot a_k$, with $k \! \geq \! 0$ if there exists a finite path
$q_0\overset{a_1}{\longrightarrow}q_1\overset{a_2}{\longrightarrow}\ldots\overset{a_k}{\longrightarrow}q_k$ of $\mathcal{A}$.
An infinite path of $\mathcal{A}$ is an infinite sequence of transitions
$q_0\xrightarrow{a_1}q_1\overset{a_2}{\longrightarrow}\ldots$, and correspondingly an infinite trace of $\mathcal{A}$ is an infinite sequence $t= a_1 \cdot a_2 \cdot \ldots$ if there exists an infinite path $q_0\overset{a_1}{\longrightarrow}q_1\overset{a_2}{\longrightarrow}\ldots$ of $\mathcal{A}$.

\subsection{Concurrent Objects %Libraries
and The Most General Client}

%A concurrent data structure provides a number of methods for accessing the data structure. %internal state representation.
%\redt{A concurrent object provides a set of methods for client programs to access the object.}
%Here we assume, as customary, that
Concurrent objects %concurrent data structures
are implemented as well-encapsulated libraries. %A client program is a program that interacts with libraries.
The \emph{most general client} of a concurrent object %a library
is a program that interacts with the object, %library,
and is designed to exhibit all the possible behaviors of the object. %a library.
A simple instance of the %
most general
client is a client %with a number of threads
that repeatedly makes non-deterministic method calls with non-deterministic arguments. %{\color {red}while respecting methods preconditions.}
Libraries may contain private memory locations for their own uses. For simplicity, and without loss
of generality, we assume that methods have only one argument and one return value (when %it returns).
they return).

Given a finite set $\mathcal{X}$ of memory locations, a finite set $\mathcal{M}$
of method names and a finite data domain $\mathcal{D}$, the set $\textit{PCom}$
of primitive commands
is defined by the following grammar:
\vspace{-3pt}
\[
  \begin{array}{lcl}
    \textit{PCom} & ::= & \tau \ | \ %\textit{checkPID}\_\textit{suc}(i)  \ | \
                          %\textit{checkPID}\_\textit{fail}(i) \ | \
                          \textit{read}(x,a) \  |\  \textit{write}(x,a) \ | \ %\\
                  %& | &
                        \textit{cas}\_\textit{suc}(x,a,b) \ | \
                  %& | &
                         \textit{cas}\_\textit{fail}(x,a,b)\\
    & | & \textit{call}(m,a) \ |\ \textit{return}(m,a)
  \end{array}
\]

% \begin{equation*}
% \begin{split}
%   \textit{PCom} ::= \tau \ | \  %\textit{getPID}\Rightarrow j
%     \textit{checkPID}(i)  \ | \ \textit{read}(x,a) \  |\  \textit{write}(x,a)\  | \\
%   % \textit{checkPID}\_\textit{cas}(i) \ | \textit{checkPID}\_\textit{fail}(i)}  \ | \ \textit{read}(x,a) \  |\  \textit{write}(x,a)\  | \\
%     \textit{cas}\_\textit{suc}(x,a,b) \ |\ \textit{cas}\_\textit{fail}(x,a,b) \ | \  \textit{call}(m,a) \ |\ \textit{return}(m,a)
% \end{split}
% \end{equation*}
%{\color{orange} GP: I don't really like the $\Rightarrow j$ notation for the getPID command. Could we rename it $checkPID(j)$ or something like that if it is a conditional?}

\noindent where $a, b \in \mathcal{D}, x \in \mathcal{X}$ %,
and $m\in\mathcal{M}$. %,
%and $i \in \mathbb{N}$.
Here $\tau$ represents an internal command.
To use the commands as labels in an LTS we assume that they encode the
expected values that they return (an oracle of sorts). Hence, for instance the
read command $\textit{read}(x, a)$ encodes the value read $a$.
%
%Similarly, the $\textit{checkPID}\_\textit{suc}(i)$ command is the successful case of the command used to check if the process identifier of the process executing it is $i$. If the process identifier does not match the command cannot execute, but $\textit{checkPID}\_\textit{fail}(i)$ can execute instead.
In general \textit{cas} (compare-and-set) commands execute a read
and a conditional write (or no write at all) in a single atomic step. In our
case a successful $\textit{cas}$ is represented with the command
$\textit{cas}\_\textit{suc}(x,a,b)$, and it is enabled when the initial value of
$x$ is $a$, upon which the command %it
updates it with value $b$, while a failed
$\textit{cas}$ command, represented with the command
$\textit{cas}\_\textit{fail}(x,a,$ $b)$ does not update the state, and can only
happen when the value of $x$ is not $a$.


A library $\mathcal{L}$ is a tuple
\mbox{$\mathcal{L}$ = $(\mathcal{X}_{\mathcal{L}},\mathcal{M}_{\mathcal{L}}, \mathcal{D}_{\mathcal{L}}, Q_\mathcal{L},$ $\rightarrow_\mathcal{L})$}, where $\mathcal{X}_{\mathcal{L}}$, $\mathcal{M}_{\mathcal{L}}$ and $\mathcal{D}_{\mathcal{L}}$ are a finite memory location set, a finite method name set and a finite data domain of $\mathcal{L}$, respectively.
$Q_\mathcal{L} = \bigcup_{m \in \mathcal{M_\mathcal{L}}} Q_m $ is the union of disjoint finite sets $Q_m$ of program positions of each method $m\in\mathcal{M}_\mathcal{L}$.
Each program position represents the current program counter value and local register value of a
process and can be considered as a state.
$\rightarrow_\mathcal{L} = \bigcup_{m \in \mathcal{M}_\mathcal{L}} \rightarrow_m$ is the union of disjoint transition relations of each method $m\in\mathcal{M}_\mathcal{L}$. Let $\textit{PCom}_{\mathcal{L}}$ be the set of primitive commands (except call and return commands) upon $\mathcal{X}_{\mathcal{L}}$, $\mathcal{M}_{\mathcal{L}}$ and $\mathcal{D}_{\mathcal{L}}$. Then, for each $m \in \mathcal{M}_{\mathcal{L}}$, $\rightarrow_m \subseteq Q_m \times \textit{PCom}_{\mathcal{L}} \times Q_m$. For each $m \in \mathcal{M}_{\mathcal{L}}$ and $a\in\mathcal{D}_\mathcal{L}$, $Q$ contains an initial %state
program position $\textit{is}_{(\textit{m,a})}$, which represents that library begins to execute method $m$ with argument $a$, and a final %state
program position $\textit{fs}_{(\textit{m,a})}$ which represents that method $m$ has finished its execution and then a return action with return value $a$ can occur. There are neither incoming transitions to $\textit{is}_{(\textit{m,a})}$ nor outgoing transitions from $\textit{fs}_{(\textit{m,a})}$ in $\rightarrow_m$.
% ; while for each $a\in\mathcal{D}_\mathcal{L}$ there exists an initial state $\textit{is}_{(\textit{m,a})}$ and a final state $\textit{fs}_{(\textit{m,a})}$ in $Q_m$ such that there are neither incoming transitions to $\textit{is}_{(\textit{m,a})}$ nor outgoing transitions from $\textit{fs}_{(\textit{m,a})}$ in $\rightarrow_m$. $\textit{is}_{(\textit{m,a})}$ represents that concurrent data structure begins to execute method $m$ with argument $a$, and $\textit{fs}_{(\textit{m,a})}$ represents that method $m$ has finished its execution and then a return action with return value $a$ can occur.

% \gpnote{I think we need to explain why $\{q_c,q'_c\}$ here. This is unusual.}

% \color {red}A most general client is a special program that repeatedly calls an arbitrary method with an arbitrary argument for arbitrarily many times.
%Formally, the %a
The most general client $\mathcal{MGC}$ is defined as a tuple $( \mathcal{M}_{\mathcal{C}}, \mathcal{D}_{\mathcal{C}}, Q_{\mathcal{C}},\rightarrow_{\textit{mgc}})$, where $\mathcal{M}_{\mathcal{C}}$ is a finite method name set, $\mathcal{D}_{\mathcal{C}}$ is a finite data domain, $Q_{\mathcal{C}}=\{\textit{in}_{\textit{clt}},\textit{in}_{\textit{lib}}\}$ %$Q_{\mathcal{C}}=\{q_c,q'_c\}$
is the state set, %$q_c$ and $q'_c$ are two states,
and $\rightarrow_{\textit{mgc}}=  \{ (\textit{in}_{\textit{clt}},\textit{call}(m,a),\textit{in}_{\textit{lib}}), (\textit{in}_{\textit{lib}},\textit{return}(m,b), \textit{in}_{\textit{clt}}), \vert m \in \mathcal{M}_{\mathcal{C}}, a,b \in \mathcal{D}_{\mathcal{C}} \} $ %and $\rightarrow_{\textit{mgc}}=  \{ (q_c,\textit{call}(m,a),$ $q'_c),(q'_c,\textit{return}(m,b)$, $q_c), \vert m \in \mathcal{M}_{\mathcal{C}}, a,b \in \mathcal{D}_{\mathcal{C}} \} $
is a transition relation. State $\textit{in}_{\textit{clt}}$ %$q_c$
represents that currently %there is
no method of library is running, and $\textit{in}_{\textit{lib}}$ %$q'_c$
represents that some method of library is running.
%A client program $\mathcal{C}$ can then be defined as a tuple $\mathcal{C}$ = $(\mathcal{X}_{\mathcal{C}},\mathcal{M}_{\mathcal{C}}, \mathcal{D}_{\mathcal{C}}, Q_\mathcal{C}, $ $\rightarrow_\mathcal{C})$ where $\mathcal{X}_{\mathcal{C}}$, $\mathcal{M}_{\mathcal{C}}$,  $\mathcal{D}_{\mathcal{C}}$ and $Q_\mathcal{C}$ are a finite memory location set, a finite method name set, a finite data domain and a finite program position set of $\mathcal{C}$, respectively. Let $\textit{PCom}_{\mathcal{C}}$ be the set of primitive commands upon $\mathcal{X}_{\mathcal{C}}$, $\mathcal{M}_{\mathcal{C}}$ and $\mathcal{D}_{\mathcal{C}}$. Then, $\rightarrow_{\mathcal{C}} \subseteq Q_{\mathcal{C}} \times \textit{PCom}_{\mathcal{C}} \times Q_{\mathcal{C}}$ is a transition relation of $\mathcal{C}$. A most general client is a special client program that is designed to exhibit all the possible behaviors of a library. Formally, a most general client $\mathcal{MGC}$ is defined as a client $( \{\}, \mathcal{M}_{\mathcal{C}}, \mathcal{D}_{\mathcal{C}}, \{q_c,q'_c\},\rightarrow_{\textit{mgc}})$ with a transition relation $\rightarrow_{\textit{mgc}}=  \{ (q_c,\textit{call}(m,a),$ $q'_c),(q'_c,\textit{return}(m,b),q_c), \vert m \in \mathcal{M}_{\mathcal{C}}, a,b \in \mathcal{D}_{\mathcal{C}} \} $. $q_c$ represents that currently there is no method of library running on this most general client program, and $q'_c$ represents that some method of library is running on this most general client program. Intuitively, a most general client %simply
%repeatedly calls an arbitrary method with an arbitrary argument for arbitrarily many times.






\subsection{TSO Operational Semantics}
\label{sec:operational semantics}

A concurrent system consists of $n$ processes, each of which runs the %a
most general client $\mathcal{MGC}$ = $( \mathcal{M}, \mathcal{D}, \{\textit{in}_{\textit{clt}},\textit{in}_{\textit{lib}}\},\rightarrow_{\textit{mgc}})$, and all the most general clients interact with a same library $\mathcal{L}$ = $(\mathcal{X}_{\mathcal{L}},\mathcal{M}, \mathcal{D}, Q_\mathcal{L},\rightarrow_\mathcal{L})$.
%{\color {red}On TSO memory model \cite{DBLP:conf/tphol/OwensSS09}, each processor is equipped with an FIFO store buffer. Although in each detailed chip of TSO memory model the buffer size is bounded, since the TSO memory model is proposed to model all chips with such mechanism, the buffer size is unbounded in TSO memory model of \cite{DBLP:conf/tphol/OwensSS09}.}
In this paper we follow the %theoretical
TSO memory model of~\cite{DBLP:conf/popl/AtigBBM10}
(similarly
to~\cite{DBLP:conf/tphol/OwensSS09,DBLP:conf/esop/BouajjaniDM13,DBLP:conf/esop/BurckhardtGMY12}),
where each processor is equipped with a FIFO store buffer.
As explained in the introduction, in this %theoretical
TSO memory model, each process is associated with an unbounded FIFO store buffer.
%{\color {red}Although in every realistic multiprocessor system implementing the TSO memory model, the buffer is of bounded size, to describe the semantics of \emph{any} TSO implementing system it is necessary to consider unbounded size FIFO store buffers associated with each process, as in the semantics of~\cite{DBLP:conf/popl/AtigBBM10}.}
Fence commands are used to ensure order between commands before fence and commands after fence. The TSO memory model of \cite{DBLP:conf/popl/AtigBBM10} does not include fence commands, since fence commands can be simulated with $\textit{cas}$ commands.
%Although in every realistic multiprocessor system implementing the TSO memory model, the buffer is of bounded size, to describe the semantics of \emph{any} TSO implementing system it is necessary to consider unbounded size FIFO store buffers associated with each process, as in the semantics of~\cite{DBLP:conf/tphol/OwensSS09}. associates a unbounded size FIFO store buffer with each process. This is clearly a safe over-approximation of any TSO system.




The operational semantics of a concurrent system (with library $\mathcal{L}$ and $n$ processes) on TSO is defined
as an LTS $\llbracket \mathcal{L}, n \rrbracket$ = $(\textit{Conf}, \Sigma,
\rightarrow,\textit{InitConf})$, %where
with $\textit{Conf}$, $\Sigma$, $\rightarrow$
and $\textit{InitConf}$ described below. %as follows.

Configuration of $\textit{Conf}$ are tuples $(p,d,u)$, where $p: \{ 1, \ldots, n \} \rightarrow \{\textit{in}_{\textit{clt}}\} \cup (Q_{\mathcal{L}} \times \{\textit{in}_{\textit{lib}}\})$ %$p: \{ 1, \ldots, n \} \rightarrow \{q_c\} \cup (Q_{\mathcal{L}} \times \{q'_c\})$
represents the control state of each process, $d: \mathcal{X}_{\mathcal{L}} \rightarrow \mathcal{D}$ is the valuation of memory locations, and $u: \{ 1, \ldots, n\} \rightarrow (\{ (x,a)\ \vert\ x \in \mathcal{X}_{\mathcal{L}}, a \in \mathcal{D} \})^*$ is the content of each process's %processor's
store buffer. The initial configuration $\textit{InitConf} \in \textit{Conf}$ is $(p_{\textit{init}}, d_{\textit{init}}, u_{\textit{init}})$. Here $p_{\textit{init}}$ maps each process id to $\textit{in}_{\textit{clt}}$, %$q_c$,
$d_{\textit{init}}$ is a valuation for memory locations in $\mathcal{X}_{\mathcal{L}}$, and $u_{\textit{init}}$ initializes each process with an empty buffer.

%{\color{orange} Indeed there seems to be an  inconsistent use of $getPID$ below.}

We denote with $\Sigma$ the set of actions defined by the following grammar:\\[-5pt]
\[
  \begin{array}{lcl}
    \Sigma & ::= & \tau(i) \  | \ %{\color {red}getPID(i)}
    \textit{read}(i,x,a) \  |\  \textit{write}(i,x,a)\  | \
    \textit{cas}(i,x,a,b) \ | \
    \textit{flush}(i,x,a) \\
    & | & \textit{call}(i,m,a) \ | \  \textit{return}(i,m,a)
  \end{array}
\]


\noindent where $1 \! \leq \! i \! \leq \! n, m \in \mathcal{M}$, $x \in
\mathcal{X}_{\mathcal{L}}$ and $a,b \in \mathcal{D}$. The transition relation $\rightarrow$ is the least relation satisfying the
transition rules shown in \figurename~\ref{fig:transition relation te} for each
$1 \leq i \leq n$. The rules are explained below:
\begin{itemize}
%\setlength{\itemsep}{0.5pt}
\item[-] $\textit{Tau}$ rule: A $\tau$ transition only influences the control state of one process.

%\item[-] {\color {red}$\textit{GetPID}$ rule: A $\textit{getPID}$ transition can occur if the process id matches the argument of the command.}
%\item[-] $\textit{CheckPID}\_\textit{Suc}$ and $\textit{CheckPID}\_\textit{Fail}$ rules: A $\textit{checkPID}\_\textit{suc}$ transition can occur if the current process ID matches the process ID of the $\textit{checkPID}\_\textit{suc}$ command, and a $\textit{checkPID}\_\textit{fail}$ transition can occur if the current process ID does not match the process ID of the $\textit{checkPID}\_\textit{fail}$ command.

\item[-] $\textit{Read}$ rule: A function $\textit{lookup}(u,d,i,x)$ is used to search for the latest value of $x$ %from its %processor-local
    %store buffer
    in the buffer or the main memory, i.e.,
\begin{displaymath}
\textit{lookup(u,d,i,x)} = \left \{ \begin{array}{ll}
                      a & \textrm{if } u(i) %\uparrow_{\Sigma_x}
                          \uparrow_{ \{ (x,b)\vert b \in \mathcal{D} \} }  =(x,a) \cdot l, \ \textit{for some sequence} \ l %\in \Sigma_x^*
                          \\
                      d(x) & \textrm{otherwise }
                      \end{array} \right.
\end{displaymath}
where %$\Sigma_x$ = $\{(x,a) \vert x \in \mathcal{X}_{\mathcal{L}}, a \in \mathcal{D} \}$
$\{ (x,b)\vert b \in \mathcal{D} \}$ is the set of items of $x$ in buffer. %pending write actions for $x$.
%Read actions return the latest value of $x$ from the processor-local store buffer if present, and return the value in memory if there isn't any.
A $\textit{read}(i,x,a)$ action returns the latest value of $x$ in the buffer
if present, or returns the value in memory if the buffer contains no stores on
$x$.

\item[-] $\textit{Write}$ rule: %A write action will insert a pair of memory location and value at the %end
    %tail of its processor-local store buffer.
    An $\textit{write}(i,x,a)$ action puts an item $(x,a)$ into
    the tail of its %processor-local %the
    store buffer.

\item[-] $\textit{Cas}\_\textit{Suc}$ and $\textit{Cas}\_\textit{Fail}$ rules: %A $\textit{cas}$ command can only be executed when the  processor-local store buffer is empty and thus forces the current process to clear its store buffer in advance. %A successful $\textit{cas}$ command will change the value of memory location $x$ immediately while a failed $\textit{cas}$ command does not change memory.
  A $\textit{cas}$ action atomically executes a read and a conditional write (or no write at all) if and only if the process's %processor-local
  store buffer is empty.

\item[-] $\textit{Flush}$ rule: %The memory model may decide to flush the entry at the head of processor-local store buffer to memory at any time.
    An $\textit{flush}$ action is carried out by the memory model to flush the item at the head of the process's %processor-local
    store buffer to memory at any time.

\item[-] $\textit{Call}$ and $\textit{Return}$ rules: After a $\textit{call}$ action, the current
  process %transitions
  transits to $\textit{is}_{(\textit{m,a})}$. When the current process %comes to
  %transitions
  transits to $\textit{fs}_{(\textit{m,a})}$ it can launch a $\textit{return}$ action and %return to
  move to %$q_c$
  $\textit{in}_{\textit{clt}}$ of the most general client. %program.
\end{itemize}
%\gpnote{Where are \emph{is} and \emph{fs} defined?}
\begin{figure}[tbp]
%tau%
\[
\begin{array}{l c}
  \bigfrac{ p(i)=(q_i,\textit{in}_{\textit{lib}} %q'_c
  ) \quad q_i\ {\xrightarrow{\tau}}_{\mathcal{L}}\ q'_i } { ( p,d,u)\ {\xrightarrow{\tau(i)}}\ ( p[i:(q'_i,\textit{in}_{\textit{lib}} %q'_c
)],d,u )} {\textit{Tau}}
\end{array}
\]

\vspace{-2pt}

%checkPID_suc
%\[
%  \begin{array}{l c}
%    \bigfrac{ p(i)=(q_i,q'_c) \quad q_i\ {\xrightarrow{\textit{checkPID}\_\textit{suc}(i)}}_{\mathcal{L}}\ q'_i } { ( p,d,u)\ {\xrightarrow{\textit{checkPID}(i)}}\ ( p[i:(q'_i,q'_c)],d,u )} {\textit{CheckPID}\_\textit{Suc}}
%  \end{array}
%\]

%\vspace{-2pt}

%checkPID_fail
%\[
%  \begin{array}{l c}
%    \bigfrac{ p(i)=(q_i,q'_c) \quad j \neq i \quad q_i\ {\xrightarrow{\textit{checkPID}\_\textit{fail}(j)}}_{\mathcal{L}}\ q'_i } { ( p,d,u)\ {\xrightarrow{\textit{checkPID}(i)}}\ ( p[i:(q'_i,q'_c)],d,u )} {\textit{CheckPID}\_\textit{Fail}}
%  \end{array}
%\]

%\vspace{-2pt}


%getPID%
%{\color {red}\[
%\begin{array}{l c}
%\bigfrac{ p(i)=(q_i,q'_c) \quad q_i\ {\xrightarrow{\textit{getPID}\Rightarrow i}}_{\mathcal{L}}\ q'_i } { %( p,d,u)\ {\xrightarrow{\textit{getPID}(i)}}\ ( p[i:(q'_i,q'_c)],d,u )} {\textit{GetPID}}
%\end{array}
%\]}

\vspace{-2pt}


%read%
\[
\begin{array}{l c}
  \bigfrac{ p(i)=(q_i,\textit{in}_{\textit{lib}} %q'_c
) \quad q_i\ {\xrightarrow{\textit{read}(x,a)}}_{\mathcal{L}}\ q'_i \quad \textit{lookup}(u,d,i,x)=a } { ( p,d,u)\ {\xrightarrow{\textit{read}(i,x,a)}}\
  ( p[i:(q'_i, \textit{in}_{\textit{lib}} %q'_c
)],d,u ] )} {\textit{Read}}
\end{array}
\]

\vspace{-2pt}



%write%
\[
\begin{array}{l c}
  \bigfrac{ p(i)=(q_i,\textit{in}_{\textit{lib}} %q'_c
) \quad q_i\
  {\xrightarrow{\textit{write}(x,a)}}_{\mathcal{L}}\ q'_i \quad u(i)=l } { ( p,d,u)\ {\xrightarrow{\textit{write}(i,x,a)}}\
  ( p[i:(q'_i, \textit{in}_{\textit{lib}} %q'_c
)],d,u[i:(x,a) \cdot l] )} {\textit{Write}}
\end{array}
\]

\vspace{-2pt}

%cas_suc%
\[
\begin{array}{l c}
  \bigfrac{ p(i)=(q_i, \textit{in}_{\textit{lib}} %q'_c
) \quad q_i\
  {\xrightarrow{\textit{cas}\_\textit{suc}(x,a,b)}}_{\mathcal{L}}\ q'_i \quad
  d(x)=a \quad u(i)=\epsilon } { ( p,d,u)\
{\xrightarrow{\textit{cas}(i,x,a,b)}}\
  ( p[i:(q'_i, \textit{in}_{\textit{lib}} %q'_c
)],d[x:b],u)} {\textit{Cas}\_\textit{Suc}}

\end{array}
\]

\vspace{-2pt}

%cas_fail%
\[
\begin{array}{l c}
  \bigfrac{ p(i)=(q_i, \textit{in}_{\textit{lib}} %q'_c
) \quad q_i\
  {\xrightarrow{\textit{cas}\_\textit{fail}(x,a,b)}}_{\mathcal{L}}\ q'_i \quad
  d(x) \neq a \quad u(i)=\epsilon } { (p,d,u)\
  {\xrightarrow{\textit{cas}(i,x,a,b)}}\ ( p[i:(q'_i, \textit{in}_{\textit{lib}} %q'_c
  )],d,u)} {\textit{Cas}\_\textit{Fail}}
\end{array}
\]

\vspace{-2pt}

%flush%
\[
\begin{array}{l c}
\bigfrac{ u(i)=l \cdot (x,a) } { ( p,d,u)\
{\xrightarrow{\textit{flush}(i,x,a)}}\
( p,d[x:a],u[i:l] )} {\textit{Flush}}
\end{array}
\]

\vspace{-2pt}


%call%
\[
\begin{array}{l c}
  \bigfrac{ p(i)= \textit{in}_{\textit{clt}} %q_c
} { (p,d,u)\
{\xrightarrow{\textit{call}(i,m,a)}}\
  ( p[ i: (\textit{is}_{(\textit{m,a})}, \textit{in}_{\textit{lib}} %q'_c
) ],d,u)} {\textit{Call}}
\end{array}
\]

\vspace{-2pt}

%return%
\[
\begin{array}{l c}
  \bigfrac{ p(i)=(\textit{fs}_{(\textit{m,a})}, \textit{in}_{\textit{lib}} %q'_c
) } { (p,d,u)\
{\xrightarrow{\textit{return}(i,m,a)}}\
  ( p[i: \textit{in}_{\textit{clt}} %q_c
],d,u )} {\textit{Return}}
\end{array}
\]

%\vspace{-5pt}
\caption{Transition Relation $\rightarrow$}\label{fig:transition
relation te}

\vspace{-15pt}

\end{figure}




\forget{The detailed
definition of the transition relation can be found in Appendix
\ref{sec:appendix proof of section sec:concurrent systems}. Intuitively, an
$\textit{write}(i,x,a)$ action puts an item $(x,a)$ into the store buffer, and
a $\textit{read}(i,x,a)$ action returns the latest value of $x$ in the buffer
if present, or returns the value in memory if the buffer contains no stores on
$x$. Actions $\tau$, $\textit{call}$ and $\textit{return}$ only influence the
control state. An $\textit{flush}$ action is carried out by the memory model
to flush the item at the head of the process's %processor-local
store buffer to memory at
any time. A $\textit{cas}$ action atomically executes a read and a
conditional write (or no write at all) if and only if the process's %processor-local
store buffer is empty.
}


\forget{
The transition relation $\rightarrow$ is the least relation satisfying the
transition rules shown in \figurename~\ref{fig:transition relation te} for each
$1 \leq i \leq n$. The rules are explained below:
\begin{itemize}
%\setlength{\itemsep}{0.5pt}
\item[-] $\textit{Tau}$ rule: A $\tau$ transition only influences the control state of one process.

%\item[-] {\color {red}$\textit{GetPID}$ rule: A $\textit{getPID}$ transition can occur if the process id matches the argument of the command.}
%\item[-] $\textit{CheckPID}\_\textit{Suc}$ and $\textit{CheckPID}\_\textit{Fail}$ rules: A $\textit{checkPID}\_\textit{suc}$ transition can occur if the current process ID matches the process ID of the $\textit{checkPID}\_\textit{suc}$ command, and a $\textit{checkPID}\_\textit{fail}$ transition can occur if the current process ID does not match the process ID of the $\textit{checkPID}\_\textit{fail}$ command.

\item[-] $\textit{Read}$ rule: A function $\textit{lookup}(u,d,i,x)$ is used to search for the latest value of $x$ from its  processor-local store buffer or the main memory, i.e.,
\begin{displaymath}
\textit{lookup(u,d,i,x)} = \left \{ \begin{array}{ll}
                      a & \textrm{if } u(i) %\uparrow_{\Sigma_x}
                      \redt{ \uparrow_{ \{ (x,b)\vert b \in \mathcal{D} \} } } =(x,a) \cdot l, \ \textit{for some} \ l \in \Sigma_x^*  \\
                      d(x) & \textrm{otherwise }
                      \end{array} \right.
\end{displaymath}
where %$\Sigma_x$ = $\{(x,a) \vert x \in \mathcal{X}_{\mathcal{L}}, a \in \mathcal{D} \}$
\redt{$\{ (x,b)\vert b \in \mathcal{D} \}$} is the set of \redt{items of $x$ in buffer.} %pending write actions for $x$.
Read actions return
the latest value of $x$ from the processor-local store buffer if present, and
return the value in memory if there isn't any.

\item[-] $\textit{Write}$ rule: A write action will insert a pair of memory location and value at the %end
    tail of its processor-local store buffer.

\item[-] $\textit{Cas}\_\textit{Suc}$ and $\textit{Cas}\_\textit{Fail}$ rules: A $\textit{cas}$
  command can only be executed when the  processor-local store buffer is empty
  and thus forces the current process to clear its store buffer in advance. %A successful $\textit{cas}$ command will change the value of memory location $x$ immediately while a failed $\textit{cas}$ command does not change memory.

\item[-] $\textit{Flush}$ rule: The memory model may decide to flush the entry at the head of processor-local store buffer to memory at any time.

\item[-] $\textit{Call}$ and $\textit{Return}$ rules: After a $\textit{call}$ action, the current
  process %transitions
  transits to $\textit{is}_{(\textit{m,a})}$. When the current process %comes to
  %transitions
  transits to $\textit{fs}_{(\textit{m,a})}$ it can launch a $\textit{return}$ action and %return to
  move to %$q_c$
  \redt{$\textit{in}_{\textit{clt}}$} of the most general client. %program.
\end{itemize}
%\gpnote{Where are \emph{is} and \emph{fs} defined?}
\begin{figure}[tbp]
%tau%
\[
\begin{array}{l c}
\bigfrac{ p(i)=(q_i,\redt{\textit{in}_{\textit{lib}}} %q'_c
) \quad q_i\ {\xrightarrow{\tau}}_{\mathcal{L}}\ q'_i } { ( p,d,u)\ {\xrightarrow{\tau(i)}}\ ( p[i:(q'_i,\redt{\textit{in}_{\textit{lib}}} %q'_c
)],d,u )} {\textit{Tau}}
\end{array}
\]

\vspace{-2pt}

%checkPID_suc
%\[
%  \begin{array}{l c}
%    \bigfrac{ p(i)=(q_i,q'_c) \quad q_i\ {\xrightarrow{\textit{checkPID}\_\textit{suc}(i)}}_{\mathcal{L}}\ q'_i } { ( p,d,u)\ {\xrightarrow{\textit{checkPID}(i)}}\ ( p[i:(q'_i,q'_c)],d,u )} {\textit{CheckPID}\_\textit{Suc}}
%  \end{array}
%\]

%\vspace{-2pt}

%checkPID_fail
%\[
%  \begin{array}{l c}
%    \bigfrac{ p(i)=(q_i,q'_c) \quad j \neq i \quad q_i\ {\xrightarrow{\textit{checkPID}\_\textit{fail}(j)}}_{\mathcal{L}}\ q'_i } { ( p,d,u)\ {\xrightarrow{\textit{checkPID}(i)}}\ ( p[i:(q'_i,q'_c)],d,u )} {\textit{CheckPID}\_\textit{Fail}}
%  \end{array}
%\]

%\vspace{-2pt}


%getPID%
%{\color {red}\[
%\begin{array}{l c}
%\bigfrac{ p(i)=(q_i,q'_c) \quad q_i\ {\xrightarrow{\textit{getPID}\Rightarrow i}}_{\mathcal{L}}\ q'_i } { %( p,d,u)\ {\xrightarrow{\textit{getPID}(i)}}\ ( p[i:(q'_i,q'_c)],d,u )} {\textit{GetPID}}
%\end{array}
%\]}

\vspace{-2pt}


%read%
\[
\begin{array}{l c}
\bigfrac{ p(i)=(q_i,\redt{\textit{in}_{\textit{lib}}} %q'_c
) \quad q_i\ {\xrightarrow{\textit{read}(x,a)}}_{\mathcal{L}}\ q'_i \quad \textit{lookup}(u,d,i,x)=a } { ( p,d,u)\ {\xrightarrow{\textit{read}(i,x,a)}}\
( p[i:(q'_i, \redt{\textit{in}_{\textit{lib}}} %q'_c
)],d,u ] )} {\textit{Read}}
\end{array}
\]

\vspace{-2pt}



%write%
\[
\begin{array}{l c}
\bigfrac{ p(i)=(q_i,\redt{\textit{in}_{\textit{lib}}} %q'_c
) \quad q_i\
  {\xrightarrow{\textit{write}(x,a)}}_{\mathcal{L}}\ q'_i \quad u(i)=l } { ( p,d,u)\ {\xrightarrow{\textit{write}(i,x,a)}}\
( p[i:(q'_i, \redt{\textit{in}_{\textit{lib}}} %q'_c
)],d,u[i:(x,a) \cdot l] )} {\textit{Write}}
\end{array}
\]

\vspace{-2pt}

%cas_suc%
\[
\begin{array}{l c}
\bigfrac{ p(i)=(q_i, \redt{\textit{in}_{\textit{lib}}} %q'_c
) \quad q_i\
  {\xrightarrow{\textit{cas}\_\textit{suc}(x,a,b)}}_{\mathcal{L}}\ q'_i \quad
  d(x)=a \quad u(i)=\epsilon } { ( p,d,u)\
{\xrightarrow{\textit{cas}(i,x,a,b)}}\
( p[i:(q'_i, \redt{\textit{in}_{\textit{lib}}} %q'_c
)],d[x:b],u)} {\textit{Cas}\_\textit{Suc}}

\end{array}
\]

\vspace{-2pt}

%cas_fail%
\[
\begin{array}{l c}
\bigfrac{ p(i)=(q_i, \redt{\textit{in}_{\textit{lib}}} %q'_c
) \quad q_i\
  {\xrightarrow{\textit{cas}\_\textit{fail}(x,a,b)}}_{\mathcal{L}}\ q'_i \quad
  d(x) \neq a \quad u(i)=\epsilon } { (p,d,u)\
  {\xrightarrow{\textit{cas}(i,x,a,b)}}\ ( p[i:(q'_i, \redt{\textit{in}_{\textit{lib}}} %q'_c
  )],d,u)} {\textit{Cas}\_\textit{Fail}}
\end{array}
\]

\vspace{-2pt}

%flush%
\[
\begin{array}{l c}
\bigfrac{ u(i)=l \cdot (x,a) } { ( p,d,u)\
{\xrightarrow{\textit{flush}(i,x,a)}}\
( p,d[x:a],u[i:l] )} {\textit{Flush}}
\end{array}
\]

\vspace{-2pt}


%call%
\[
\begin{array}{l c}
\bigfrac{ p(i)= \redt{\textit{in}_{\textit{clt}}} %q_c
} { (p,d,u)\
{\xrightarrow{\textit{call}(i,m,a)}}\
( p[ i: (\textit{is}_{(\textit{m,a})}, \redt{\textit{in}_{\textit{lib}}} %q'_c
) ],d,u)} {\textit{Call}}
\end{array}
\]

\vspace{-2pt}

%return%
\[
\begin{array}{l c}
\bigfrac{ p(i)=(\textit{fs}_{(\textit{m,a})}, \redt{\textit{in}_{\textit{lib}}} %q'_c
) } { (p,d,u)\
{\xrightarrow{\textit{return}(i,m,a)}}\
( p[i: \redt{\textit{in}_{\textit{clt}}} %q_c
],d,u )} {\textit{Return}}
\end{array}
\]

\vspace{-5pt}
\caption{Transition Relation $\rightarrow$}\label{fig:transition
relation te}

\vspace{-15pt}

\end{figure}

%\vspace{-10pt}

The initial configuration $\textit{InitConf} \in \textit{Conf}$ is a tuple $(p_{\textit{init}}, d_{\textit{init}}, u_{\textit{init}})$. Here $p_{\textit{init}}$ maps each process id to \redt{$\textit{in}_{\textit{clt}}$}. %$q_c$,
$d_{\textit{init}}$ is a valuation for memory locations in $\mathcal{X}_{\mathcal{L}}$, and $u_{\textit{init}}$ initializes each process with an empty buffer.
}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "CONCUR2021.tex"
%%% End: 