\section{Liveness}
\label{sec:liveness}

%In this section, we introduce definitions of lock-freedom, wait-freedom, deadlock-freedom, starvation-freedom and obstruction-freedom \cite{DBLP:books/daglib/0020056,DBLP:conf/concur/LiangHFS13}. %, as well as the
%definition of %bounded wait-freedom \cite{DBLP:journals/jucs/BritM96,DBLP:books/daglib/0020056}.
%{\color {red}$k$-bounded wait-freedom \cite{DBLP:conf/pldi/PetrankMS09}.}

%Intuitively, lock-freedom requires that at each point in time there is at least one method that should return in a finite number of steps. Wait-freedom requires that each call to a library method returns in a finite number of steps. Deadlock-freedom and starvation-freedom can be obtained from lock-freedom and wait-freedom respectively by adding assumptions about the fair scheduling of executions. Obstruction-freedom guarantees that each method can return in a finite number of steps if it executes in isolation. Given a bound $k$, bounded wait-freedom requires that each call to a library method returns in no more than $k$ steps.
%\redt{Intuitively, clients using a wait-free library find that each method call returns in finite steps. Clients using a lock-free library find that there will always be some method return after the whole system executes for sufficient number of steps, while it is possible that method on some process never return. Deadlock-freedom and Starvation-freedom requires each fair execution satisfies lock-freedom and wait-freedom, respectively. Clients using a obstruction-free library find that each method call is guaranteed to return in finite number of steps when executed in isolation.}
\forget{
Below we give an intuitive descriptions of the properties listed above:
\begin{itemize}
\item Lock-freedom requires that some library method call returns whenever the concurrent system
  executes for a sufficient number of steps.
\item Wait-freedom requires that each library method call returns whenever the thread executing it
  is scheduled for a sufficient number of steps.
\item Deadlock-freedom requires that every fair execution satisfies lock-freedom.
\item Starvation-freedom requires that every fair execution satisfies wait-freedom.
\item Obstruction-freedom requires that each library method call returns in a finite number of steps
  when executed in isolation.
\end{itemize}
}


% {\color {red}The intuitive explanation of above liveness properties are as follows: Lock-freedom requires that some call to library method should return if the concurrent system executes for a sufficient number of steps, while wait-freedom requires that each call to a library method should return if it is scheduled for a sufficient number of steps. Deadlock-freedom (resp., starvation-freedom) %can be obtained from lock-freedom (resp., wait-freedom) by considering only executions of fair scheduling.
% requires each fair execution to satisfy lock-freedom (resp., wait-freedom).
% Obstruction-freedom requires that each call to library method should return in finite steps if it executes in isolation.} %$k$-bounded wait-freedom requires that each call to a library method should return within $k$ steps of the calling process.

%In this section, we introduce definitions of lock-freedom, wait-freedom, deadlock-freedom, starvation-freedom and obstruction-freedom \cite{DBLP:books/daglib/0020056,DBLP:conf/concur/LiangHFS13}.
%Let us now introduce their formal definitions.
We use $T_{\omega}(\llbracket \mathcal{L}, n \rrbracket)$ to denote all %finite or
infinite traces of the concurrent system $\llbracket \mathcal{L}, n \rrbracket$.
Given an execution $t \in T_{\omega}(\llbracket \mathcal{L}, n \rrbracket)$, %let $t(i,j)$ denote the substring $t(i) \cdot \ldots \cdot t(j)$ of $t$.
we say a call action $t(i)$ matches a return action $t(j)$ with $i<j$, if the two actions are by the
same process, and there are no call or return actions by the same process in-between.
%{\color{orange}
Here we assume that %there are no recursive methods, and also we assume that
methods do not call other methods. %}
%\gpnote{Shouldn't we require that there are not call or return actions of the
%  same process in-between?}
Let $\textit{pend}\_\textit{inv}(t)$ denote the set of pending call actions of
$t$, in other words, call actions of $t$ with no matching return action in $t$.

We define the following predicates borrowed from
\cite{DBLP:conf/concur/LiangHFS13}. Since we do not consider aborts, and we do
not consider termination markers, %with slight modifications.
we slightly modify the predicates definition of
\cite{DBLP:conf/concur/LiangHFS13} by consider only infinite executions. Given
an infinite execution $t \in T_{\omega}(\llbracket \mathcal{L},n \rrbracket)$:
\begin{itemize}
\item[-] $\textit{prog-t}(t)$: This predicate holds when every method call in $t$ eventually
  returns. Formally, for each index $i$ and action $e$, if $e \in
  \textit{pend}\_\textit{inv}(t(1,i))$, %then
  there exists $j>i$, such that $t(j)$ matches $e$. %in $t$.

\item[-] $\textit{prog-s}(t)$: This predicate holds when %it is always true that if there are pending method calls, at least one method returns in the future.
    there is always some method return action happens in the future if the system executes for a sufficient number of steps. Formally, for each index $i$ and action
  $e$, if $e \in \textit{pend}\_\textit{inv}(t(1,i))$ holds, then there exists $j>i$, such that
  $t(j)$ is a return action.

\item[-] $\textit{sched}(t)$: This predicate holds if %there are no pending invocations of library methods in $t$ (e.g. if $t$ is finite), or if
  $t$ is an infinite trace with pending call actions, %pending method
  %invocations,
  and at least one of the processes with a pending call action %pending invocations
  is scheduled infinitely many
  times. Formally, if $\vert t \vert = \omega$ and $\textit{pend}\_\textit{inv}(t) \neq \emptyset$,
  then there exists $e \in \textit{pend}\_\textit{inv}(t)$, such that $\vert t \uparrow_{pid(e)}
  \vert = \omega$. Here $t \uparrow_{pid(e)}$ represents the projection of $t$ into the actions of the process of $e$.

\item[-] $\textit{fair}(t)$: This predicate describing fair interleavings requires that if $t$ is an
  infinite execution, then each %non-terminated
  process is scheduled infinitely many times. Formally,
  if $\vert t \vert = \omega$, then for each process $proc$ %which is not ruminated
  in $t$,
  \mbox{$\vert t \uparrow_{proc} \vert$} \mbox{$= \omega$}. Here $t \uparrow_{proc}$ represents the
  projection of $t$ into actions of process $proc$.

\item[-] $\textit{iso}(t)$: This predicate requires that if $t$ is an infinite execution, eventually
  only one process is scheduled. Formally, if $\vert t \vert = \omega$, then there exists index $i$
  and process $proc$, such that for each $j>i$, $t(j)$ is an action of process $proc$.
\end{itemize}

With these predicates, we can present the formal notions of lock-freedom, wait-freedom, deadlock-freedom, starvation-freedom and obstruction-freedom of \cite{DBLP:conf/concur/LiangHFS13}. %{\color {red}and $k$-bounded wait-freedom of \cite{DBLP:conf/pldi/PetrankMS09}}.

\begin{definition}\label{def:lock-free, wait-free, deadlock-free, starvation-free and obstruction-free}
Given an execution $t \in T_{\omega}(\llbracket \mathcal{L},n \rrbracket)$:
\begin{itemize}
\item[-] $t$ satisfies lock-freedom whenever: $\textit{sched}(t) \Rightarrow \textit{prog-s}(t)$,

\item[-] $t$ satisfies wait-freedom whenever: $\textit{sched}(t) \Rightarrow \textit{prog-t}(t)$,

\item[-] $t$ satisfies deadlock-freedom whenever: $\textit{fair}(t) \Rightarrow \textit{prog-s}(t)$,

\item[-] $t$ satisfies starvation-freedom whenever: $\textit{fair}(t) \Rightarrow \textit{prog-t}(t)$,

\item[-] $t$ satisfies obstruction-freedom whenever: $\textit{sched}(t) \wedge \textit{iso}(t) \Rightarrow \textit{prog-s}(t)$
\end{itemize}

For library $\mathcal{L}$, we parameterize the definitions above over $n$ processes, and we define
their satisfaction requiring that each execution of $\llbracket \mathcal{L}, n \rrbracket$ satisfies
the corresponding liveness property.
\end{definition}

\forget{
The definition of bounded wait-freedom is as follows:

\begin{definition}\label{def:bounded wait-freedom}
Given an execution $t \in T(\llbracket \mathcal{L},n \rrbracket)$ and a bound $k$, $t$ satisfies bounded wait-freedom, if $t$ satisfies wait-freedom, and for each call action $t(i)$ of some process $proc$, there exists indexes $j \leq  k  +  1$ and $i'$, such that the index of $t(i)$ in $t \uparrow_{proc}$ is $i'$, and $(t \uparrow_{proc})(i'+j)$ is a matching return action (if $\vert t  \uparrow_{proc}  \vert \geq i'  +  k  +  1$).
Given a bound $k$, $\mathcal{L}$ satisfies bounded wait-freedom for $n$ processes, if each execution of $\llbracket \mathcal{L}, n \rrbracket$ satisfies bounded wait-freedom.
\end{definition}
}

%Let us introduce the notion of bounded wait-freedom and population-oblivious wait-freedom of \cite{DBLP:books/daglib/0020056}.
%An execution $t$ satisfies bounded wait-freedom \cite{DBLP:books/daglib/0020056}, if there is a bound on the number of steps a method call can take.
%An execution $t$ satisfies population-oblivious wait-freedom \cite{DBLP:books/daglib/0020056}, if it satisfies bounded wait-freedom, and the bound does not rely on the processes number.
%{\color {red}We define a notion called $k$-bounded wait-freedom,} which requires wait-freedom as well as each method should return within $k$ steps of the calling process.
%To verify bounded versions of wait-freedom, we define a notion called $k$-bounded wait-freedom.
%Let $t \uparrow_{pid}$ denotes the projection of execution $t$ into actions of process $pid$.
%An execution $t$ satisfies $k$-bounded wait-freedom, if it satisfies wait-freedom, and each method will return in $k$ steps of the calling process.
%Formally, $t$ satisfies $k$-bounded wait-freedom, if it satisfies wait-freedom, and for each call action $t(i)$ of process $pid$, there exists $j<k$ and $i'$, such that the index of $t(i)$ in $t \uparrow_{pid}$ is $i'$, and $l(i'+j)$ is a matching return action.
%$\llbracket \mathcal{L}, n \rrbracket$ satisfies $k$-bounded wait-freedom, if each of its execution satisfies $k$-bounded wait-freedom.


%Note that lock-freedom and wait-freedom requires fair scheduling, while obstruction-freedom does not require fair scheduling.

%TSO memory model associate with each process an FIFO buffer. One reasonable assumption is that in an infinite execution, if process $p$ do not launch new command after some time point, then its buffer should be eventually cleared. Based on this assumption, we propose a sub-notion of obstruction-freedom called fair-obstruction-freedom. An infinite execution $t$ is fair-obstruction-freedom, if it satisfies $isolate(t,p) \Rightarrow prog(t,p) \wedge fairBuf(t)$. Here predicate $fairBuf(t)$ holds, if for each process $p'$, either $\vert t \uparrow_{write(p')} \vert$ is infinite, or $\vert t \uparrow_{write(p')} \vert$ is finite and $\vert t \uparrow_{write(p')} \vert = \vert t \uparrow_{flush(p')} \vert$.

\forget{
Petrank \emph{et al.} \cite{DBLP:conf/pldi/PetrankMS09} demonstrate how to formalize lock-freedom, wait-freedom and obstruction-freedom as LTL formulas.
In Appendix \ref{sec:appendix discussion of section sec:liveness} we state how to formalize deadlock-freedom and starvation-freedom for $n$ processes as CTL$^*$ formulas.
As explained in Section \ref{subsec:equivlant characterization of obstruction-freedom}, %Since
concurrent system with $n$ processes on SC can be expressed as finite state LTS, and LTL and CTL$^*$ model checking is decidable %in polynomial space
\cite{DBLP:reference/mc/2018}, we thus obtain that the above five liveness properties are decidable for SC.
}

Petrank \emph{et al.} \cite{DBLP:conf/pldi/PetrankMS09} demonstrate how to formalize lock-freedom, wait-freedom and obstruction-freedom as LTL formulas.
It remains to show that deadlock-freedom and starvation-freedom for $n$ processes can be formalized
as %LTL
CTL$^*$ formulas.
Let $A$, $F$ and $G$ be the standard modalities in CTL$^*$.
%\redt{Let $A$ be the path quantifier of ``for all computation paths'', $F$ be the temporal operator of ``in the future'', and $G$ be the temporal operator of ``globally'' in CTL$^*$.}
Let $P_{\textit{ret}}$ be a predicate identifying return actions, %;
$P_{proc}$ be a
predicate identifying actions of process $proc$, and $P_{(r,proc)}$ %a the
the predicate identifying process $proc$'s
return actions. We define $\textit{fair}=(GF\ P_1) \wedge \ldots \wedge (GF\ P_n)$ to describe fair
executions of $n$ processes. Then, deadlock-freedom can be defined as the %LTL
CTL$^*$ formula $A (\textit{fair}
\rightarrow GF\ P_{\textit{ret}})$, and starvation-freedom can be defined as the %LTL
CTL$^*$ formula $A (\textit{fair} \rightarrow GF\ P_{(r,1)} \wedge \ldots \wedge GF\ P_{(r,n)})$.

As explained in Section \ref{subsec:equivlant characterization of obstruction-freedom}, %Since
concurrent system with $n$ processes on SC can be expressed as finite state LTS, and LTL and CTL$^*$ model checking is decidable %in polynomial space
\cite{DBLP:reference/mc/2018}, we can obtain that the above five liveness properties are decidable for SC.


%In Appendix \ref{sec:encoding liveness as temporal logic formaulas} we show that deadlock-freedom and starvation-freedom for $n$ processes can also be %expressed
%formalized as LTL formulas.}

%In Appendix \ref{sec:encoding liveness as temporal logic formaulas} we show that all the six liveness properties of this section for $n$ processes can be expressed as LTL formulas.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "FSTTCS2021.tex"
%%% End: 