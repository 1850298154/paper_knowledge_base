\section{Related Work}

Task-parallel programming is prevalent in a variety of languages and
libraries.
%
Multilisp~\cite{Multilisp} is one of the earliest languages with
futures, a mechanism for parallel execution of functional code.
%
Fork-join parallelism is employed in Cilk~\cite{Cilk}, and the more
general async-finish with futures model was introduced in
X10~\cite{X10}.
%
Habanero-Java~\cite{HJ} modernized X10 as an extension to Java and,
later, as a Java library, HJlib~\cite{HJlib}; this language
incorporates additional synchronization primitives, such as the
phaser~\cite{Phaser} and the data-driven future~\cite{DDF}, which is a
promise-like mechanism.
%
Many other languages, libraries, and extensions include spawning and
synchronizing facilities, whether for threads or lightweight tasks,
including Chapel~\cite{Chapel}, Fortress~\cite{Fortress},
OpenMP~\cite{OpenMP}, Intel Threading Building Blocks~\cite{TBB},
Java~\cite{JCP}, C++17~\cite{Cpp17}, and Scala~\cite{ScalaFutures}.
%

The promise, as we define it, can be traced back to the I-structures
of the Id language~\cite{IStructures}, which are also susceptible to
deadlock.
%
Cells of data in an I-structure are uninitialized when allocated, may
be written to at most once, and support a read operation that blocks
until the data is available.

The classic definition of a deadlock is found in Isloor and
Marsland~\cite{Deadlock}, which is primarily concerned with concurrent
allocation of limited resources.
%
Solutions in this domain fall into the three categories of Coffman:
static prevention, run-time detection, and run-time
avoidance~\cite{Coffman71}.

We consider logical deadlocks, which are distinct from resource
deadlocks in that there is an unresolvable cyclic dependence among
computational results.
%
Solutions in the logical deadlock domain include techniques that
dynamically detect cycles~\cite{Luecke03, Krammer04, Krammer08,
  Hilbrich09, Vo11, Hilbrich12}, that raise alarms upon the formation
or possible formation of cycles~\cite{Agarwal06, Boudol09, Gerakios11,
  Armus, KJ, TJ}, that statically check for cycles through
analysis~\cite{Williams05, Naik09, Ng16} or through type
systems~\cite{Boyapati02,Vasconcelos09}, or that preclude cycles by
carefully limiting the blocking synchronization semantics available to
the programmer, either statically or dynamically~\cite{X10, Phaser,
  HJ, KJ, TJ}.
%
The present work includes a dynamic, precise cycle detection
algorithm, enabled only by the introduction of a structured ownership
semantics on the otherwise unrestricted promise primitive.

Futures are a special case of promises where each one is bound to a
task whose return value is automatically put into the promise.
%
Transitive Joins~\cite{TJ} and its predecessor, Known Joins~\cite{KJ},
are policies with runtime algorithms for deadlock detection on
futures. They are, in general, not applicable to promises. These two
techniques impose additional structure on the synchronization pattern
by limiting the set of futures that a given task may await at any
given time.

Recent work identifies the superior flexibility of promises over
futures with the problematic loss of a guarantee that they will be
fulfilled and develops a \emph{forward} construct as a
middle-ground~\cite{Forward}. Forwarding can be viewed in terms of
delegating promise ownership, but it is restricted in that 1) it moves
only a single promise into a new task, and 2) in particular, it moves
only the implicit promise that is used to retrieve a task's return
value. In terms of futures, forwarding amounts to re-binding a future
to new task.

Other synchronization constructs benefit from similar annotations to
the one we have proposed for promises. This includes event-driven
programming models where events have similar semantics to that of promises.
JavaScript, though a single-threaded language, still uses an
asynchronous task model to schedule callbacks on an event
loop~\cite{JavaScriptAsync}, and could benefit from our approach.
Likewise, our approach is directly applicable to multithreaded
execution models, such as Concurrent Collections~\cite{CnC} and the Open
Community Runtime~\cite{OCR}, that use event-driven execution as a fundamental
primitive.
%
As another example, the MPI blocking receive primitive must name the sending
task; from this information a waits-for graph for deadlock detection
can be directly constructed~\cite{Hilbrich09}.  In addition,
nonblocking communications in MPI
use {\tt MPI\_Request} objects in a manner similar to promises, and
the {\tt MPI\_Wait} operation akin to the get operation on promises.

Languages with barriers and phasers sometimes require the
participating tasks to \emph{register} with the
construct~\cite{Phaser}.
%
Notably, this kind of registration is absent from the Java API, which
is problematic for the Armus deadlock tool~\cite{Armus}. In that work,
registration annotations had to be added to the Java benchmarks in
order to apply the Armus methodology.

In this work, we considered programs which only use promises for
blocking synchronization, and we constrained ownership transfer to
occur only when a task is spawned.
%
Since a promise can have multiple readers or no readers at all, it is
not possible in principle to use one promise to synchronize the
ownership hand-off of a second promise between two existing tasks. We
cannot guarantee that the receiving task exists and is unique.
%
In future work, one could consider a slightly higher abstraction in
the form of a pair of promises acting like a rendezvous, which is a
primitive in languages like Ada and Concurrent
C~\cite{AdaConcurrentC}. Such a synchronization pattern could be
leveraged to hand off promise ownership since there would be a
guaranteed single receiving task.

The Rust language incorporates affine types in its move semantics to
ensure that certain objects have at most one extant reference at all
times~\cite{Rust}. The movement of promise ownership from one task to
another and the obligation to fulfill each promise exactly once may be
expressible at compile time through the use of a linear type system,
which restricts references to exactly one instance.
