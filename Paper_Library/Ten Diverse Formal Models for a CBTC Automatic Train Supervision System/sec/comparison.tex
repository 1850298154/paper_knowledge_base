\section{Commonalities and Differences}
\label{sec:comparison}

\subsection{The basic blackboard model}

We want to build a model that describes all the possible evolutions of the system composed by the 8 trains, with purpose of verifying the correctness of the A0, ..., A7  and B0, ..., B7 tables that control the non saturation of the sections A and B, and the correctness of the assumption that the A and B sections are the only zones where a deadlock might occur.
The design skeleton we have in mind is that of a blackboard model, where a global space of common variables is read and updated by a set of atomic transformation operations. 
An atomic system evolution corresponds to a one-step movement of one train in the yard, which can occur when the next endpoint is free and when the move does not saturate neither the A section, nor the B section. 
We have encoded the above simple skeleton design using notations supported by 10 verification frameworks, namely UMC, Promela/SPIN, NuSMV/nuXmv, mCRL2, CPN Tools, FDR4, CADP, TLA+, UPPAAL and ProB. 
Within the context of this paper, our goal is to provide some feedback on the differences and traps that should be tackled when changing the reference frameworks, and the commonalities that would allow a simple translation from one framework to another.
Each framework surely has its own typical set of features that might lead to the best modelling and verification of a system, but, in this work, we are not interested in comparing the best way in which all the 10 frameworks could model the system. Instead, we are interested in seeing if, and to which extent, our basic design skeleton could be fitted with minimal transformations in all the frameworks taken into consideration.

In the following subsections we summarise some of the aspects that appear to characterise the differences of the various frameworks as evidenced by our specification problem. These observations can support the reader in making sense of the different models that are reported in Appendix A\footnote{In Appendix A we report solely the sequential cases -- according to the classification in Sect.~\ref{sec:structure} -- which are the most representative for our design.}, and attached to the current paper. 
More specifically, for each framework, we provide one or more model variants. The variants represent different modelling styles, according to the classification provided in Sect.~\ref{sec:structure}. 
In the case of CPN Tools, the different variants are associated to models with a different number of trains. Indeed, in our experiments, presented in~\cite{mazzanti2018towards,isola}, CPN Tools was not able to verify the case with eight trains, and models with a lower number or trains were tested. Table~\ref{tab:models} provides a brief description of the different variants considered, with the associated file names.

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[]
\centering
\caption{Different models developed with associated frameworks.}
\label{tab:models}
\begin{footnotesize}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Framework}                    & \textbf{File Name}                   & \textbf{Description}                         \\ \hline \hline
\multirow{2}{*}{\textbf{CADP}}   & cadp\_oneway8par.lnt                 & Parallel without shared memory               \\ \cline{2-3} 
                                 & cadp\_oneway8seq.lnt                 & Sequential                                   \\ \hline
\textbf{CPN Tools}               & cpn-oneway$<$X$>$.xml & Parallel without shared memory with X trains \\ \hline
\multirow{2}{*}{\textbf{FDR4}}   & fdr4\_oneway8par.txt                 & Parallel without shared memory               \\ \cline{2-3} 
                                 & fdr4\_oneway8seq.txt                 & Sequential                                   \\ \hline
\multirow{2}{*}{\textbf{mCRL2}}  & mcrl2\_oneway8par.txt                & Parallel without shared memory               \\ \cline{2-3} 
                                 & mcrl2\_oneway8seq.txt                & Sequential                                   \\ \hline
\textbf{ProB}                    & prob\_oneway8seq.mch                 & Sequential                                   \\ \hline
\textbf{NuSMV/nuXmv}             & smv\_oneway8-SM.smv                  & Sequential                                   \\ \hline
\textbf{SPIN}                    & spin\_oneway8.pml                    & Sequential                                   \\ \hline
\textbf{TLA+}                    & tla\_oneway8.txt                     & Sequential                                   \\ \hline
\textbf{UMC}                     & umc\_oneway8seq.txt                  & Sequential                                   \\ \hline
\multirow{2}{*}{\textbf{UPPAAL}} & uppaal-oneway8par.ta                 & Parallel with shared memory                  \\ \cline{2-3} 
                                 & uppaal-oneway8seq.ta                 & Sequential                                   \\ \hline
\end{tabular}
\end{footnotesize}
\end{table}

\subsection{System Design Structure}
\label{sec:structure}

The frameworks taken into account allow different kinds of model structures, which can be seen in our variants. 

\begin{description}
\item[Sequential]
With the sequential design structure the global system status is read and updated by a single sequential, nondeterministic process. This is the case that more directly reflects our initial design skeleton, and this structure has been modelled in all the considered frameworks\footnote{mcrl2\_oneway8seq.ta, cadp\_oneway8seq.lnt, fdr4\_oneway8seq.csp, umc\_oneway8seq.txt, spin\_oneway8.pml, prob\_oneway8.mch, tla_oneway8.txt, smv\_oneway8-SM.smv}, with the exception of CPN Tools. Indeed, this modelling style can be reproduced with CPN Tools, but it is not in line with the typical use of Petri Nets.
%since the Petri Nets formalism does not support this modelling style.

\item[Parallel without Shared Memory] With this design structure we indicate the case in which different parallel process interact among themselves in the absence of a common shared memory that could be directly read and updated by the processes. 
%In general, concurrent frameworks allow the user to design a system as a collection of interacting entities, but without allowing the presence of some shared memory that could be directly read and updated by the entities themselves. 
This is in general the case of concurrent frameworks, such as UMC, CPN, FDR4, CADP, mCRL2, where sets of processes (or a network layout in the case of Petri Nets) are used to model the system, and where a single entity might model the evolutions in time of a specific component of the system status (e.g., a variable). This is not our main reference scenario, however in the case of mCRL2, CADP, FDR4, CPN Tools we show alternative modelling examples that follow this design structure\footnote{mcrl2\_oneway8par.ta, cadp\_oneway8par.lnt, fdr4\_oneway8par.csp, cpn\_oneway8.xml, cpn\_oneway6-nocol.xml}.

\item[Parallel with Shared Memory]  
With this design structure a set of parallel processes share a common memory space, and, at the same time, may interact through inter-process communication. 
SPIN and UPPAAL are the only frameworks that allow the user to design a system in this way. An example of this model structure has been shown only in the case of UPPAAL\footnote{uppal-oneway8seq.ta}. 
\end {description}

subsection{Language Style}

Another evident difference among the various frameworks, is the overall style of the language used to specify the system.
For example, if we consider the way in which the transition relation (i.e., the system evolutions) are described, we can observe that three main approaches are followed by our considered frameworks. These three language styles can be qualified as \emph{imperative}, \emph{logical} and \emph{algebraic}, and are exemplified below with small fragments of code in the style of CADP-LNT~\cite{lnt}\footnote{ LTN is one of the languages supported by CADP, and is the language chosen for our experiment.},
%When referring to the language used, CADP is referred as CADP-LNT, since LNT is the language adopted in our case.}, 
TLA+ and FDR4, respectively.

\vspace{-3 mm}
\begin{alltt}
{\footnotesize 
if P0<6 then           (P0 < 6) &            System(P0,RA) =
   P0 := P0+1;         (P0' = P0+1) &          (P0 <6)  -> 
   RA := RA+A0[P0];    (RA' = RA+A0[P0+1])     System(P0+1,RA+A0[P0+1])
end;
}
\end{alltt}
\vspace{-3 mm}

In spite of the apparent difference, if the state transformation to be carried out during a system evolution is simple (like it happens in our case), the three styles are roughly equivalent, and translation from one style to the other can be performed with limited effort. 
%Indeed, in our case, the models developed 
%In the case of ProB imperative, algebraic (CSP from FDR4), logical notations (TLA+) (the three notations accepted by ProB) are internally translated into a prolog program.

\subsection{Arrays and Indexing}

In our example we do not have the need to use sophisticated data structures, and our design skeleton is just based on integer values and fixed-size tables of numbers.
Sometimes, e.g., in the case of UMC, SPIN, NuSMV/nuXmv, CADP-LNT, UPPAAL, TLA+, array-like types and indexing operations are natively supported by the specification language; other times, e.g., in the case of CPN Tools, FDR4, mCRL2, arrays should be represented as functions, or sequences, or lists, and the indexing operations possibly manually encoded as custom recursive functions. For example, in the case of FDR4 we have:

\vspace{-3 mm}
\begin{alltt}
{\footnotesize 
M0 = <1,9,10,13,15,20,23>  -- list of endpoint for the mission of train0

select_item(list,index) =    -- item selection, given an index 
  if index==0 then           --  (assuming index in the appropriate range)
     head(list) 
  else 
    select_item(tail(list),index-1);
}
\end{alltt}
\vspace{-3 mm}
  
\subsection{System Initialisation}

The different ways in which the frameworks treat system initialisation point out a difference that might trick an inexperienced designer.
Three different approaches can be recognised when a state variable in defined by the model, but not explicitly initialised at system startup.

  
\begin{description}
\item[Default Value]  
The uninitialised variables might get some default initial value (typically 0 for integers). This is the approach found in UMC, SPIN, UPPAAL.
\item[Error]   
The situation can be statically recognised as a design error, and notified to the designer. 
This is the approach followed by TLA+, ProB, CPN Tools, FDR4, mCRL2, CADP-LNT.
\item[Nondeterministic Assignment]  
The not explicitly initialised variable may nondeterministically get any of the possible values allowed by its type. This approach has been encountered only in in Nu\-SMV/\-nu\-Xmv. From one side this choice provides a powerful and flexible way to specify a rich set of possible system initial values, from the other side it might trick an inexperienced designer wrongly thinking that a classical default value (like 0) is used instead.
\end{description}
 
\subsection{The Transition Relation}

In all the considered  frameworks the transition relation is defined by rules that have the form:  \emph{guard-condition / state-transformation-effects}.
A possible question is what happens to the variables that are not explicitly modified by the \emph{state-transformation-effects}.
The situation is similar to the initialisation issue previously seen. Also in this case we have three different approaches:

\begin{description}
\item[Previous Value]   
The not explicitly assigned state variables preserve their previous value.
This is the approach followed by CPN, UPPAAL, FDR4, mCRL2, SPIN, UMC, ProB, CADP-LNT.
\item[Default Value]  
The not explicitly assigned state variables get a default \emph{null} value. This is what happens in the case of TLA+.
\item[Nondeterministic Assignment] 
The not explicitly assigned variable may nondeterministically get any of the possible values allowed by its type. This is what happens in the NuSMV/nuXmv case.
\end{description}

The difference among the three classes is evident if we compare the fragments of  \emph{state-transformation-effects} as they occur in CADP-LNT, TLA+ and NuSMV/nuXmv:

\vspace{-3 mm}
\begin{alltt}
{\footnotesize 
       P0 := P0+1;       (P0' = P0+1) &           next(P0) in P0+1 &
                         UNCHANGED<<P1,..P7>>     next(P1) in P1 &
                                                  ...
                                                  next(P7) in P7 
}
\end{alltt}
\vspace{-3 mm}

While with CADP-LNT it is not needed to make explicit that {\tt \footnotesize P1 ... P7} do not change their value, in TLA+ we need to use the keyword {\tt \footnotesize UNCHANGED}, 
and in NuSMV/nuXmv we have to explicitly state, for each variable, that the next value is equal to the one at the previous execution step.

Another relevant difference among the various frameworks is whether they allow the transition relation to be only \textit{partially} defined, i.e., 
are certain inputs and certain states allowed not to trigger a system evolution?

In our problem this situation actually occurs. For example, when a train cannot proceed because its next endpoint is occupied by another train, the rule describing the train progress cannot be applied. In all frameworks, with the exception of NuSMV/nuXmv, this does not represent a problem. It simply means that from such a system configuration state there is no outgoing edge corresponding to the movement of that train.

In the case of NuSMV/nuXmv instead the transition relation must be a \textit{total} function. This means that if a certain state configuration and a certain system input does not trigger an actual system evolution, we should equally explicitly state that the next system state is unchanged. If we fail to explicitly state that, the consequence is that the next state can become any state where all the system state variables nondeterministically get any of the values allowed by their type.
Notice that in this way we are introducing self loops in many states of the graph describing the system behaviour, and this has a certain impact on the way in which the system properties could be stated and verified. For example,  the user might be constrained to specify fairness constraints, or avoid the use of LTL formulas, or avoid CTL formulas like \emph{AF$<$statepredicate$>$}.
Indeed the verification approach of NuSMV always takes into consideration only infinite -- possibly fair, if requested -- traces\footnote{when using the \texttt{-bmc} option the behaviour might be different}.

\subsection{ Verification Techniques}

In our case the property we want to verify is that \textit{for all possible executions all the trains eventually complete their missions}. 
This property can be easily specified and verified in all the considered frameworks. 
However each framework provides original advanced verification features not supported by other frameworks. 
The possibility to translate a specification from a formalism to another might lead to several advantages:

\begin{itemize}
\item  We can increase the confidence of the verification results, given that none of the analysed frameworks are qualified at the highest integrity levels usually required by safety critical standards.
\item  We can exploit the specific strong points of more than one framework (e.g. the friendliness of a user interface, the ability to scale well, the possibility of generating program code or performing model based testing). 
\item We can verify a wider class of properties. For example, by importing a FDR4 model into ProB we can verify also LTL/CTL properties, by translating a model into UPPAAL we can introduce and verify further time related aspects, and so on. Table~\ref{tab:features} summarises the basic verification features that the considered frameworks make available.

\end{itemize}


\begin{table}[!h]
\centering
\caption{Verification features supported by the various frameworks}
\label{tab:features}
\begin{footnotesize}
\begin{tabular}{|c|l|}
\hline
\textbf{Framework}   & \textbf{Supported Verification Techniques}                       \\ \hline  \hline
\textbf{UMC}         & model checking CTL-like, state-event based logics                \\ \hline
\textbf{SPIN}        & model checking LTL, fairness requirements                        \\ \hline
\textbf{NuSMV/nuXMV} & LTL, CTL, PSL~\cite{psl}, SMT model checking, fairness requirements         \\ \hline
\textbf{CADP}        & MCL~\cite{mcl}, Parametric Mu-Calculus model checking, equivalence checking \\ \hline
\textbf{UPPAAL}      & MITL~\cite{mitl}, time-related, and probability related properties            \\ \hline
\textbf{TLA+}        & LTL, Theorem Proving, Proof Validations                          \\ \hline
\textbf{ProB}        & LTL, CTL model checking, constraints based checking  \\ \hline
\textbf{mCRL2}       & Parametric Mu Calculus model checking, equivalence checking \\ \hline
\textbf{FDR4}        & Refinement Checking, fairness requirements                       \\ \hline
\textbf{CPN}         & CTL, custom ML properties                                        \\ \hline
\end{tabular}
\end{footnotesize}
\end{table}

\subsection{Some Performance Data}

It is not a goal of our paper to make a comparative evaluation of the various frameworks in terms of scalability or performance. 
Nevertheless a summary of the  experienced times  when evaluating the property that \emph{for all possible executions all the trains eventually complete their missions} might still be a useful approximate indication of the impact of a certain system design approach / formal verification technique  in terms of performance.
The verification times presented in Table~\ref{tab:times} are expressed as ranges because they actually depend of the specific design approach adopted, on the specific formulas being evaluated, and on the specific options used during the tool execution. We refer to~\cite{mazzanti2018towards} for additional details.

\begin{table}[]
\centering
\caption{Indicative Summary of Evaluation Times}
\label{tab:times}
\begin{footnotesize}
\begin{tabular}{|c|l|}
\hline
\textbf{Framework}   & \textbf{Range of evalution times}        \\ \hline \hline
\textbf{UMC}         & 38 - 86 seconds                          \\ \hline
\textbf{SPIN}        & 13 - 47 seconds                          \\ \hline
\textbf{NuSMV/nuXMV} & 2.9 - 43 seconds                         \\ \hline
\textbf{CADP}        & 29 seconds                               \\ \hline
\textbf{UPPAAL}      & 16 seconds                               \\ \hline
\textbf{TLA+}        & 3 minutes                                \\ \hline
\textbf{ProB}        & 32 minutes                               \\ \hline
\textbf{mCRL2}       & 2 minutes -19 minutes                              \\ \hline
\textbf{FDR4}        & 15 seconds - 20 minutes                  \\ \hline
\textbf{CPN}         & unable to deal with the state-space size \\ \hline
\end{tabular}
\end{footnotesize}
\end{table}




