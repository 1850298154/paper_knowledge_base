\section{Background} 
% and Related Work}
\label{sec:background}
We start with discussion on motion planning (Sec.~\ref{subsec:mp}). We then discuss fundamentals of first-order logical models (Sec.~\ref{subsec:first_order}) and abstractions (Sec.~\ref{subsec:abstraction}). Sec.~\ref{subsec:ssp} discusses stochastic shortest path problems in the context of our approach. 
% s the definition of classical planning and discuss a few of the many approaches that perform classical planning. Sections \ref{sec:ssp} and \ref{sec:mp} discuss the stochastic variant of the planning problem and motion planning briefly. Lastly, section \ref{sec:itmp} discusses the recent work done related to the work presented in the paper.


% Combined task and motion planning has achieved a lot of research focus in recent years, though most of the works are focused on solving combined task and motion planning problem in deterministic settings. 

% \subsection{Planning under Uncertainty}


\subsection{Motion Planning}
\label{subsec:mp}

Let $\X = \X_\text{free} \cup \X_\text{obs} $ be the configuration space~\cite{Lav06} of a given robot. Here $\X_\text{free}$ represents the set of configurations where the robot is not in collision with any obstacle and $\X_\text{obs}$ represents configurations in collision with an obstacle. Let $x_i \in \X_\text{free}$ and $x_g \in \X_\text{free}$ be the initial and goal configurations of the robot. A motion planning problem is defined as follows:
\begin{definition}

    A \textbf{motion planning problem} is a $4$-tuple $\langle \X, f, x_o, x_g \rangle$ where, 
    \begin{itemize}
        \item $\X$ is the space of all possible configurations (a.k.a \emph{configuration space or C-space}). \item $x_i$ is the initial configuration.
        \item $x_g$ is the goal configuration. 
        \item $f: \X \rightarrow \{0,1\}$ determines whether a pose $x \in \X$ is in a collision or not. $f(x) = 0$ if the configuration $x$ is in collision ($x \in \X_\text{free}$).  
    \end{itemize}
\end{definition}


A solution to a motion planning problem is a collision-free trajectory $t: [0,1] \rightarrow \X$ such that $t(0) = x_i$ and $t(1) = x_g$. A trajectory is collision-free if $f(x) = 1$ for every configuration in the trajectory.

\subsection{First-Order Logical Models}
\label{subsec:first_order}
We use first-order logic to express models for planning problems.  Let $\tau_R$ be a type of variables that represent vectors of continuous real values and $\tau_O$ be a type of variables that represent names of the objects in the environment and symbolic references for the variables of the type $\tau_R$. Let $\U$ be the universe consisting of object names of type $\tau_O$, continuous vectors of type $\tau_R$, and symbolic references for these vectors, let $\Pm$ be a set of predicates, and let $\C$ be a set of constants. Let $\mathcal{V} = \Pm \cup \C$ define the vocabulary. In this work, we consider two kinds of predicates: symbolic and hybrid.  We define each of them as follows: 
\begin{definition}
    A predicate $\psym(y_1,\dots,y_k) \in \Psym$ is a \textbf{symbolic predicate} iff all of its arguments $y_1,\dots,y_k$ are of type $\tau_O$.
\end{definition} 

\begin{definition}
    A predicate $\ph(y_1,\dots,y_k,\theta_1,\dots,\theta_m) \in \Ph$ is a \textbf{hybrid predicate} iff its arguments $y_1,\dots,y_k$ are of type $\tau_O$ and  $\theta_1,\dots,\theta_m$ are of type $\tau_R$.
\end{definition}

States are logical structures or models defined over predicates. A structure or a state $s \in \Sm$, of vocabulary $\mathcal{V}$ where $\Pm = \Psym \cup \Ph \subset \mathcal{V}$, consists of a universe $\U$, a predicate $p^S$ over $\U$ for every predicate $p \in \mathcal{V}$, and an element $c^S$ over $\mathcal{U}$ for every constant symbol $c \in \mathcal{V}$. An \emph{interpretation} of a predicate $p \in \Pm$ provides a relation between objects in the universe $\U$. 
% E.g., an interpretation, for a hybrid predicate \emph{at} -{}- \emph{at(o$_1$,loc)} -{}- if true, specifies a relation between \emph{o$_1$} and \emph{loc} representing that the object \emph{o$_1$} is at the location \emph{loc}, where $o_1 \in \U$ is the name of an object in the environment and \emph{loc} $\in \mathbb{R}^{6}$ represents the pose of the object in the environment. Similarly, an interpretation, for a symbolic predicate \emph{on} -{}- \emph{on($o_x$,$o_y$)} -{}- if true, specifies a relation between objects $o_x$ and $o_y$ representing that the object $o_x$ is placed on the object $o_y$, where $o_x, o_y \in \mathcal{U}$ are the names of objects in the environment. 
 Henceforth, we use $ \inter{p}_s$ and $\inter{\psi}_{s}$ to denote interpretations of the predicate $p$ and a formula $\psi$ in $s \in \Sm$ respectively. 

We use the notion of actions in PPDDL~\cite{McDermott1998PDDL} to represent the actions available to the robot. We classify actions available to the robot as \emph{symbolic} and \emph{hybrid} actions depending on the types of predicates that appear in the actions' descriptions and their arguments. Symbolic actions only use predicates from $\Psym$ to specify their preconditions and effects, but hybrid actions may use predicates from $\Psym$ and $\Ph$. 

% E.g., a symbolic action \emph{TurnOn(light)} is executed by the robot using a wireless transmitter to turn on a light where the argument \emph{light} is the name of an object in the environment and \emph{IsTurnedOn(light)} is a predicate from $\Psym$ that appears in the effect of the action. A concrete hybrid action \emph{Place(obj, loc, traj)} is executed by the robot by placing an object \emph{obj} at a certain location \emph{loc} using the trajectory \emph{traj}, where \emph{obj} is a name of the object in the environment while \emph{pose} and \emph{traj} are vectors or real values representing target pose of the object and trajectory to be used by the robot to execute the action. \emph{$\lnot$holding(obj)} and \emph{at(obj, pose)} are symbolic and concrete predicates respectively which appear in the effect of the action. 

A hybrid action is a motion planning action if the robot requires to compute a motion plan while executing the hybrid action. Action arguments for motion planning actions specify trajectories required to execute these actions and preconditions can be used to specify constraints on these motion planning trajectories. Values for these motion planning arguments can be sampled using a motion planner. 
% E.g, the action \emph{Place(obj, loc, traj)} contains a motion planning argument \emph{traj} which refers to a valid collision-free trajectory. 
We formally define motion planning actions as follows:
\begin{definition}
A \textbf{motion planning action} $a_\text{mp}(o_1,\dots,o_k,\theta_1,\dots,\theta_j,t_1,\dots,t_n)$ is a hybrid action where $o_1,\dots,o_k$ are of type $\tau_o$, $\theta_1,\dots,\theta_j$ are of type $\tau_R$, and $t_1,\dots,t_n$ are motion planning trajectories. \emph{pre(a$_\text{mp}$)} contains constraints on $t_1,\dots,t_n$ and \emph{eff(a$_\text{mp})$} represents the effective pose of the robot after executing action $a_\text{mp}$. $\mathcal{A}_\text{mp} \subset \Ah$ is the set of all motion planning actions.
\end{definition}  

We now use these concepts of first-order logical models to discuss stochastic shortest path problems in the context of our problem. 


\subsection{Abstraction}
\label{subsec:abstraction}

We use the concepts of abstraction to model the robot manipulation problem as a symbolic planning problem. 
Let $V_l$ be a low-level vocabulary and $V_h$ be a high-level vocabulary such that $V_h \subset V_l$; the predicates in $V_h$ are defined as identical to their counterparts in $V_l$. We define \emph{relational abstractions} as first-order queries that map structures over one vocabulary to structures over another vocabulary. A first-order query $\alpha$ from $V_h$ to $V_l$ defines functions in $V_h$(also identified as $\alpha(V_l))$ using the $V_l$-formulas in $S_l$: $\llbracket r \rrbracket _{V_h} (o_1, o_2, ..., o_n) = True$ iff $\llbracket \psi_{r}^{\alpha}(o_1, o_2, ..., o_n) \rrbracket _{S_l} = True$, where $\psi_{r}^{\alpha}$ is a formula over $V_l$. Such abstractions reduce the number of properties being modeled keeping number of objects the same. 
\paragraph{\textbf{Example}} Let $V_l$ be a first-order vocabulary consisting of continuous locations on a tabletop, an object $o$ and a relation \emph{atLocation($o$,$l$)} that defines relationship between an object $o$ and a continuous location $l$ on the tabletop. Let $V_h$ also be a first-order vocabulary that has a $0$-ary relation (constant) \emph{OnTable}. A first-order query $\alpha$ defines the value of \emph{OnTable} in $V_h$ as follows: \emph{OnTable} is true iff there exists a continuous location $l$ such that relation \emph{atLocation($l$,$o$)} is true in $V_l$.


The goal of our approach is to compute a solution for the obtained high-level symbolic problem with ``refinements'' that select a specific motion planning problem and its solution in the concrete space for each action in the high-level solution. In this view, each high-level action corresponds to infinite low-level problems in the concrete space, each defined by a specific initial and target configuration of the robot. For example, a high-level action of placing a cup on a table corresponds to infinite motion planning problems, each defined by a different location of the cup on the table. The refinement process would require selecting one of these problems and computing a valid motion planning solution for it. 

% Before defining the abstraction used in this work, we define some required terminology.
% An interpretation of a predicate $p \in \mathcal{P}$ represents either a property of an object or a relation between two or more objects. E.g., \emph{at($o_1$, loc)} is a hybrid predicate that specifies that object $o_1$ is at the location \emph{loc} where, $o_1\ \in \mathcal{U}$ is a name for an object in the environment and \emph{loc} $\subset \mathbb{R}^6$ represents the pose of the object with name $o_1$ in the $3$-D environment. Similarly, \emph{on($o_x$, $o_y$)} specifies that the object $o_x$ is placed on  the object $o_y$ where, $o_x,o_y \in \mathcal{U}$ are names of objects in the environment.


\subsection{Stochastic Shortest Path Problems}
\label{subsec:ssp}
% \subsubsection{Probabilistic planning}~\\ 
We use first order logical models defined in Sec.~\ref{subsec:first_order} to define stochastic shortest path problems (SSPs)~\cite{bertsekas91_ssp} as follows: 
% We now discuss stochastic version of the planning problem named \emph{stochastic shortest path problem}. \citet{bertsekas91_ssp} defines the \emph{stochastic shortest path problems} as follows: 
\begin{definition}
    A continuous \textbf{stochastic shortest path} (SSP) problem is defined as a $7$-tuple $ P_\text{ssp} = \langle \mathcal{P}, \mathcal{S}, \mathcal{A}, T, C, \gamma, H \rangle$ where,
    \begin{itemize}
        \item $\Pm = \Psym \cup \Ph$ is a set of predicates.
        \item $\Sm$ is a set of states such that every state is a structure defined over $\Pm$.
        \item $\Am = \Asym \cup \Ah$ is a set of actions. Here $\Am_\text{mp} \subset \Ah$.
        \item $T: \Sm \times \Am \times \Sm \rightarrow [0,1]$ is a transition function that assigns a probability value to each transition $(s,a,s')$. Here $s'$ represents a resultant state reached by the robot after executing an action $a$ in state $s$. 
        \item $C: \mathcal{S} \times \mathcal{A} \rightarrow \mathbb{R}$ is a cost function.
        \item $\gamma = 1$ is a discount factor (fixed). 
        \item $H$ is a finite horizon.
    \end{itemize}
\end{definition}
 A solution to an SSP is a non-stationary policy $\pi$ of the form
$\pi:\Sm \times \{1,\dots, H\} \rightarrow \Am$ that maps all
the states and time steps at which they are encountered to an
action. The optimal policy $\pi^{*} $ is a policy that reaches the
goal state with the least expected cumulative cost. Due to the finite horizon, SSP
policies need not be stationary.  




