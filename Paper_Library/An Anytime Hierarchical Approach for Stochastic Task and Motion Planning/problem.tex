\section*{Problem Statement}

Let $\mathcal{O}$ be the set of symbolic references to the objects in the environment. For convenience, we will refer to these references directly as objects. 

Let $\mathcal{P}$ be a set of predicates. In this work, we consider two kinds predicates: \emph{symbolic} and \emph{hybrid}. We define each of them as follows: 
\begin{definition}
    Let $\mathcal{P}_{sym}$ be a set of \textbf{symbolic predicates} defined using a set of objects $o \subseteq \mathcal{O}$ as their arguments. 
\end{definition}

\begin{definition}
    Let $\mathcal{P}_{h}$ be a set of \textbf{concrete hybrid predicates}. Each $p_h(o,\Theta) \in \mathcal{P}_h$ uses a set of vectors $\Theta$ each of which is a vector of continuous values, along with the set of objects $o \subseteq \mathcal{O}$ as its arguments.
\end{definition}

A predicate $p \in \mathcal{P} = \mathcal{P}_{sym} \cup \mathcal{P}_h$ represents either a property of the object or a relation between two or more objects. For e.g., \emph{at($o_1$, loc)} specifies the location of the object $o_1$ where, $\{o_1\} \subset \mathcal{O}$ and \emph{loc} is a \emph{6-D} vector representing the pose of the object $o_1$ in the $3$-D environment, and \emph{on($o_x$, $o_y$)} specifies that object $o_x$ is placed on $o_y$.

Let $\alpha$ be a composition of entity abstraction (sec. \ref{sec:entity}) and function abstraction. For each concrete hybrid predicate $p_h \in \mathcal{P}_h$ we derive an abstract hybrid predicate $\abs{p_h}_{\alpha}$ as follows:  
\begin{definition}
    Let $ \llbracket \mathcal{P}_{h} \rrbracket_{\alpha}$ be a set of \textbf{abstract hybrid predicates}. Each $ \llbracket p_h \rrbracket_{\alpha} (o,\bar{\Theta}) \in \llbracket \mathcal{P}_{h} \rrbracket $ is an abstraction of its corresponding concrete predicate $p_h(o,\Theta) \in \mathcal{P}_h$, defined using a set of objects $o \subset \mathcal{O}$ and $\bar{\Theta}$ such that $\Theta \in \rho(\bar{\Theta})$.   
\end{definition}


We use predicates from $\mathcal{P}$ to define the concrete and abstract states as follows:

\begin{definition}
    A \textbf{concrete state} $x$ is defined as a subset of $\mathcal{P} = \mathcal{P}_{sym} \cup \mathcal{P}_h$. 
    $\mathcal{X}$ is a set of all possible concrete states. 
\end{definition}

\begin{definition}
    An \textbf{abstract state} $\abs{x}_{\alpha}$ is defined as a  subset of $ \llbracket \mathcal{P} \rrbracket_{\alpha} = \mathcal{P}_{sym} \cup \llbracket \mathcal{P}_h \rrbracket_{\alpha}$.  $\abs{\mathcal{X}}_{\alpha}$ is a set of all possible abstract states. 
\end{definition}

We classify actions available to the robot as \emph{symbolic} and \emph{hybrid} actions depending on the type predicates that appear in its actions. We define them as follows:

% \begin{definition}
%     Let $\llbracket \mathcal{X} \rrbracket_{\alpha}$ be the \textbf{abstract state space}. Each state $\llbracket x \rrbracket_{\alpha}$ is defined as a subset of $ \llbracket \mathcal{P} \rrbracket_{\alpha} = \mathcal{P}_{sym} \cup \llbracket \mathcal{P}_h \rrbracket_{\alpha}$.
% \end{definition}


\begin{definition}
    Let $\mathcal{A}_{sym}$ be a set of \textbf{symbolic actions} defined using predicates from $\mathcal{P}_{sym}$ such that $\forall a_{sym} \in \mathcal{A}_{sym},\, \emph{eff}_{a_{sym}} \subset \mathcal{P}_{sym}$.
\end{definition}


\begin{definition}
    Let $\mathcal{A}_h$ be a set of \textbf{concrete hybrid actions} defined using predicates from $\mathcal{P}_{sym} \cup \mathcal{P}_h$ such that $\forall a_{h} \in \mathcal{A}_{h},\, \emph{eff}_{a_{h}} \subset \mathcal{P}_{sym} \cup \mathcal{P}_h$.
\end{definition}
Each hybrid action $a_h \in \mathcal{A}_h$ is indeed 
% Each hybrid action $a_h \in \mathcal{A}_h$ is defined as 
a temporal abstraction of primitive actions that enable use of low-level controllers to manipulate the agent, and can be refined using a motion planner. For simplicity and without the loss of generality, we embed these refinements as parts of action arguments (see Fig. \ref{abs_example1}).


\begin{definition}
    Let $\llbracket \mathcal{A}_h \rrbracket_{\alpha}$ be a set of \textbf{abstract hybrid actions} defined using predicates from $\mathcal{P}_{sym} \cup \llbracket \mathcal{P}_{h} \rrbracket_{\alpha}$ such that $\forall \llbracket a_{h} \rrbracket_{\alpha} \in \llbracket \mathcal{A}_h \rrbracket_{\alpha},\, \emph{eff}_{\llbracket a_{h} \rrbracket_{\alpha}} \subset \mathcal{P}_{sym} \cup \llbracket \mathcal{P}_{h} \rrbracket_{\alpha}$.
\end{definition}

\begin{definition}
    A \textbf{concrete planning} problem $P$ is defined as a $6$-tuple $ P = \langle \mathcal{O}, \mathcal{P} = \mathcal{P}_{sym} \cup \mathcal{P}_h, \mathcal{X},  \mathcal{A} = \mathcal{A}_{sym} \cup \mathcal{A}_h, x_0, X_g \rangle$ where, $\mathcal{O}$ is a set of symbolic references to the objects in the environment, $\mathcal{P}$ is a set of predicates, $\mathcal{X}$ is a set of states, $\mathcal{A}$ is a set of actions available to the agent, $x_0 \in \mathcal{X}$ is an initial state, and $X_g \subset \mathcal{X}$ is a set of goal states.
    
\end{definition}

The solution to a concrete planning problem is a valid sequence of actions $\pi = \langle a_0,\dots,a_n \rangle$ such that $\forall a_i \in \pi,\, a_i \in  \mathcal{A}$ and when applied to $x_0$, the resultant state is $x_n \in X_g$.


\begin{definition}
    An \textbf{abstract planning} problem $\llbracket P \rrbracket_{\alpha}$ is defined as a $6$-tuple $ P = \langle \mathcal{O}, \llbracket \mathcal{P} \rrbracket_{\alpha} = \mathcal{P}_{sym} \cup \llbracket \mathcal{P}_h \rrbracket_{\alpha}, \llbracket \mathcal{X} \rrbracket_{\alpha},  \llbracket \mathcal{A} \rrbracket_{\alpha} = \mathcal{A}_{sym} \cup  \llbracket \mathcal{A}_h \rrbracket_{\alpha}, \llbracket x_0 \rrbracket_{\alpha}, \llbracket X_g \rrbracket_{\alpha} \rangle$ where, $\mathcal{O}$ is a set of symbolic references to the objects in the environment, $ \llbracket \mathcal{P} \rrbracket_{\alpha}$ is a set of abstract predicates, $\llbracket \mathcal{X} \rrbracket_{\alpha}$ is a set of abstract states, $\llbracket \mathcal{A} \rrbracket_{\alpha}$ is a set of abstract actions available to the agent, $\llbracket x_0 \rrbracket_{\alpha} \in \llbracket \mathcal{X} \rrbracket_{\alpha}$ is an initial state, and $\llbracket X_g \rrbracket_{\alpha} \subset \llbracket \mathcal{X} \rrbracket_{\alpha}$ is a set of goal states.
    
\end{definition}

The solution to an abstract planning problem is a valid sequence of actions $ \llbracket \pi \rrbracket_{\alpha} = \langle a_0,\dots,a_n \rangle$ such that  $\forall \llbracket a_i \rrbracket_{\alpha} \in \llbracket \pi \rrbracket_{\alpha},\, \llbracket a_i \rrbracket_{\alpha} \in  \llbracket \mathcal{A} \rrbracket_{\alpha}$ and when applied to $\llbracket x_0 \rrbracket_{\alpha}$, the resultant state is $\llbracket x_n \rrbracket_{\alpha} \in \llbracket X_g \rrbracket_{\alpha}$.

A \emph{concrete SSP} can be defined in a similar fashion with stochastic action descriptions for actions in $\mathcal{A}$.


% A \emph{concrete planning} problem $P$ is defined as a $5$-tuple $ P = \langle \mathcal{P}, \mathcal{X}, \mathcal{O}, \mathcal{A}, X_g \rangle$ where,  $\mathcal{P}$ is a set of predicates, $\mathcal{X}$ define a concrete state space that consists of states defined using the set of predicates $\mathcal{P}$, $\mathcal{O}$ defines a set of symbolic names for the objects in the environment, $\mathcal{A}$ is a set of actions available to the agent, and $X_g$ defines a set of goal states. Each state $x \in \mathcal{X}$ is made up of a subset of the set of predicates $ \mathcal{P}$. $\mathcal{P}$ is a union of sets $\mathcal{P}_{sym}$ and $\mathcal{P}_{h}$ where, $\mathcal{P}_{sym}$ is a set of symbolic predicates that use objects ffrom $\mathcal{O}$ as their arguments, and $\mathcal{P}_h$ is a set of hybrid predicates that use a set of real valued vectors $\theta$ along with symbolic arguments.  $\mathcal{A}$ defines a set of symbolic and hybrid actions defined using predicates from $\mathcal{P}$ and objects from $\mathcal{O}$. While every action $a \in \mathcal{A}$ affects the symbolic predicates in the state, hybrid actions also affects hybrid predicates. Hybrid actions are defined as a temporal abstraction of primitive actions that enable use of low-level controllers to manipulate the agent, and refined using a motion planner. For simplicity and without lose of generality, we embed these refinements as parts of action arguments (see Fig. \ref{abs_example1}). The solution to a concrete planning problem is a valid sequence of actions $[a_0,\dots,a_n]$ such that when applied to $x_0$, the resultant state is $x_n \in X_g$. 
% We use entity abstraction defined in the section \ref{sec:entity} to compute an abstract planning problem $[P]$ by abstracting the predicates with continuous vector $\theta$ using a set of symbolic arguments $[\theta]$. We then define set of abstract actions $[\mathcal{A}]$ with abstracted predicates. Fig. \ref{abs_example1} provides an example of one of the abstract actions where continuous parameters such as \emph{target\_pose} and robot configurations \emph{config$_1$} and \emph{config$_2$} are replaced by corresponding symbolic arguments. 

We define  task and motion planning problems as follows: 
\begin{definition}

    A \textbf{task and motion planning problem}  (\emph{TAMPP}) can be defined as a $5$-tuple $\langle \M$, $\alpha$, $\gamma$, $\abs{\M}_{\alpha} \rangle$ where, $\M$ is a concrete planning problem, $\alpha$ is an abstraction function that is composition of entity abstraction and function abstraction, $\gamma$ is a concretization function in the form of generators, and $\abs{\M}_{\alpha}$ is an abstract model computed by applying $\alpha$ on the concrete model $\M$.
\end{definition}

\begin{definition}

    A \textbf{stochastic task and motion planning problem}  (\emph{STAMPP}) can be defined as a $5$-tuple $\langle \M$, $\alpha$, $\gamma$, $\abs{\M}_{\alpha} \rangle$ where, $\M$ is a concrete \emph{SSP}, $\alpha$ is an abstraction function that is composition of entity abstraction and function abstraction, $\gamma$ is a concretization function in the form of generators, and $\abs{\M}_{\alpha}$ is an abstract model computed by applying $\alpha$ on the concrete model $\M$.
\end{definition}



Solutions to \emph{TAMPPs} or \emph{STAMPPs} are policies with actions from the concrete model $\M$. In this work, We consider solutions in the form of  a policy tree where each node $u_p$ in the tree represents an  state $s_{u_p}$ and edge $e_p$ represents an $a_{e_p}$. The child of a node-edge pair $(u_p,e_p)$ in the policy tree refers to a possible outcome of executing the action $a_{e_p}$ at the state $s_{u_p}$. In the case of all deterministic actions (\emph{TAMPP}), the tree would have a single branch. 
