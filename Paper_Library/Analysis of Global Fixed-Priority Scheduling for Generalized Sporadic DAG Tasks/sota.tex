\section{The State-of-the-Art Analysis for G-FP}
\label{sec:sota}

\begin{figure}[h!]
\centering
\includegraphics[width=\linewidth]{figures/melani.pdf}
\caption{Workload generated by an interfering task $\tau_i$ in Melani et al.~\cite{melani2015response}.}
\label{fig:melani}
\end{figure}

Melani et al.~\cite{melani2015response} proposed a response-time analysis for G-FP scheduling 
of conditional DAG tasks that may contain conditional vertices, for modeling conditional constructs 
such as \texttt{if-then-else} statements. 
They bounded the interfering workload by assuming that jobs of the interfering task execute perfectly 
in parallel on all $m$ processors. Their bound for the interfering workload is computed as follows. 
$$W_i(\Delta) = \Big\lfloor\frac{\Delta+R_i-C_i/m}{T_i} \Big\rfloor C_i + 
\min\big\{ C_i, m((\Delta+R_i-C_i/m)\mod T_i) \big\}.$$
Figure~\ref{fig:melani} illustrates the workload computation for an interfering task $\tau_i$ given 
in~\cite{melani2015response}. As shown in this figure, both carry-in and carry-out jobs are assumed to 
execute with perfect parallelism upon $m$ processors. Thus their workload contributions in the considered 
window are maximized. This assumption simplifies the workload computation as it ignores the 
internal DAG structures of the interfering tasks. However, assuming that DAG tasks have such 
abundant parallelism is likely unrealistic and thus makes the analysis pessimistic. 

Fonseca et al.~\cite{fonseca2017improved} later considered a task model similar to the one in this paper 
and proposed a method to improve the bounds for carry-in and carry-out 
workloads by explicitly considering the DAGs. The carry-in workload was bounded using a 
\emph{hypothetical schedule} for the carry-in job, in which the carry-in job can use as many processors 
as it needs to fully exploit its parallelism. They proved that the carry-in workload of the hypothetical 
schedule is maximized when: (i) the hypothetical schedule's completion time is aligned with the worst-case 
completion time of the interfering task, (ii) every subtask in the hypothetical schedule starts executing 
as soon as all of its predecessors finish, and (iii) every subtask in the hypothetical 
schedule executes for its full WCET. Figure~\ref{fig:workload} shows the hypothetical schedule 
of the carry-in job for the task in Figure~\ref{fig:example_task}. In this paper, we adopt their method for 
computing carry-in workload. In particular, the carry-in workload of task $\tau_i$ with a carry-in window of 
length $\Delta_i^{CI}$, i.e., from the start of the problem window to the completion time of the carry-in job 
(see Figure~\ref{fig:workload}), is computed as follows.
\begin{equation}
\label{eqn:carryin}
W_i^{CI}(\Delta_i^{CI}) = \sum_{v_{i, k}\in V_i}\max\big\{ C_{i, k} - \max(L_i - S_{i, k} - \Delta_i^{CI}, 0), 0 \big\}.
\end{equation}
In Equation~\ref{eqn:carryin}, $S_{i, k}$ is the start time of subtask $v_{i, k}$ in the hypothetical schedule for 
the carry-in job described above. It can be computed by taking a longest path among all paths from source 
subtasks to $v_{i, k}$ and adding up the WCETs of the subtasks along that path excluding $v_{i, k}$ itself. 

\begin{figure}[t!]
\centering
\begin{subfigure}{0.7\linewidth}
  \centering
  \includegraphics[width=\linewidth]{figures/nfjdag_conflict.pdf}
  \caption{A non-nested-fork-join DAG task.}
  \label{fig:nfjdag_conflict}
\end{subfigure}
\hfill
\begin{subfigure}{.7\linewidth}
  \centering
  \includegraphics[width=\linewidth]{figures/nfjdag.pdf}
  \caption{A nested fork-join DAG task.}
  \label{fig:nfjdag}
\end{subfigure}
\caption{Example for a general DAG task and a nested fork-join DAG task.}
\label{fig:nfjdagtask}
\end{figure}

For the carry-out workload,~\cite{fonseca2017improved} considered a subset of generalized DAG tasks, 
namely nested fork-join DAG (NFJ-DAG) tasks. A NFJ-DAG is constructed recursively from smaller NFJ-DAGs 
using two operations: \emph{series composition} and \emph{parallel composition}. Figure~\ref{fig:nfjdag} 
shows an example NFJ-DAG task. Figure~\ref{fig:nfjdag_conflict} shows a similar DAG with one more 
edge $(v_{i, 7}, v_{i, 8})$. The DAG in Figure~\ref{fig:nfjdag_conflict} is not a NFJ-DAG due to a single 
cross edge $(v_{i, 7}, v_{i, 8})$. To deal with a non NFJ-DAG,~\cite{fonseca2017improved} first transforms 
the original DAG to a NFJ-DAG by removing the conflicting edges, such as $(v_{i, 7}, v_{i, 8})$ in 
Figure~\ref{fig:nfjdagtask}. Then they compute the upper-bound for the carry-out workload using the 
obtained NFJ-DAG. The computed bound is proved to be an upper-bound for the carry-out workload. 
We note that the transformation removes some precedence constraints from the original DAG, and thus 
the resulting NFJ-DAG may have higher parallelism than the original DAG. Hence, computing the carry-out 
workload of a generalized DAG task via its transformed NFG-DAG may be pessimistic, especially for 
a complex DAG, as the transformation may remove many edges from the original DAG. 


In this paper, we propose a new technique to directly compute an upper-bound for the carry-out workload of 
generalized DAG task. The high level idea is to frame the problem of finding the bound as 
an optimization problem, which can be solved effectively by solvers such as 
the CPLEX~\cite{cplex}, Gurobi~\cite{gurobi}, or SCIP~\cite{scip}. 
The solution of the optimization problem then serves as a safe and tight upper-bound for the 
carry-out workload. In the next section we present our method in detail. 






