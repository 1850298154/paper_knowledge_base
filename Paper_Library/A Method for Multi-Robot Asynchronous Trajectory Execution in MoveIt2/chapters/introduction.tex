When dealing with multi-arm robots or setups with multiple robots where the workspace is shared, there are two main approaches to plan and execute trajectories in a collision free way. Firstly, there is the synchronous approach: All arms (or robots) that are moving at the same time are assumed to be a single moving entity, and traditional planning and execution approaches are being utilized. In the asynchronous approach, trajectories involving the shared workspace are planned independently, so they have to be managed by a central entity to avoid collision. This allows individual arms to operate independently, facilitating the simultaneous management of multiple unrelated tasks by multiple arms \cite{Seyed_2018}. 
%\emph{synchronous} and \emph{asynchronous} motion execution involve distinct methods of performing the movements of robotic arms. In synchronous execution, the robot arms carry out their tasks simultaneously and in a coordinated fashion. Conversely, in asynchronous execution, each robotic arm moves autonomously without strict synchronization with other arms\cite{Seyed_2018}. This allows individual arms to operate independently, facilitating the simultaneous management of multiple unrelated tasks by multiple arms. 

By allowing independent motion, asynchronous execution allows for a more efficient utilization of the arms when tasks vary in duration. For example, in a packaging facility, some items need quick packaging, while others require longer, complex packaging. With asynchronous execution, robotic arms can be individually assigned tasks of different duration, avoiding planning and executing combined coordinated motions for different tasks.

%The synchronous execution of tasks can be achieved in planning and execution time\cite{Seyed_2018}. Time-constrained motion \cite{Kimmel_2016}, static environment planning \cite{Buhl_2019}, and waiting-based synchronization \cite{Wang_2019} are proposed for the safe operation of synchronous execution. 
While several works address safe operation of multi-arms with synchronous execution%(e.g, \cite{Seyed_2018}, \cite{Buhl_2019}, \cite{Wang_2019})
, fewer deal with asynchronous execution, either posing it as a multi-agent problem\cite{Grady_2010},  using trajectory reservation\cite{Planrob}, or using online collision detection as in \cite{GSoC_2022}\footnote{The work presented in this paper was developed before and without knowledge of the cited work. Our implementation is available at: https://github.com/stooppas/moveit2 }. 
%
%The prevalent libraries used by the robotics community for planning and executing robotic arm movements are the Robot Operating System (ROS)\footnote{https://www.ros.org/} and Moveit2\footnote{https://moveit.picknik.ai}\cite{Coleman_moveit}. 
MoveIt2%\footnote{https://moveit.picknik.ai}
\cite{Coleman_moveit} is the most adopted library for robotic arm motion planning and execution, but, at the time of writing, while supporting multi-arm system, it only allows synchronous execution and lacks asynchronous execution. In this work, we report on extending the framework by adding a collision checking approach involving a simple scheduler.

% The contributions of this work can be summarized as follows:
% \begin{itemize}
%   \item A proof of concept extension for moveit that enables collision-free asynchronous trajectory execution.
%   \item A set of proposal experiments for validating the safe operation and measuring increased efficiency.
% \end{itemize}


