\beginbass
%
As we have anticipated, there exist infinite typing derivations that are unsound
from a logical standpoint, because they allow us to prove $\Zero$ or the empty
sequent. Hence, the typing rules presented in \Cref{fig:ts_ll} must be combined
with additional \emph{validity conditions}.

\begin{example}
	\label{ex:omega}
	Consider the non-terminating process $\Omega(x) = \PiChoice{\Call\Omega\x}{\Call\Omega\x}$.
	We obtain the following infinite derivation showing that $\Call\Omega\x$ is quasi typed.
	\[
    \begin{prooftree}
        \[
            \mathstrut\smash\vdots
            \justifies
            \qtp{x : \Zero}{\Call\Omega\x}
        \]
        \qquad
        \[
            \mathstrut\smash\vdots
            \justifies
            \qtp{x : \Zero}{\Call\Omega\x}
        \]
        \justifies
        \qtp{x : \Zero}{\Call\Omega\x}
        \using\refrule\PiChoiceRule
    \end{prooftree}
    \]
%
\end{example}

As illustrated by the next example,
there exist non-terminating processes that are quasi typed also in logically
sound contexts.

\begin{example}[Compulsive Buyer]
    \label{ex:compulsive_buyer_ll}
    Consider the following variant of the $\Buyer$ process
    \[
        \Buyer(x) = \Rec\x.\Select\AddTag\x.\Call\Buyer{x}
    \] 
    that models a ``compulsive buyer'', namely a buyer that adds infinitely many
    items to the shopping cart but never pays. Using $\FormulaF \eqdef \tmu\X.X
    \plinchoice \One$ and an arbitrary atomic address $a$ we can build the following
    infinite derivation
    \[
        \begin{prooftree}
            \[
                \[
                    \mathstrut\smash\vdots
                    \justifies
                    \qtp{
                        x : \Formula_{ail}
                    }{
                        \Call\Buyer{x}
                    }
                \]
                \justifies
                \qtp{
                    x : (\Formula \plinchoice \One)_{ai}
                }{
                    \Select\AddTag\x.\Call\Buyer{x}
                }
                \using\refrule[select]{\SelectRule}
            \]
            \justifies
            \qtp{
                x : \Formula_a
            }{
                \Call\Buyer{x}
            }
            \using\refrule[rec]{\RecRule}
        \end{prooftree}
    \]
    %
    showing that this process is quasi typed. By combining this derivation with
    the one for $\Seller$ in \Cref{ex:bsc_ll_ts} we obtain a
    derivation establishing that $\Cut\x{\Call\Buyer\x}{\Call\Seller{x,y}}$ is
    quasi typed in the context $y : \One$, although this composition cannot
    terminate.
    %
    \eoe
\end{example}

To rule out unsound derivations like those in
\Cref{ex:omega,ex:compulsive_buyer_ll} it is necessary to impose a validity
condition on derivations \citep{BaeldeDoumaneSaurin16,Doumane17}. Roughly
speaking, \muMALL's validity condition requires every infinite branch of a
derivation to be supported by the continuous unfolding of a greatest fixed
point. In order to formalize this condition, we start by defining
\emph{threads}, which are sequences of types describing sequential interactions
at the type level.

\begin{definition}[Thread]
    \label{def:thread}
    A \emph{thread} of $S$ is a sequence of types $(S_i)_{i\in o}$ for some
    $o\in\omega + 1$ such that $S_0 = S$ and $S_i \tred S_{i+1}$ whenever
    $i+1\in o$.
\end{definition}

Hereafter we use $t$ to range over threads. 

\begin{example}
	\label{ex:bsc_ll_thread}
	Consider
	$\Formula \eqdef \tmu\X.X \plinchoice \One$ from \Cref{ex:bsc_ll_formulas} we have that
	$t \eqdef (\Formula_a,(\Formula\plinchoice\One)_{ai},\Formula_{ail},\dots)$ is an
	infinite thread of $\Formula_a$.
\end{example}

A thread is \emph{stationary} if it has an
infinite suffix of equal types. The thread $t$ from \Cref{ex:bsc_ll_thread} is not stationary.
Among all threads, we are interested in finding those in which a $\tnu$-formula
is unfolded infinitely often. These threads, called $\tnu$-threads, are precisely
defined thus:

\begin{definition}[$\tnu$-thread]
    \label{def:nu-thread}
    Let $t = (S_i)_{i\in\omega}$ be an infinite thread, let $\strip{t}$ be the
    corresponding sequence $(\strip{S_i})_{i\in\omega}$ of formulas and let
    $\InfOften{t}$ be the set of elements of $\strip{t}$ that occur infinitely
    often in $\strip{t}$. We say that $t$ is a \emph{$\tnu$-thread} if
    $\minf\InfOften{t}$ is defined and is a $\tnu$-formula.
\end{definition}

\begin{example}
	Consider the infinite thread $t$ from \Cref{ex:bsc_ll_thread}.
	We have $\InfOften{t} = \set{\Formula, \Formula \choice \One}$ 
	and $\minf\InfOften{t} = \Formula$, so $t$
	is \emph{not} a $\tnu$-thread because $\Formula$ is not a $\tnu$-formula.
\end{example}

\begin{example}
	Consider the following formulas 
	\[
	\begin{array}{rclrcl}
		\FormulaF & \eqdef & \tnu\X.\tmu\Y.X \choice Y 
		& \qquad
		\FormulaG & \eqdef & \tmu\Y.\FormulaF \choice Y
	\end{array}
	\]	
	Observe that $\FormulaG$ is the ``unfolding'' of $\FormulaF$. 
	Now 
	\[
	t_1 \eqdef (\FormulaF_a, \FormulaG_{ai},
	(\FormulaF \choice \FormulaG)_{aii}, \FormulaF_{aiil}, \dots)
	\] is a thread of
	$\FormulaF_a$ such that $\InfOften{t_1} = \set{\FormulaF, \FormulaG, \FormulaF
	\choice \FormulaG}$ and we have $\minf\InfOften{t_1} = \FormulaF$ because
	$\FormulaF \subf \FormulaG$, so $t_1$ is a $\tnu$-thread.
	%
	If, on the other hand, we consider the thread 
	\[
	t_2 \eqdef (\FormulaF_a,
	\FormulaG_{ai}, (\FormulaF \choice \FormulaG)_{aii}, \FormulaG_{aiir},
	(\FormulaF \choice \FormulaG)_{aiiri}, \dots)
	\]
	such that $\InfOften{t_2} =
	\set{\FormulaG, \FormulaF \choice \FormulaG}$ we have $\minf\InfOften{t_2} =
	\FormulaG$ because $\FormulaG \subf \FormulaF \choice \FormulaG$, so $t_2$ is
	not a $\tnu$-thread.
\end{example}

Intuitively, the $\subf$-minimum formula among those that occur infinitely often
in a thread is the outermost fixed point operator that is being unfolded
infinitely often. It is possible to show that this minimum formula is always
well defined \citep{Doumane17}. If such minimum formula is a greatest fixed point
operator, then the thread is a $\tnu$-thread.

Now we proceed by identifying threads along branches of typing derivations. To
this aim, we provide a precise definition of \emph{branch}.

\begin{definition}[Branch]
    \label{def:branch}
    A \emph{branch} of a typing derivation is a sequence
    $(\qtp{\Ctx_i}{P_i})_{i\in o}$ of judgments for some $o\in\omega+1$ such
    that $\qtp{\Ctx_0}{P_0}$ occurs somewhere in the derivation and
    $\qtp{\Ctx_{i+1}}{P_{i+1}}$ is a premise of the rule application that
    derives $\qtp{\Ctx_i}{P_i}$ whenever $i+1\in o$.
\end{definition}

An infinite branch is valid if supported by a $\tnu$-thread that originates
somewhere therein.

\begin{definition}[Valid Branch]
    \label{def:valid_branch}
    Let $\gamma = (\qtp{\Ctx_i}{P_i})_{i\in\omega}$ be an infinite branch in
    a derivation. We say that $\gamma$ is \emph{valid} if there exists
    $j\in\omega$ such that $(S_k)_{k\geq j}$ is a non-stationary $\tnu$-thread
    and $S_k$ is in the range of $\Ctx_k$ for every $k \geq j$.
\end{definition}

\begin{example}
	The infinite branch in the typing derivation for $\Seller$ of
	\Cref{ex:bsc_ll_formulas} is valid since it is supported by the $\tnu$-thread
	$(\FormulaG_{\dual{a}}, (\FormulaG \plinbranch \Bot)_{\dual{a}i},
	\FormulaG_{\dual{a}il},\dots)$ where $\FormulaG \eqdef \tnu\X.X \plinbranch \Bot$
	happens to be the $\subf$-minimum formula that is unfolded infinitely often.
\end{example}

\begin{example}
	The infinite branch in the typing derivation for $\Buyer$ of
	\Cref{ex:compulsive_buyer_ll} is invalid, because the only infinite thread
	in it is $(\FormulaF_a, (\FormulaF \plinchoice \One)_{ai}, \FormulaF_{ail}, \dots)$
	which is not a $\tnu$-thread.
\end{example}

A \muMALL derivation is valid if so is every infinite branch in
it \citep{BaeldeDoumaneSaurin16,Doumane17}. For the purpose of ensuring fair
termination, this condition is too strong because some infinite branches in a
typing derivation may correspond to unfair executions that, by definition, we
neglect insofar its termination is concerned. For example, the infinite branch
in the derivation for $\Buyer$ of \Cref{ex:bsc_ll_formulas} corresponds to
an unfair run in which the buyer insists on adding items to the shopping cart,
despite it periodically has a chance of paying the seller and terminate the
interaction. That typing derivation for $\Buyer$ would be considered an invalid
proof in \muMALL because the infinite branch is not supported by a $\tnu$-thread
(in fact, there is a $\tmu$-formula that is unfolded infinitely many times along
that branch, as in \Cref{ex:compulsive_buyer_ll}).

It is generally difficult to understand if a branch corresponds to a fair or
unfair run because the branch describes the evolution of an incomplete process
whose behavior is affected by the interactions it has with processes found in
other branches of the derivation.
%
However, we can detect (some) unfair branches by looking at the
non-deterministic choices they traverse, since choices are made autonomously by
processes. To this aim, we introduce the notion of \emph{rank} to estimate the
least number of choices a process can possibly make during its lifetime.

\begin{definition}[Rank]
    \label{def:rank}
    Let $\rankR$ and $\rankS$ range over the elements of $\RankSet \eqdef
    \Nat\cup\set\infty$ equipped with the expected total order $\leq$ and
    operation $+$ such that $\rankR + \infty = \infty + \rankR = \infty$.
    %
    The \emph{rank} of a process $P$, written $\rankof{P}$, is the least element
    of $\RankSet$ such that
    \[
    	\begin{array}{lr}
        \begin{array}{@{}r@{~}c@{~}l@{}}
            \rankof{\Link\x\y} & = & 0 \\
            \rankof{\Fail\x} & = & 0 \\
            \rankof{\PiClose\x} & = & 0 \\
            \rankof{\PiWait\x.P} & = & \rankof{P} \\
            \rankof{\Join[z]\x\y.P} & = & \rankof{P} \\
            \rankof{\Select[y]{\InTag_i}\x.P} & = & \rankof{P}
        \end{array}
				& \qquad
        \begin{array}{@{}r@{~}c@{~}l@{}}
        		\rankof{\Rec[y]\x.P} & = & \rankof{P} \\
            \rankof{\Corec[y]\x.P} & = & \rankof{P} \\
            \rankof{\Case[y]\x{P}{Q}} & = & \max\set{\rankof{P},\rankof{Q}} \\
            \rankof{\PiChoice{P}{Q}} & = & 1 + \min\set{\rankof{P},\rankof{Q}} \\
            \rankof{\Cut\x{P}{Q}} & = & \rankof{P} + \rankof{Q} \\
            \rankof{\Fork[z]\x\y{P}{Q}} & = & \rankof{P} + \rankof{Q}
        \end{array}
    	\end{array}
    \]
\end{definition}

Roughly, the rank of terminated processes is $0$, that of processes with a
single continuation $P$ coincides with the rank of $P$, and that of processes
spawning two continuations $P$ and $Q$ is the sum of the ranks of $P$ and $Q$.
Then, the rank of a sum input with continuations $P$ and $Q$ is conservatively
estimated as the maximum of the ranks of $P$ and $Q$, since we do not know which
one will be taken, whereas the rank of a choice with continuations $P$ and $Q$
is 1 plus the minimum of the ranks of $P$ and $Q$.

\begin{example}
	Consider $\Buyer$ and $\Seller$ from \Cref{ex:bsc_ll_proc} and $\Omega$ from \Cref{ex:omega}.
 	Then have $\rankof{\Call\Buyer\x} = 1$, $\rankof{\Call\Seller{x,y}} = 0$
 	and $\rankof{\Call\Omega\x} = \infty$.
\end{example}

Note that $\rankof{P}$ only depends on the structure of $P$ but not on the
actual names occurring in $P$. As a consequence, when $P$ is defined by means of a
\emph{finite} system of equations, the value of $\rankof{P}$ too can be
determined by a \emph{finite} system of equations.

\begin{example}
	\label{ex:eq_system}
	Consider the definition of $\Buyer$ found in
	\Cref{ex:bsc_ll_proc}. In order to compute $\rankof{\Call\Buyer\x}$ we consider
	the system of equations
	{
    \renewcommand{\x}{\bullet}
    \renewcommand{\y}{\bullet}
    \renewcommand{\z}{\bullet}
    %
    \[
    \begin{array}{rcl}
    	\rankof{\Call\Buyer\x} & = & \rankof{
            \PiChoice{
                \Select[\z]\AddTag\y.\Call\Buyer\z
            }{
                \Select[\z]\PayTag\y.\PiClose\z
            }
        }
      \\
      \rankof{
            \PiChoice{
                \Select[\z]\AddTag\y.\Call\Buyer\z
            }{
                \Select[\z]\PayTag\y.\PiClose\z
            }
        } & = & 1 + \min\set{ 
            \\ & & \qquad\quad \rankof{\Select[\z]\AddTag\y.\Call\Buyer\z},
            \\ & & \qquad\quad \rankof{\Select[\z]\PayTag\y.\PiClose\z}
        }
        \\
        \rankof{\Select[\z]\AddTag\y.\Call\Buyer\z} & = & \rankof{\Call\Buyer\z}
        \\
        \rankof{\Select[\z]\PayTag\y.\PiClose\z} & = & \rankof{\PiClose\z}
        \\
        \rankof{\PiClose\z} & = & 0
    \end{array}
    \]
	}
	%
	where we have used a placeholder $\bullet$ in place of every channel name
	occurring in these terms.
	%
	\eoe
\end{example}

Every such system of equations can be thought of as a function $\ffun :
\parens\RankSet^n \to \parens\RankSet^n$ on the complete lattice
$\parens\RankSet^n$ ordered by the pointwise extension of $\leq$ in $\RankSet$.
%
Note that $\ffun$ is monotone, because all the operators occurring in the
definition of rank (see \Cref{def:rank}) are monotone. So, $\ffun$ has a least fixed
point by the Knaster-Tarski theorem and the rank of $P$ is the component of this
fixed point that corresponds to $\rankof{P}$.

\begin{example}
	For system of equations in \Cref{ex:eq_system} we have $n = 5$ and we have
	\[
    \ffun(x_1,x_2,x_3,x_4,x_5) = (x_2,1+\min\set{x_3,x_4},x_1,x_5,0)
	\]
	whose least solution is $(1,1,1,0,0)$. Now $\rankof{\Call\Buyer\x}$ corresponds
	to the first component of this solution, that is $1$.
	%
	\eoe
\end{example}

\begin{definition}
    \label{def:fair_branch}
    A branch is \emph{fair} if it traverses finitely many, finitely-ranked
    choices.
\end{definition}

A finitely-ranked choice is at finite distance from a region of the process in
which there are no more choices. An \emph{unfair} branch gets close to such
region infinitely often, but systematically avoids entering it.
%
Note that every finite branch is also fair, but there are fair branches that are
infinite. 

\begin{example}
	All the infinite branches inside the derivation of
	\Cref{ex:omega} and the only infinite branch in the derivation for
	$\Call\Seller{x,y}$ of \Cref{ex:bsc_ll_ts} are fair since they do not
	traverse any finitely-ranked choice. On the contrary, the only infinite branch
	in the derivation for $\Call\Buyer\x$ of the \Cref{ex:bsc_ll_ts} is
	unfair since it traverses infinitely many finitely-ranked choices. All fair
	branches in the same derivation for $\Buyer$ are finite.
\end{example}

At last we can define our notion of well-typed process.

\begin{definition}[Well-Typed Process]
    \label{def:wtp}
    We say that $P$ is \emph{well typed} in $\Ctx$, written
    $\piwtp\Ctx{P}$, if the judgment $\qtp\Ctx{P}$ is derivable and each
    fair, infinite branch in its derivation is valid.
\end{definition}

\begin{example}
	 $\Omega$ is ill typed since the fair, infinite branches in
	\Cref{ex:omega} are all invalid.
\end{example}

\begin{theorem}[Soundness]
	\label{thm:ts_ll_sound}
    If $\piwtp{x : \One}{P}$ and $P \wred Q$ then $Q \wred \PiClose\x$.
\end{theorem}

As for the session-based calculi (\Cref{ch:ft_bin,ch:ft_multi}) 
\Cref{thm:ts_ll_sound} entails all the good properties we expect from well-typed
processes: \emph{failure freedom} (no unguarded sub-process $\Fail\y$ ever
appears), \emph{deadlock freedom} (if the process stops it is terminated),
\emph{lock freedom} \citep{Kobayashi02,Padovani14} (every pending action can be
completed in finite time) and \emph{junk freedom} (every channel can be
depleted).