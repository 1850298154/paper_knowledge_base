\beginbass
%
\begin{figure}[t]
	\framebox[\textwidth]{
    \begin{math}
        \displaystyle
        \begin{array}[t]{@{}r@{~}c@{~}ll@{}}
            P, Q
            & ::= & \Link\x\y & \text{link}
            \\
            & | & \Fail\x & \text{empty in}
            \\
            & | & \PiWait\x.P & \text{unit in}
            \\
            & | & \Join[y]\x\z.P & \text{pair in}
            \\
            & | & \Case[y]\x{P}{Q} & \text{sum in}
            \\
            & | & \Corec[y]\x.P & \text{corec}
        \end{array}
        ~
        \begin{array}[t]{@{}r@{~}c@{~}lll@{}}
            & | & \Cut\x{P}{Q} & \text{comp}
            \\
            & | & \PiChoice{P}{Q} & \text{choice}
            \\
            & | & \PiClose\x & \text{unit out}
            \\
            & | & \Fork[y]\x\z{P}{Q} & \text{pair out}
            \\
            & | & \Select[y]{\InTag_i}\x.P & \text{sum out} & i\in\set{1,2}
            \\
            & | & \Rec[y]\x.P & \text{rec}
        \end{array}
    \end{math}
  	}
    \caption{Syntax of \piLIN}
    \label{fig:proc_syntax_ll}
\end{figure}
%
We assume an infinite set of \emph{channels} ranged over by $x$, $y$ and
$z$. \piLIN processes are coinductively generated by the productions of the
grammar shown in \Cref{fig:proc_syntax_ll}. %and their informal meaning is given below.
A \emph{link} $\Link\x\y$ acts as a \emph{linear
forwarder} \cite{GardnerLaneveWischik07} that forwards a single message either
from $x$ to $y$ or from $y$ to $x$. The uncertainty in the direction of the
message is resolved once the term is typed and the polarity of the types of $x$
and $y$ is fixed (as we will show in \Cref{sec:ts_ll_ts}).
%
The term $\Fail\x$ represents a process that receives an empty message from $x$
and then fails. This form is only useful in the metatheory: the type system
guarantees that well-typed processes never fail, since it is not possible to
send empty messages.
%
The term $\PiClose\x$ models a process that sends the unit on $x$, effectively
indicating that the interaction is terminated, whereas $\PiWait\x.P$ models a
process that receives the unit from $x$ and then continues as $P$.
%
The term $\Fork[z]\x\y{P}{Q}$ models a process that creates two new channels $y$
and $z$, sends them in a pair on channel $x$ and then forks into two parallel
processes $P$ and $Q$. Dually, $\Join[z]\x\y.P$ models a process that receives a
pair containing two channels $y$ and $z$ from channel $x$ and then continues as
$P$.
%
The term $\Select[y]{\InTag_i}\x.P$ models a process that creates a new channel
$y$ and sends $\InTag_i\parens\y$ (that is, the $i$-th injection of $y$ in a
disjoint sum) on~$x$. Dually, $\Case[y]\x{P_1}{P_2}$ receives a disjoint sum
from channel $x$ and continues as either $P_1$ or $P_2$ depending on the tag
$\InTag_i$ it has been built with. For clarity, in some examples we will use
more descriptive labels such as $\AddTag$ and $\PayTag$ instead of $\LeftTag$
and $\RightTag$.
%
The terms $\Rec[y]\x.P$ and $\Corec[y]\x.P$ model processes that respectively
send and receive a new channel $y$ and then continue as $P$. They do not
contribute operationally to the interaction being modeled, but they indicate the
points in a program where (co)recursive types are unfolded.
%
A term $\Cut\x{P}{Q}$ denotes the parallel composition of two processes $P$ and
$Q$ that interact through the fresh channel $x$.
%
Finally, the term $\PiChoice{P}{Q}$ models a non-deterministic choice between two
behaviors $P$ and $Q$.

\piLIN binders are easily recognizable because they enclose channel names in
round parentheses. Note that all outputs are in fact \emph{bound outputs}. The
output of free channels can be modeled by combining bound outputs with
links \citep{LindleyMorris16}. For example, the output $\FreeFork\x\y\z$ of a
pair of free channels $y$ and $z$ can be modeled as the term
$\Fork[z']\x{y'}{\Link\y{y'}}{\Link\z{z'}}$.
%
We identify processes modulo renaming of bound names, we write $\fn{P}$ for the
set of channel names occurring free in $P$ and we write $\subst\y\x$ for the
capture-avoiding substitution of $y$ for the free occurrences of $x$.
%
We impose a well-formedness condition on processes so that, in every sub-term of
the form $\Fork[z]\x\y{P}{Q}$, we have $y \not\in\fn{Q}$ and $z\not\in\fn{P}$.

We omit any concrete syntax for representing infinite processes. Instead, we
work directly with infinite trees obtained by corecursively unfolding
contractive equations of the form $A(x_1,\dots,x_n) = P$. For each such
equation, we assume that $\fn{P} \subseteq \set{x_1,\dots,x_n}$ and we write
$\Call{A}{y_1,\dots,y_n}$ for its unfolding $P\subst{y_i}{x_i}_{1\leq i\leq n}$.

\begin{notation}
    \label{not:sessions}
    To reduce clutter due to the systematic use of bound outputs, by convention
    we omit the continuation called $y$ in \Cref{fig:proc_syntax_ll} when its name is
    chosen to coincide with that of the channel $x$ on which $y$ is
    sent/received.
    %
    For example, with this notation we have $\Join\x\z.P = \Join[x]\x\z.P$ and
    $\Select{\InTag_i}\x.P = \Select[x]{\InTag_i}\x.P$ and $\Case\x{P}{Q} =
    \Case[x]\x{P}{Q}$.
    %
    \eoe
\end{notation}

A welcome side effect of adopting \Cref{not:sessions} is that it gives the
illusion of working with a session calculus in which the same channel $x$ may be
used repeatedly for multiple input/output operations, while in fact $x$ is a
linear channel used for exchanging a single message along with a fresh
continuation that turns out to have the same name. If one takes this notation as
native syntax for a session calculus, its linear $\pi$-calculus
encoding \citep{DardhaGiachinoSangiorgi17} turns out to be precisely the \piLIN
term it denotes.
%
Besides, the idea of rebinding the same name over and over is widespread in
session-based functional languages \citep{GayVasconcelos10,Padovani17} as it
provides a simple way of ``updating the type'' of a session endpoint after each
use.

\begin{example}
    \label{ex:bsc_ll_proc}
    Below we model the interaction informally described in
    \Cref{ex:bsc} between \actor{buyer} and \actor{seller} using  the syntactic sugar
    defined in \Cref{not:sessions}:
    \[
    \begin{array}{@{}r@{~}l@{}}
    				& \Cut\x{\Call\Buyer\x}{\Call\Seller{x,y}} \\
            \Buyer(x) & =
            \Rec\x.\parens{
                \PiChoice{
                    \Select\AddTag\x.\Call\Buyer\x
                }{
                    \Select\PayTag\x.\PiClose\x
                }
            }
            \\
            \Seller(x,y) & =
            \Corec\x.
            \Case\x{
                \Call\Seller{x,y}
            }{
                \PiWait\x.\PiClose\y
            }
        \end{array}
    \]

    At each round of the interaction, the buyer decides whether to $\AddTag$ an
    item to the shopping cart and repeat the same behavior (left branch of the
    choice) or to $\PayTag$ the seller and terminate (right branch of the
    choice). The seller reacts dually and signals its termination by sending a
    unit on the channel $y$. As we will see in \Cref{sec:ts_ll_ts}, $\Rec\x$
    and $\Corec\x$ identify the points within processes where (co)recursive
    types are unfolded.

    If we were to define $\Buyer$ using distinct bound names we would write an
    equation like
    \[
        \Buyer(x) =
        \Rec[y]\x.
        \parens{
            \PiChoice{
                \Select[z]\AddTag\y.\Call\Buyer\z
            }{
                \Select[z]\PayTag\y.\PiClose\z
            }
        }
    \]
    and similarly for $\Seller$. 
    %
    \eoe
\end{example}