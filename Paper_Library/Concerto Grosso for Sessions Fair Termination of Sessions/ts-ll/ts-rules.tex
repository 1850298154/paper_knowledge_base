\beginbass
%
\begin{figure}[t]
  	\framebox[\textwidth]{
    \begin{mathpar}
        \inferrule{\mathstrut}{
            \qtp{x : \Formula_\addressA, y : \dual\Formula_\addressB}{\Link\x\y}
        }
        ~\defrule\LinkRule
        \and
        \inferrule{
            \qtp{\CtxC, x : S}{P}
            \\
            \qtp{\CtxD, x : \dual{S}}{Q}
        }{
            \qtp{\CtxC, \CtxD}{\Cut\x{P}{Q}}
        }
        ~\defrule\CutRule
        \and
        \inferrule{\mathstrut}{
            \qtp{\Ctx, x : \Top}{\Fail\x}
        }
        ~\defrule[fail]\FailRule
        \and
        \inferrule{
            \qtp\Ctx{P}
        }{
            \qtp{\Ctx, x : \Bot}{\PiWait\x.P}
        }
        ~\defrule[wait]\PiWaitRule
        \and
        \inferrule{\mathstrut}{
            \qtp{x : \One}{\PiClose\x}
        }
        ~\defrule[close]\PiCloseRule
        \and
        \inferrule{
            \qtp{\Ctx, y : S, z : T}{P}
        }{
            \qtp{\Ctx, x : S \tjoin T}{\Join[z]\x\y.P}
        }
        ~\defrule[join]\JoinRule
        \and
        \inferrule{
            \qtp{\CtxC, y : S}{P}
            \\
            \qtp{\CtxD, z : T}{Q}
        }{
            \qtp{\CtxC, \CtxD, x : S \tfork T}{\Fork[z]\x\y{P}{Q}}
        }
        ~\defrule[fork]\ForkRule
        \and
        \inferrule{
            \qtp{\Ctx, y : S}{P}
            \\
            \qtp{\Ctx, y : T}{Q}
        }{
            \qtp{\Ctx, x : S \plinbranch T}{\Case[y]\x{P}{Q}}
        }
        ~\defrule[case]\CaseRule
        \and
        \inferrule{
            \qtp{\Ctx, y : S_i}{P}
        }{
            \qtp{\Ctx, x : S_1 \plinchoice S_2}{\Select[y]{\InTag_i}\x.P}
        }
        ~\defrule[select]\SelectRule
        \and
        \inferrule{
            \qtp{\Ctx, y : S\subst{\tnu\X.S}X}{P}
        }{
            \qtp{\Ctx, x : \tnu\X.S}{\Corec[y]\x.P}
        }
        ~\defrule[corec]\CorecRule
        \and
        \inferrule{
            \qtp{\Ctx, y : S\subst{\tmu\X.S}X}{P}
        }{
            \qtp{\Ctx, x : \tmu\X.S}{\Rec[y]\x.P}
        }
        ~\defrule[rec]\RecRule
        \and
        \inferrule{
            \qtp\Ctx{P}
            \\
            \qtp\Ctx{Q}
        }{
            \qtp\Ctx{\PiChoice{P}{Q}}
        }
        ~\defrule\PiChoiceRule
    \end{mathpar}
    }
    \caption{Typing rules for \piLIN}
    \label{fig:ts_ll}
\end{figure}
%
We say that $P$ is \emph{quasi
typed} in $\Ctx$ if the judgment $\qtp\Ctx{P}$ is coinductively
derivable using the rules shown in \Cref{fig:ts_ll}
Rule \refrule{\LinkRule} states that a link $\Link\x\y$ is quasi typed provided
that $x$ and $y$ have dual types, but not necessarily dual addresses.
%
Rule \refrule{\CutRule} states that a process composition $\Cut\x{P}{Q}$ is
quasi typed provided that $P$ and $Q$ use the linear channel $x$ in
complementary ways, one according to some type $S$ and the other according to
the dual type $\dual{S}$. Note that the context $\CtxC,\CtxD$ in the
conclusion of the rule is defined provided that $\CtxC$ and $\CtxD$ have
disjoint domains. This condition entails that $P$ and $Q$ do not share any
channel other than $x$ ensuring that the interation between $P$ and $Q$ may
proceed without deadlocks.
%
Rule \refrule[fail]{\FailRule} deals with a process that receives an empty
message from channel $x$. Since this cannot happen, we allow the process to be
quasi typed in any context.
%
Rules \refrule[close]{\PiCloseRule} and \refrule[wait]{\PiWaitRule} concern the
exchange of units. The former rule states that $\PiClose\x$ is quasi typed in a
context that contains a single association for the $x$ channel with type $\One$,
whereas the latter rule removes $x$ from the context (hence from the set of
usable channels), requiring the continuation process to be quasi typed in the
remaining context.
%
Rules \refrule[fork]{\ForkRule} and \refrule[join]{\JoinRule} concern the
exchange of pairs. The former rule requires the two forked processes $P$ and $Q$
to be quasi typed in the respective contexts enriched with associations for the
continuation channels $y$ and $z$ being created. The latter rule requires the
continuation process to be quasi typed in a context enriched with the channels
extracted from the received pair.
%
Rules \refrule[select]{\SelectRule} and \refrule[case]{\CaseRule} deal with the
exchange of disjoint sums in the expected way.
%
Rules \refrule[rec]{\RecRule} and \refrule[corec]{\CorecRule} deal with fixed
point operators by unfolding the (co)recursive type of the channel $x$. As in
\muMALL, the two rules have exactly the same structure despite the fact that the
two fixed point operators being used are dual to each other. Clearly, the
behavior of least and greatest fixed points must be distinguished by some other
means, as we will see in \Cref{ssec:ts_ll_wtp} when discussing the validity of a
typing derivation.
%
Finally, \refrule{\PiChoiceRule} deals with non-deterministic choices by requiring
that each branch of a choice must be quasi typed in exactly the same typing
context as the conclusion.

Besides the structural constraints imposed by the typing rules, we implicitly
require that the types in the range of all typing contexts have pairwise
disjoint addresses. This condition ensures that it is possible to uniquely trace
a communication protocol in a typing derivation: if we have two channels $x$ and
$y$ associated with two types $\FormulaF_\addressA$ and $\FormulaG_\addressB$
such that $\addressA \prefix \addressB$, then we know that $y$ is a continuation
resulting from a communication that started from $x$. In a sense, $x$ and $y$
represent different moments in the same conversation.

\begin{remark}
	The typing rules in \Cref{fig:ts_ll} except \refrule{\PiChoiceRule} are in
	one-to-one correspondence with those of the \muMALL proof
	system \citep{BaeldeDoumaneSaurin16,Doumane17}. Concerning \refrule{\PiChoiceRule},
  it does not alter in any way the context of the process being typed.
  This implies that the type system is a conservative extension
  of \muMALL. That is, if $\qtp{x_1:S_1,\dots,x_n:S_n}{P}$ is coinductively
  derivable using the rules in \Cref{fig:ts_ll}, then $\vdash
  S_1,\dots,S_n$ is coinductively derivable in \muMALL. The converse is also true,
  although the proof term $P$ is not uniquely determined.
\end{remark}

\begin{example}[Buyer - Seller]
    \label{ex:bsc_ll_ts}
    Let us show that the system described in \Cref{ex:bsc_ll_proc} is quasi
    typed. To this aim, let $\FormulaF \eqdef \tmu\X.X \plinchoice \One$ and
    $\FormulaG \eqdef \tnu\X.X \plinbranch \Bot$ respectively be the formulas
    describing the behavior of $\Buyer$ and $\Seller$ on the channel $x$. Note
    that $\FormulaG = \dual\FormulaF$ and let $a$ be an arbitrary atomic
    address. We derive
    %
    \[
        \begin{prooftree}
            \[
                \[
                    \[
                        \mathstrut\smash\vdots
                        \justifies
                        \qtp{
                            x : \FormulaF_{ail}
                        }{
                            \Call\Buyer\x
                        }
                    \]
                    \justifies
                    \qtp{
                        x : (\FormulaF \plinchoice \One)_{ai}                        
                    }{
                        \Select\AddTag\x.\Call\Buyer\x
                    }
                    \using\refrule[select]\SelectRule
                \]
                \qquad
                \[
                    \[
                        \justifies
                        \qtp{
                            x : \One
                        }{
                            \PiClose\x
                        }
                        \using\refrule[close]{\PiCloseRule}
                    \]
                    \justifies
                    \qtp{
                        x : (\FormulaF \plinchoice \One)_{ai}
                    }{
                        \Select\PayTag\x.\PiClose\x
                    }
                    \using\refrule[select]{\SelectRule}
                \]
                \justifies
                \qtp{
                    x : (\FormulaF \plinchoice \One)_{ai}
                }{
                    \PiChoice{
                        \Select\AddTag\x.\Call\Buyer\x
                    }{
                        \Select\PayTag\x.\PiClose\x
                    }
                }
                \using\refrule{\PiChoiceRule}
            \]
            \justifies
            \qtp{
                x : \FormulaF_a
            }{
                \Call\Buyer\x
            }
            \using\refrule[rec]{\RecRule}
        \end{prooftree}
    \]
    and also
    \[
        \begin{prooftree}
            \[
                \[
                    \mathstrut\smash\vdots
                    \justifies
                    \qtp{
                        x : \FormulaG_{\dual{a}il},
                        y : \One
                    }{
                        \Call\Seller{x,y}
                    }
                \]
                \qquad
                \[
                    \[
                        \justifies
                        \qtp{
                            y : \One
                        }{
                            \PiClose\y
                        }
                        \using\refrule[close]{\PiCloseRule}
                    \]
                    \justifies
                    \qtp{
                        x : \Bot,
                        y : \One
                    }{
                        \PiWait\x.\PiClose\y
                    }
                    \using\refrule[wait]{\PiWaitRule}
                \]
                \justifies
                \qtp{
                    x : (\FormulaG \plinbranch \Bot)_{\dual{a}i},
                    y : \One
                }{
                    \CaseX\x{
                        \Call\Seller{x,y}
                    }{
                        \PiWait\x.\PiClose\y
                    }            
                }
                \using\refrule[case]{\CaseRule}
            \]
            \justifies
            \qtp{
                x : \FormulaG_{\dual{a}},
                y : \One
            }{
                \Call\Seller{x,y}
            }
            \using\refrule[corec]{\CorecRule}
        \end{prooftree}
    \]
    %
    showing that $\Buyer$ and $\Seller$ are quasi typed. Note that both
    derivations are infinite, but for dual reasons. In $\Buyer$ the infinite
    branch corresponds to the behavior in which $\Buyer$ chooses to add one more
    item to the shopping cart. This choice is made independently of the behavior
    of other processes in the system. In $\Seller$, the infinite branch
    corresponds to the behavior in which $\Seller$ receives one more $\AddTag$
    message from $\Buyer$.
    %
    By combining these derivations we obtain
    %
    \[
        \begin{prooftree}
            \[
                \mathstrut\smash\vdots
                \justifies
                \qtp{
                    x : \FormulaF_a
                }{
                    \Call\Buyer\x
                }
            \]
            \qquad
            \[
                \mathstrut\smash\vdots
                \justifies
                \qtp{
                    x : \FormulaG_{\dual{a}},
                    y : \One
                }{
                    \Call\Seller{x,y}
                }
            \]
            \justifies
            \qtp{
                y : \One
            }{
                \Cut\x{\Call\Buyer\x}{\Call\Seller{x,y}}
            }
            \using\refrule{\CutRule}
        \end{prooftree}
    \]
    %
    showing that the system as a whole is quasi typed.
    %
    \eoe
\end{example}