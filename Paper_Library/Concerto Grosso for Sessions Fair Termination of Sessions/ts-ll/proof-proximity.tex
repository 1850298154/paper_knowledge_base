\beginbass
%
The cut elimination result of \muMALL is proved by introducing a \emph{multicut}
rule that collapses several unguarded cuts in a single rule having a variable
number of premises. The usefulness of working with multicuts is that they
prevent infinite sequences of reductions where two cuts are continuously
permuted in a non-productive way and no real progress is made in the cut
elimination process. In the type system of \piLIN we do not have a typing rule
corresponding to the multicut. At the same time, the troublesome permutations of
cut rules correspond to applications of the associativity law of parallel
composition, namely of the \refrule{sp-assoc} pre-congruence rule. That is, the
introduction of the multicut rule in the cut elimination proof of \muMALL
corresponds to working with \piLIN terms considered equal up to structural
pre-congruence. Nonetheless, since the \piLIN reduction rules require two
processes willing to interact on some channel $x$ to be the children of the same
application of \refrule\CutRule, it is not entirely obvious that \emph{not}
introducing an explicit multicut rule allows us to perform in \piLIN all the
principal reductions that are performed during the cut elimination process in a
\muMALL proof.

Here we show that this is actually the case by proving a so-called
\emph{proximity lemma}, showing that every well-typed process can be rewritten
in a structurally pre-congruent one where any two processes in which the same
channel $x$ occurs free are the children of a cut on $x$.
%
To this aim, we introduce \emph{process contexts} to refer to unguarded
sub-terms of a process. Process contexts are processes with a single unguarded
\emph{hole} $\Hole$ and are generated by the following grammar:
\[
    \textbf{Process context} \qquad
    \PCtxC, \PCtxD ~~::=~~
    \Hole ~~\mid~~
    \Cut\x\PCtx{P} ~~\mid~~
    \Cut\x{P}\PCtx
\]

As usual we write $\PCtx[P]$ for the process obtained by replacing the
hole in $\PCtx$ with $P$. Note that this substitution is not
capture-avoiding in general and some free names occurring in $P$ may be captured
by binders in $\PCtx$. We write $\bn\cdot$ for the function
inductively defined by
\[
  \bn\Hole = \emptyset
  \text{\qquad and \qquad}
  \bn{\Cut\x\PCtx{P}} = \bn{\Cut\x{P}\PCtx} = \set\x \cup \bn\PCtx
\]

The next lemma shows that a cut on $x$ can always be pushed down towards any
process in which $x$ occurs free.

\begin{lemma}
    \label{lem:push-down}
    If $x\in\fn{P} \setminus \bn\PCtxC$, then $\Cut\x{\PCtxC[P]}{Q} \pcong
    \PCtxD[\Cut\x{P}{Q}]$ for some $\PCtxD$.
  \end{lemma}
\begin{proof}
    By induction on the structure of $\PCtxC$ and by cases on its
    shape.

      \proofcase{Case $\PCtxC = \Hole$}
        %
        We conclude by taking $\PCtxD \eqdef \Hole$ using the
        reflexivity of $\pcong$. 

      \proofcase{Case $\PCtxC = \Cut\y{\PCtxC'}{R}$}
        %
        From the hypothesis $x \in \fn{P} \setminus \bn\PCtxC$ we
        deduce $x \ne y$ and $x \in \fn{P} \setminus \bn{\PCtxC'}$.
        %
        Using the induction hypothesis we deduce that there exists
        $\PCtxD'$ such that $\Cut\x{\PCtxC'[P]}{Q} \pcong
        \PCtxD'[\Cut\x{P}{Q}]$. Take $\PCtxD \eqdef
        \Cut\y{\PCtxD'}{R}$. We conclude
        \[
            \begin{array}{rcll}
                \Cut\x{\PCtxC[P]}{Q}
                & = & \Cut\x{\Cut\y{\PCtxC'[P]}{R}}{Q} & \text{by definition of $\PCtxC$}
                \\
                & \pcong & \Cut\x{Q}{\Cut\y{\PCtxC'[P]}{R}} & \text{by \refrule{sp-comm}}
                \\
                & \pcong & \Cut\y{\Cut\x{Q}{\PCtxC'[P]}}{R} & \text{from $x \in \fn{P} \setminus \bn\PCtxC$} \\
                & & & \text{and \refrule{sp-assoc}}
                \\
                & \pcong & \Cut\y{\Cut\x{\PCtxC'[P]}{Q}}{R} & \text{by \refrule{sp-comm}}
                \\
                & \pcong & \Cut\y{\PCtxD'[\Cut\x{P}{Q}]}{R} & \text{by induction hypothesis}
                \\
                & = & \PCtxD[\Cut\x{P}{Q}] & \text{by definition of $\PCtxD$}
            \end{array}
        \]

      \proofcase{Case $\PCtxC = \Cut\y{R}{\PCtxC'}$}
        %
        Analogous to the previous case.
\end{proof}

The proximity lemma is then proved by applying \Cref{lem:push-down} twice.

\begin{lemma}[Proximity]
    \label{lem:proximity_ll}
    \brk
    If $x\in\fn{P_i}\setminus\bn{\PCtxC_i}$ for $i=1,2$, then
    $\PCtxC[\Cut\x{\PCtxC_1[P_1]}{\PCtxC_2[P_2]} \pcong
    \PCtxD[\Cut\x{P_1}{P_2}]$ for some $\PCtxD$.
\end{lemma}
\begin{proof}
    It suffices to apply \Cref{lem:push-down} twice, thus:
    \[
        \begin{array}{@{}r@{~}c@{~}ll@{}}
            \PCtxC[\Cut\x{\PCtxC_1[P_1]}{\PCtxC_2[P_2]}
            & \pcong & \PCtxC[\PCtxD_1[\Cut\x{P_1}{\PCtxC_2[P_2]}]]
            & \text{using the hypothesis} \\
            & & & \text{and \Cref{lem:push-down}}
            \\
            & \pcong & \PCtxC[\PCtxD_1[\Cut\x{\PCtxC_2[P_2]}{P_1}]]
            & \text{by \refrule{sp-assoc}}
            \\
            & \pcong & \PCtxC[\PCtxD_1[\PCtxD_2[\Cut\x{P_2}{P_1}]]]
            & \text{using the hypothesis} \\
            & & & \text{and \Cref{lem:push-down}}
            \\
            & \pcong & \PCtxC[\PCtxD_1[\PCtxD_2[\Cut\x{P_1}{P_2}]]]
            & \text{by \refrule{sp-assoc}}
        \end{array}
    \]
    and we conclude by taking $\PCtxD \eqdef \PCtxC[\PCtxD_1[\PCtxD_2]]$.
\end{proof}

Notably, \Cref{lem:proximity_ll} corresponds to \Cref{lem:proximity_bin,lem:proximity_multi} that 
we proved in the session based scenarios.