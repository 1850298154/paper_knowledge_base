\begintreble
%
Let us briefly summarize the two main contents of this thesis.
First, we introduced \emph{fair termination} as a desirable property in
systems  based on communication as it entails many well known properties
that are studied in the literature. 
However, providing a type system for enforcing fair termination is not straightforward
as there exist some peculiar scenarios in which the liveness is compromised. 
Then, due to the increasing interest of research communities in proof assistants we
decided to focus on some mechanization aspects. Notably, generalized inference
systems have been a transversal topic throughout the thesis as most of the time we relied on them
for characterizing the definitions that we needed.

\paragraph{Type Systems}
On the one hand, in \Cref{ch:ft_bin,ch:ft_multi} we presented a type system for
binary/multiparty sessions which involved \emph{fair subtyping}. Then we showed
that fair subtyping must be used carefully, that is, finitely many times when it has a strictly
positive weight. The main advantage of the type systems under analysis is that 
they allow for compositional reasoning.
On the other hand, in \Cref{ch:ft_ll} we presented a linear logic inspired type system for
the linear $\pi$-calculus. In this case there is no subtyping relation. A peculiar 
aspect was that we could type both a fair and an unfair process (see \Cref{ex:slot_comp})
by using the same type/formula. Differently with respect to the type systems in
\Cref{ch:ft_bin,ch:ft_multi}, the enforcement of fair termination 
is based on a global \emph{validity condition}.
At last, we showed that the type systems cannot be compared which leads to interesting
research directions.
Apart from the technique being used for developing the type systems, we hope
that the reader has been convinced that fair termination is a fundamental
property for communication-based calculi.

\paragraph{Agda Mechanizations}
In \Cref{ch:gis_lib} we introduce a library for supporting
generalized inference systems in Agda. Differently, to the built-in techniques, 
the library allows to provide \emph{modular}
definitions that can be composed without duplicating notions.
We then took advantage of such library for characterizing
the properties of session types in \Cref{ch:agda_prop}. 
The main aim was to show that well known properties
could be turned into \emph{fair} ones by adding corules and without changing
the main inference systems (see \Cref{sec:agda_fs}). 
The application of foundational aspects to session types tried to provide
a useful guideline for those researchers involved in the formalization of
session type based calculi. Indeed, we also relied on a peculiar definition
of session types that aims at simplifying the definition of the predicates on them.
We hope to have provided some helpful suggestions for realizing the dream according
to which one day all the proofs will be certified.

\section*{Future Work}

We conclude the thesis by inspecting some possible research directions that we can 
take in the future. We are grateful to all the anonymous reviewers of the articles
that we have submitted during these years as they suggested many interesting
topics that we mention in this section.

\paragraph{Fair Termination of Sessions}
An open question that may have a relevant practical impact is whether the
type system in \Cref{ch:ft_bin,ch:ft_multi} remain \emph{sound} 
in a setting where communications are
\emph{asynchronous}. We expect the answer to be positive, as is the case for
other synchronous multiparty session types systems \citep{ScalasYoshida19}, but
we have not worked out the details yet. 
Then, a natural development of these type systems is their application to a
real programming environment. We envision two approaches that can be followed to
this aim. A bottom-up approach may apply our static analysis technique to a
program (in our process calculus) that is extracted from actual code and that
captures the code's communication semantics. We expect that suitable annotations
may be necessary to identify those branching parts of the code that represent
non-deterministic choices in the program. Most typically, these branches will
correspond to finite loops or to queries made to the human user of the program
that have several different continuations. A top-down approach may provide
programmers with a \emph{generative tool} that, starting from a global
specification in the form of a \emph{global type} \citep{HondaYoshidaCarbone16},
produces template code that is ``well-typed by design'' and that the programmer
subsequently instantiates to a specific application.
Scribble \citep{YoshidaHuNeykovaNg13,AnconaEtAl16} is an example of such a tool.
Interestingly, the usual notion of global type projectability is not sufficient
to entail that the session map resulting from a projection is coherent. However,
coherence would be guaranteed by requiring that the projected global type is
fairly terminating.
%
Finally, we plan to investigate the adaptation of the type system for ensuring
the fair termination in the popular actor-based model. This is a drastically
different setting in which the order of messages is not as controllable as in
the case of sessions. As a consequence, type based analyses require radically
different formalisms such as mailbox types \citep{deLiguoroP18}, for which the
study of fair subtyping and of type systems enforcing fair termination is
unexplored. 

\paragraph{Validity in \piLIN}
One drawback of the type system proposed in \Cref{ch:ft_ll} is that establishing whether a
quasi-typed process is also well typed requires a global check on the whole
typing derivation. This does not happen in the type systems for sessions
in \Cref{ch:ft_bin,ch:ft_multi}.
The need for a global check seems to arise commonly in infinitary proof
systems \citep{DaxHofmannLange06,Doumane17,BaeldeDoumaneSaurin16,BaeldeEtAl22},
so an obvious aspect to investigate is whether the analysis can be localized. A
possible source of inspiration for devising a local type system for \piLIN might
come from the work of \cite{DerakhshanPfenning19}. They
propose a compositional technique for dealing with infinitary typing derivations
in a session calculus, although their type system is limited to the additive
fragment of linear logic.

\paragraph{Fair Subtyping and Linear Logic}
In \Cref{sec:comparison} we showed that the type systems in \Cref{ch:ft_bin,ch:ft_multi}
and the one in \Cref{ch:ft_ll} cannot be compared. 
In particular, \Cref{ex:slot_comp} points out a fundamental difference between the two
approaches, that is, the presence or absence of fair subtyping.
Given the rich
literature exploring the connections between linear logic and session types,
\piLIN and its type system might provide the right framework for investigating
the logical foundations of fair subtyping.


\paragraph{Inference Systems in Agda}
For future work we plan to extend the library that we 
presented in \Cref{ch:gis_lib} in several directions. 
The first one is to support other interpretations of inference systems, 
such as the \emph{regular} one \citep{Dagnino20}, which is basically 
coinductive but allows only proof trees with finitely many distinct subtrees.
To this end, useful starting points are works on regular terms and streams 
\citep{Spadotti16,UustaluV17} and on finite sets \citep{FirsovU15} in dependent type theories.
The challenging part is the finiteness constraint, which is not trivial in a type-theoretic setting. 
A second direction is to implement other proof techniques for (flexible) coinduction, 
as parametrized coinduction \citep{HurNDV13} and up-to techniques \citep{Pous16,Danielsson18}. 
Finally, another direction could be the development of a full framework for composition 
of inference systems, along  the lines of seminal work on module systems \citep{Bracha92}. 
On the more practical side, a further development is to transform the methodology in 
an automatic translation. That is, a user should be allowed to write an inference system 
(with corules) in a natural syntax, and the corresponding Agda types should be 
generated automatically, either by  an external tool, or, more interestingly, 
using \emph{reflection}, recently added in Agda.
