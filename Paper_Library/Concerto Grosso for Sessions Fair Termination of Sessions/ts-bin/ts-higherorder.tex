\beginbass
%
We have defined fair subtyping in such a way that higher-order session types are \emph{invariant} 
with respect to the type of the channel being exchanged (see \refrule{fs-channel}). 
This is a limitation compared to traditional presentations of unfair subtyping 
\citep{GayHole05,CastagnaDezaniGiachinoPadovani09,BernardiHennessy16}, 
where the covariant/contravariant rules shown below are adopted (\refrule{us-channel-in}, \refrule{us-channel-out}):
\[
        \inferrule{
          \S \usubt \T \\ \U \usubt \V
        }{
          \In\U.\S \usubt \In\V.\T
        }
        \qquad\qquad
        \inferrule{
          \S \usubt \T \\ \V \usubt \U
        }{
          \Out\U.\S \usubt \Out\V.\T
        }
\]

The problem of these rules is that a single application of fair subtyping allowing for 
co-/contra-variance of higher-order session types may have the same overall effect of 
infinitely many applications of fair subtyping on first-order session types and, 
as we have seen in \Cref{ssec:boundedness}, unbounded applications of fair subtyping may compromise fair termination.
%
Below is an example that illustrates the problem. The example is not large \emph{per se}, 
but it is a bit contrived because it has to involve two sessions 
(or else there would be no need for higher-order session types), 
it must be bounded (or else it could be ruled out by the 
action/session/cast boundedness requirements) and non-terminating.

\begin{example}
    \label{ex:invariant_ch}
    \[
    	\begin{array}{@{}r@{~}l@{}}
    	& \NewPar\y{\NewPar\x{\Call A {x,y}}{\Call B x}}{\Call B y}
    	\\
    	\Definition{A}{x,y}{& \POutput\x\lmore.\POutput\x\y.\Call B x}
    	\\
    	\Definition{B}{x}{&
        \PRecv\x{
        	\lmore : \PInput\x{(y)}.\Call A {y,x},
        	\lstop : \Wait\x\Done
        }
    	}	
    	\end{array}
    \]
    The process models a \emph{master} $\Call A {x,y}$ connected with a
	\emph{primary slave} $\Call B x$ and a \emph{secondary slave} $\Call B y$
	through the sessions $x$ and $y$. The interaction among the three processes
	proceeds in rounds. At each round, the master may decide whether to continue or
	stop the interaction by sending either $\lmore$ or $\lstop$ on the session $x$
	to the primary slave. If the master decides to continue the interaction (which
	it does deterministically), it also delegates $y$ to the primary slave so that,
	at the next round, the roles of the three processes rotate: the master is
	downgraded to secondary slave, the primary slave is promoted to master, and the
	secondary slave becomes the primary one.
	%
	\eoe
\end{example}

Below is a graphical representation of
the network topology modeled by the process in \Cref{ex:invariant_ch} and of its evolution:
\[
    \tikzset{baseline=1.25em}
    \tikz[thick]{
    \node (M) at ( 0   ,1) {$\Call A {x,y}$};
    \node (P) at (-0.75,0) {$\Call B x$};
    \node (S) at ( 0.75,0) {$\Call B y$};
    \draw (P) -- (M) -- (S);
    }
    \wred
    \tikz[thick]{
    \node (S) at ( 0   ,1) {$\Call B x$};
    \node (M) at (-0.75,0) {$\Call A {y,x}$};
    \node (P) at ( 0.75,0) {$\Call B y$};
    \draw (P) -- (M) -- (S);
    }
    \wred
    \tikz[thick]{
    \node (P) at ( 0   ,1) {$\Call B x$};
    \node (S) at (-0.75,0) {$\Call B y$};
    \node (M) at ( 0.75,0) {$\Call A {x,y}$};
    \draw (P) -- (M) -- (S);
    }
    \wred
    \tikz[thick]{
    \node (M) at ( 0   ,1) {$\Call A {y,x}$};
    \node (P) at (-0.75,0) {$\Call B y$};
    \node (S) at ( 0.75,0) {$\Call B x$};
    \draw (P) -- (M) -- (S);
    }
    %\wred\cdots
\] 

It is clear that the process in \Cref{ex:invariant_ch} does not terminate since 
there is no $\Close\x$ to match the $\Wait\x\Done$.
%
It is also relatively easy to infer the types of $x$ and $y$ from the structure of 
$A(x,y)$ and $B(x)$. In particular, if we call $S_A$ and $T_A$ the types of $x$ and 
$y$ in $A(x,y)$ and $S_B$ the type of $x$ in $B(x)$ we see that these types must satisfy the equations
\[
\begin{array}{rcl}
	 	S_A & = & \Out\lmore.\Out\T_A.S_B
    \\
    S_B & = & \In\lmore.\In\S_A.T_A \branch \In\lstop.\End[\In]
    \\
    T_A & = & \Out\lmore.\Out\T_A.S_B \choice \Out\lstop.\End[\Out]
\end{array}
\]

Note that $T_A \subt[1] S_A$ holds because $T_A$ and $S_A$ differ only for the topmost output. 
The validity of this relation is unquestionable as it relies on the definition of fair subtyping 
that we have given in \Cref{sec:fair_sub}, which is invariant with respect to higher-order session types.
%
\begin{remark}
	In the following we assume to have two rules for fair subtyping allowing for 
	co-/contra-variance of channel input and output, respectively.
	\[
        \inferrule[ch-in]{
          \S \subt[m] \T \\ \U \subt[n] \V
        }{
          \In\U.\S \subt[k] \In\V.\T
        }\defrule[ch-in]{}
        \qquad\qquad
        \inferrule[ch-out]{
          \S \subt[m] \T \\ \V \subt[n] \U
        }{
          \Out\U.\S \subt[k] \Out\V.\T
        }\defrule[ch-out]{}
	\]
	where $k \in F(m,n)$ concerning the input and $k \in G(m,n)$ concerning the output.
	Note that $F,G : \Nat \times \Nat \rightarrow \mathcal{P_*}(\Nat)$.
	However, \refrule{tb-channel-in} and \refrule{tb-channel-out} are still invariant.
	%
	\eor
\end{remark}
%
If fair subtyping allowed for covariance of higher-order inputs (see \refrule{us-channel-in}, \refrule{us-channel-out}),
then $\co{T_A} \subt S_B$, $\co{S_B} \subt T_A$ (along with $\co{S_B} \subt S_A$ by transitivity of $\subt$)  
would also hold and we would be able to establish that the process 
in \Cref{ex:invariant_ch} is well typed, provided that casts are placed appropriately. 

\begin{example}
	We show the derivation for the judgment $\co{T_A} \subt[k] S_B$ for some $k$.
	\[
	\begin{prooftree}
		\[
			\[
				\vdots
				\justifies
				T_A \subt[1] S_A
			\]
			\[
				\vdots
				\justifies
				\co{T_A} \subt[k] S_B
			\]
			\justifies
			\Out{S_A}.\co{T_A} \subt[m] \Out{T_A}.S_b
			\using\refrule{ch-out}
		\]
		\[
			\vdots
			\justifies
			\Out\lstop.\End[\Out] \subt[0] \Out\lstop.\End[\Out] 
		\]
		\justifies
		\co{S_B} \subt[1] T_A
		\using\refrule{fsb-tag-out-2}
	\end{prooftree}
	\]
	\[
	\begin{prooftree}
		\[
			\[
				\vdots
				\justifies
				T_A \subt[1] S_A
			\]
			\[
				\vdots
				\justifies
				\co{S_B} \subt[1] T_A
				%\using\refrule{fsb-tag-out-2}
			\]
			\justifies
			\In{T_A}.\co{S_B} \subt[k] \In{S_A}.T_A
			\using\refrule{ch-in}
		\]
		\[
			\vdots
			\justifies
			\In\lstop.\End[\In] \subt[0] \In\lstop.\End[\In]
		\]
		\justifies
		\co{T_A} \subt[k] S_B
		\using\refrule{fsb-tag-in}
	\end{prooftree}
	\]
	Note that $m \in G(1,k)$ and $k \in F(1,1)$. Hence, a solution is guaranteed to exist.
	For this reason, in the following we omit the weight of the subtyping judgments involving
	\refrule{ch-in} and \refrule{ch-out}. It suffices to know that such judgments are derivable.
	%
	\eoe
\end{example}

\begin{example}
    \label{ex:annotated_delegation}
    We show a version of the process in \Cref{ex:invariant_ch} in which 
    we have annotated restrictions with the types $\Sys\S\T$ 
		of the two endpoints and casts with the target type of the channel affected by subtyping. 
    \[
    \NewPar{y : \hl{\Sys{T_A}{\co{T_A}}}}{
        \NewPar{x : \hl{\Sys{T_A}{\co{T_A}}}}{
            \Cast{x : \hl{S_A}}
            \Call A {x,y}
        }{
            \Cast{x : \hl{S_B}}
            \Call B x
        }
    }{
        \Cast{y : \hl{S_B}}
        \Call B y
    }
    \]
    We provide another formulation of such process which is well-typed as well.
    \[
    \NewPar{y : \hl{\Sys{\co{S_B}}{S_B}}}{
        \NewPar{x : \hl{\Sys{\co{S_B}}{S_B}}}{
            \Cast{x : \hl{S_A}}
            \Cast{y : \hl{T_A}}
            \Call A {x,y}
        }{
            \Call B x
        }
    }{
        \Call B y
    }
		\]
    %
    \eoe
\end{example}

\begin{example}
	We show that the process in \Cref{ex:annotated_delegation} is well typed.
	Below is the partial proof tree showing that $\Call{A}{x,y}$ is well typed. 
	Each judgment is implicitly annotated with the rank $0$:
	\[
    \begin{prooftree}
    \[
        \[
            \[
                \smash\vdots\mathstrut
                \justifies
                \wtp{x : S_B}{\Call{B}{x}}
                \using\refrule{tb-call}
            \]
            \justifies
            \wtp{x : \Out\T_A.S_B, y : T_A}{
                \POutput\x\y.\Call{B}{x}
            }
            \using\refrule{tb-channel-out}
        \]
        \justifies
        \wtp{x : S_A, y : T_A}{
            \POutput\x\lmore.\POutput\x\y.\Call{B}{x}
        }
        \using\refrule{tb-tag}
    \]
    \justifies
    \wtp{x : S_A, y : T_A}{\Call{A}{x,y}}
    \using\refrule{tb-call}
    \end{prooftree}
	\]
	Below is the partial proof tree showing that $\Call{B}{x}$ is well typed. Each judgment is implicitly annotated with the rank $0$:
	\[
    \begin{prooftree}
    \[
        \[
            \[
                \smash\vdots\mathstrut
                \justifies
                \wtp{x : T_A, y : S_A}{
                \Call{A}{y,x}
                }
                \using\refrule{tb-call}
            \]
            \justifies
            \wtp{x : \In\S_A.T_A}{
                \PInput\x{(y)}.\Call{A}{y,x}
            }
            \using\refrule{tb-channel-in}
        \]
        \[
            \[
                \justifies
                \wtp\emptyset\Done
                %\using\refrule{tb-done}
            \]
            \justifies
            \wtp{x : \End[\In]}{
                \Wait\x\Done
            }
            %\using\refrule{tb-wait}
        \]
        \justifies
        \wtp{x : S_B}{
        \PRecv\x{
            \lmore : \PInput\x{(y)}.\Call{A}{y,x},
            \lstop : \Wait\x\Done
        }
        }
        %\using\refrule{tb-tag}
    \]
    \justifies
    \wtp{x : S_B}{
        \Call{B}{x}
    }
    %\using\refrule{tb-call}
    \end{prooftree}
	\]
	Finally, here is the partial proof tree showing that the process shown in \Cref{ex:annotated_delegation} is well typed
	(again, we omit rank information since \refrule{ch-in} and \refrule{ch-out} are used):
	\[
    \begin{prooftree}
    \[
        \[
            \[
                \smash\vdots\mathstrut
                \justifies
                \wtp{x : T_A, y : S_A}{\Call{A}{x,y}}
                %\using\refrule{tb-call}
            \]
            \justifies
            \wtp{
                x : S_A,
                y : S_A
            }{
                \Cast\x \Call{A}{x,y}
            }
            %\using\refrule{tb-cast}
        \]
        \[
            \[
                \smash\vdots\mathstrut
                \justifies
                \wtp{x : T_B}{\Call{B}{x}}
                %\using\refrule{tb-call}
            \]
            \justifies
            \wtp{
                x : \co{S_A}
            }{
                \Cast\x \Call{B}{x}
            }
            %\using\refrule{tb-cast}
        \]
        \justifies
        \wtp{y : S_A}{
            \NewPar\x{
                \Cast\x \Call{A}{x,y}
            }{
                \Cast\y \Call{B}{x}
            }
        }
       % \using\refrule{tb-par}
    \]
    \[
        \[
            \smash\vdots\mathstrut
            \justifies
            \wtp{
                y : T_B
            }{
                \Call{B}{y}
            }
            %\using\refrule{tb-call}
        \]
        \justifies
        \wtp{
            y : \co{S_A}
        }{
            \Cast\y \Call{B}{y}
        }
        %\using\refrule{tb-cast}
    \]
    \justifies
    \wtp\emptyset{
        \NewPar\y{
            \NewPar\x{
                \Cast\x \Call{A}{x,y}
            }{
                \Cast\x \Call{B}{x}
            }
        }{
            \Cast\y \Call{B}{y}
        }
    }
    %\using\refrule{tb-par}
    \end{prooftree}
	\]
	%
	\eoe
\end{example}

By restricting fair subtyping of higher-order session types to invariant inputs and outputs, 
the only chance we have to build a typing derivation for the process in \Cref{ex:invariant_ch} 
is by casting $y$ each time it is delegated, either before it is sent or after it is received.

\begin{example}
	Consider the following variant of \Cref{ex:invariant_ch}:
	\[
    \begin{array}{r@{~}l}
    \Definition{A}{x : \hl{U_A},y : \hl{V_A}}{&
        \POutput\x\lmore.
        \Cast{y : \hl{U_A}}
        \POutput\x\y.
        \Call B x
    } \\
    \Definition{B}{x : \hl{U_B}}{&
        \PRecv\x{
            \lmore : \PInput\x{(y : \hl{U_A})}.\Call A {y,x},
            \lstop : \Wait\x\Done
        }
    }
    \end{array}
	\]
	where
	\[
	\begin{array}{rcl}
		U_A & = & \Out\lmore.\Out\U_A.U_B \\
		U_B & = & \In\lmore.\In\U_A.V_A \branch \In\lstop.\End[\In] \\
		V_A & = & \Out\lmore.\Out\U_A.U_B \choice \Out\lstop.\End[\Out]
	\end{array}
	\]
	Note that $\Cast{y : U_A}$ is a ``first-order'' cast, in the sense that the relation $V_A \subt[1] U_A$ 
	holds for fair subtyping as defined in \Cref{sec:fair_sub} without using \refrule{us-channel-in} or \refrule{us-channel-out}, 
	but the cast is now placed in a region within the definition of $A$ that prevents finding a finite rank for $A$.
	%
	\eoe
\end{example}
