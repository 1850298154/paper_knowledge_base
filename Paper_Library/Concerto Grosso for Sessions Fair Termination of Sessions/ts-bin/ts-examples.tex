\beginbass
%
In this section we present some examples of well-typed processes using the 
type system introduced in the previous section.
%
In particular, we first complete the variant (see \Cref{ex:bsc_bin_proc}) of the
running example (see \Cref{ex:bsc}). 
Then, we show some examples where some of them are 
related to the boundedness properties that we 
presented in \Cref{ssec:boundedness}.

\begin{example}
    \label{ex:bsc_ts}
    To show that the program defined in \Cref{ex:bsc_bin_proc} is well typed,
    consider the session types $S_b'$ and $S_s$, $\T_s$, $\T_c$ (see \Cref{ex:bin_bsc}).
		\[
		\begin{array}{ll}
			S_b' = \In\ladd.S_b' \branch \In\lpay.\End[\In]
			& \qquad
			S_s = \Out\ladd.(\Out\ladd.S_s \choice \Out\lpay.\End[\Out])
			\\
			T_s = \Out\lship.\End[\Out]
			& \qquad
			T_c = \In\lship.\End[\In]
		\end{array}
		\]    
    and the global type assignments
    \[
    \begin{array}{ll}
    	\tass{\Buyer}{S_b'}{0}
    	& \qquad
    	\tass{\Seller}{S_s, T_s}{0}
    	\\
    	\tass{\Carrier}{T_c}{0}
    	& \qquad
    	\tass\Main{()}{3}
    \end{array}
    \]
    %
    We can obtain typing derivations for $\Buyer$, $\Seller$ and $\Carrier$ using a null rank.
    %
    In particular, we derive
    \[
        \begin{prooftree}
            \[
                \[
                    \smash\vdots\mathstrut
                    \justifies
                    \wtp[0]{
                        x : \S_b'
                    }{
                        \Call{\Buyer}{x}
                    }
                    \using\refrule{tb-call}
                \]
                \[
                    \justifies
                    \wtp[0]{
                        x : \End[\Out]
                    }{
                        \Close\x
                    }
                    \using\refrule{tb-close}
                \]
                \justifies
                \wtp[0]{
                    x : \Out\ladd.\S_b' \choice \Out\lpay.\End[\Out]
                }{
                    \PSend\x{
                        \ladd : \Call \Buyer x,
                        \lpay : \Close\x
                    }
                }
                \using\refrule{tb-label}
            \]
            \justifies
            \wtp[0]{
                x : \S_b'
            }{
                \POutput\x\ladd.
                \PSend\x{
                  \ladd : \Call \Buyer x,
                  \lpay : \Close\x
                }    
            }
            \using\refrule{tb-label}
        \end{prooftree}
    \]
    for the definition of $\Buyer$ and
    \[
        \begin{prooftree}
            \[
                \smash\vdots
                \justifies
                \wtp[0]{
                    x : \S_s,
                    y : \T_s
                }{
                    \Call \Seller {x,y}
                }
            \]
            \[
                \[
                    \[
                        \justifies
                        \wtp[0]{
                            y : \End[\Out]
                        }{
                            \Close\y
                        }
                        \using\refrule{tb-close}
                    \]
                    \justifies
                    \wtp[0]{
                        y : \T_s
                    }{
                        \POutput\y\lship.\Close\y
                    }
                    \using\refrule{tb-label}
                \]
                \justifies
                \wtp[0]{
                    x : \End[\Out],
                    y : \T_s
                }{
                    \Wait\x{\dots}
                }
                \using\refrule{tb-wait}
            \]
            \justifies
            \wtp[0]{
                x : \S_s,
                y : \T_s
            }{
                \PRecv\x{
                    \ladd : \Call \Seller {x,y},
                    \lpay : \Wait\x{\POutput\y\lship.\Close\y}
                }  
            }
            \using\refrule{tb-label}
        \end{prooftree}
    \]
    for the definition of $\Seller$. Note that the left branch starts with an application of \refrule{tb-call}.
    %
    An analogous (but finite) derivation can be easily obtained for the body of process $\Carrier$ and is omitted here for space limitations.
    %
    Now we have
    \[
        \begin{prooftree}
            \[
                \[
                    \[
                        \smash\vdots\mathstrut
                        \justifies
                        \wtp[0]{
                            x : \S_b'
                        }{
                            \Call \Buyer x
                        }
                        \using\refrule{tb-call}
                    \]
                    \justifies
                    \wtp[1]{
                        x : \S_b
                    }{
                        \Cast\x \Call \Buyer x
                    }
                    \using\refrule{tb-cast}
                \]
                \vdots
                \justifies
                \wtp[2]{
                    y : \T_s
                }{
                    \NewPar\x{\Cast\x \Call \Buyer x}{\Call \Seller {x,y}}
                }
                \using\refrule{tb-par}
            \]
            \[
                \vdots
                \justifies
                \wtp[0]{
                    y : \T_c
                }{
                    \Call \Carrier y
                }
%                \using\refrule{tb-call}
            \]
            \justifies
            \wtp[3]\emptyset{
                \NewPar\y{\NewPar\x{\Cast\x \Call \Buyer x}{\Call \Seller {x,y}}}{\Call \Carrier y}
            }
%            \using\refrule{tb-par}
        \end{prooftree}
    \]
    showing that $\Main$ too is well typed. Note that $\S_b$ from \Cref{ex:bin_bsc} is a fair subtype of
    $\S_b'$ with weight $1$; indeed \refrule{tb-cast} increases the rank by such amount.
    %
    In all cases, we have truncated the proof trees above the applications of \refrule{tb-call}.
    %
    Of course, for each judgment occurring in these proof trees, 
    we also have to exhibit a finite proof tree possibly using \refrule{cob-label} proving action boundedness. 
    This can be easily achieved for the given process definitions, observing that none of $\Buyer$, $\Seller$ and $\Carrier$ 
    creates new sessions and that all of their typing derivations have a finite branch.
    %
    \eoe
\end{example}

\begin{example}[Infinite sessions/casts]
  In this example we demonstrate that well-typed processes may still create an unbounded number of (nested) sessions. 
  To this aim, let us consider again the process $C$ defined in \Cref{ex:infinite_sessions}. 
  Notice that $C$ is a choice whose left branch creates a new session and whose right branch does not. 
  For this reason, we elect the right choice as the one that leads to termination, 
  and therefore that determines the rank of the process.
  We derive
  \[
    \begin{prooftree}
      \[
        \[
          \mathstrut\smash\vdots
          \justifies
          \wtp[0]{
            y : \End[\Out]
          }{
            \Call{C}{y}
          }
         % \using\refrule{tb-call}
        \]
        \[
          \[
            \justifies
            \wtp[0]{
              x : \End[\Out]
            }{
              \Close\x
            }
           % \using\refrule{tb-close}
          \]
          \justifies
          \wtp[0]{
            x : \End[\Out], y : \End[\In]
          }{
            \Wait\y\dots
          }
         % \using\refrule{tb-wait}
        \]
        \justifies
        \wtp[1]{
          x : \End[\Out]
        }{
          \NewPar\y{\Call{C}{y}}{\Wait\y\dots}
        }
        % \using\refrule{tb-par}
      \]
      \[
        \justifies
        \wtp[0]{
          x : \End[\Out]
        }{
          \Close\x
        }
%        \using\refrule{tb-close}
      \]
      \justifies
      \wtp[0]{
        x : \End[\Out]
      }{
        \NewPar\y{\Call{C}{y}}{\Wait\y\dots}
        \pchoice_2
        \Close\x
      }
%      \using\refrule{tb-choice}
    \end{prooftree}
  \]

  In a similar way, there exist well-typed processes that perform an unbounded number 
  of casts but whose rank is finite. For example, it is easy to obtain a typing derivation 
  for the following alternative definition of the process $\Buyer$ discussed in \Cref{ex:bsc_bin_proc}:
  \[
    \Definition{\Buyer}{x}{\POutput\x\ladd.(\Cast\x\POutput\x\ladd.\Call{\Buyer}{x} \pchoice_2 \Cast\x\POutput\x\lpay.\Close\x)}
  \]
  
  Even though this process uses fair subtyping an unbounded number of times, the right branch of the choice has rank $1$, which is all we need to conclude that the process has rank $1$ overall.
  %
  \eoe
\end{example}

%\begin{example}[random bit generator]
%  \label{ex:bit}
%  Below we define a process $A(x)$ that implements a random bit generator along with a client
%  $B(x)$ that asks the service for random bits until it receives a $\lone$:
%  \[
%    \begin{array}{r@{~}l}
%      \Definition{A}{x}{&
%        \PRecv\x{
%          \lmore : \PSend\x{
%            \lzero : \Call{A}{x},
%            \lone  : \Call{A}{x}
%          },
%          \lstop : \Close\x
%        }
%      }
%      \\
%      \Definition{B}{x}{&
%        \POutput\x\lmore.
%        \PRecv\x{
%          \lzero : \Call{B}{x},
%          \lone  : \POutput\x\lstop.\Wait\x\Done
%        }
%      }
%    \end{array}
%  \]

%  These definitions are well typed under the global assignments $\tass{A}{S}0$
%  and $\tass{B}{U}{0}$ where $S$ is defined as in \cref{ex:subt_bit} and $U$ is
%  defined as in \cref{ex:comp_bit}. \LC{Inserire random bit in subtyping}
%  %
%  Notice that the termination of the parallel composition of $A$ and $B$ depends
%  on a complex negotiation between $A$ and $B$. Indeed, $A$ terminates when it
%  receives $\lzero$ from $B$ and $B$ terminates when it receives $\lstop$ from
%  $A$. This interaction pattern can only be modeled if both $A$ and $B$ are
%  defined using general recursion.
%  %
%  \eoe
%\end{example}