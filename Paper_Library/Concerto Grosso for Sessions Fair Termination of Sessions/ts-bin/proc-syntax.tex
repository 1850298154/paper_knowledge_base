\beginbass
%
A \emph{program} is a finite set of definitions of the form
$\pdef\pdn{\seqof\var}{P}$, at most one for each process name, where
$P$ is a \emph{process} generated by the grammar in \Cref{fig:proc_syntax_bin}.
%
\begin{figure}[t]
	\framebox[\textwidth]{
	\begin{math}
		\begin{array}[t]{@{}rcll@{}}
    	P, Q & ::= & \Done & \text{termination}
    	\\
    	& | & \Wait\x{P} & \text{signal in}
    	\\
    	& | & \PInput\x{(\y)}.{P} & \text{channel in}
    	\\
    	& | & \PBranch\x\Pol{\l_i}{P_i}{i \in I} & \text{label in/out}
    	\\
    	& | & \NewPar\x{P}{Q} & \text{session}
  	\end{array}
  	~
  	\begin{array}[t]{@{}rcll@{}}
    	& | & \Call{A}{\seqof\x} & \text{invocation}
    	\\
    	& | & \Close\x & \text{signal out}
    	\\
    	& | & \POutput\x{(\y)}.{P} & \text{channel out}
    	\\
    	& | & P \pchoice Q & \text{choice}
    	\\
    	& | & \Cast\x{P} & \text{cast}
  	\end{array}
	\end{math}
	}
	\caption{Syntax of processes}
	\label{fig:proc_syntax_bin}
\end{figure}
%
The process $\Done$ is terminated and performs no action.
%
The invocation $\Call A {\seqof\x}$ behaves as $P$ if $\Definition A {\seqof\x} P$ is the definition of $A$. 
When $\seqof\x$ is empty, we write $\Call A {}$ and $\Definition A {} P$ 
instead of $\Call A {}$ and $\Definition A {{}} P$.
%
The process $\Wait\x{P}$ waits for a signal from channel $x$ indicating that the
session $x$ is being closed and then continues as $P$. The process $\Close\x$
sends the termination signal on $x$.
%
The process $\PInput\x{(\y)}.{P}$ receives a channel $y$ from channel $x$ and then continues as $P$. 
Dually, $\POutput\x{(\y)}.{P}$ sends $y$ on $x$ and then continues as $P$.
%
The process $x\Pol\set{\l_i:P_i}_{i\in I}$ exchanges a tag $\l_i$ on channel $x$ and then continues as $P_i$. 
As for session types, we assume that the set $I$ in these forms is always non-empty and 
that $i\ne j$ implies $\l_i \ne \l_j$ for every $i,j\in I$. 
Also, we write $x \Pol \l_i.P_i$ instead of $x \Pol\set{\l_i : P_i}_{i\in I}$ when $I$ is a singleton $\set{i}$.
%
A non-deterministic choice $P_1 \pchoice P_2$ reduces to either $P_1$ or $P_2$.
The annotation $k\in\set{1,2}$ has no operational meaning, it is only used to
record that $P_k$ leads to the termination of the process and is omitted when
irrelevant.
%
A session $\NewPar\x P Q$ is the parallel composition of $P$ and $Q$ connected by $x$.
Note that composition and restriction is atomic. This approach is inspired by linear-logic
based calculi; we provide more details later on.
%
Finally, a \emph{cast} $\Cast \x P$ behaves exactly as $P$. This form simply
records the fact that the type of $x$ is subject to an application of fair
subtyping in the typing derivation for $P$. As we will see in
\Cref{sec:ts_bin_ts}, we use this form to precisely account for
all places in (the typing derivation of) a process where fair subtyping is used.
Occasionally we write $\Cast{x_1\cdots x_n}P$ for $\Cast{x_1}\cdots\Cast{x_n}P$.

The only binders are channel inputs $\PInput\x{(y)}.P$ and sessions
$\NewPar\x{P}{Q}$. We write $\fn{P}$ and $\bn{P}$ for the sets of free and bound
channel names occurring in $P$ and we identify processes modulo renaming of
bound names.
%
The program $\Program$ that provides the meaning to the process names occurring
in processes is often left implicit. Sometimes we write a process definition
$\Definition{A}{\seqof\x}{P}$ as a proposition or side condition, intending that
such definition is part of the implicit program $\Program$.
Note that this approach differs from the one used by \cite{ScalasYoshida19} as they 
introduce process definition in the syntax. We adopt a different approach in order
to keep the calculus as light as possible.
 
\begin{example}
  \label{ex:bsc_bin_proc}
  Let us revisit and complete the example we sketched in \Cref{ex:bsc}. 
  We let the \actor{buyer} $\tadd$ an \emph{odd} number of items.
  We can model the whole system as the following set of process definitions:
  \[
      \begin{array}{@{}r@{~}l@{}}
        \Definition\Main{}{&
          \NewPar\y{\NewPar\x{\Cast\x \Call \Buyer x}{\Call \Seller {x,y}}}{\Call \Carrier y}
        }
        \\
        \Definition{\Buyer}{x}{&
          \POutput\x\ladd.{
          	\PSend\x{
            	\ladd : \Call \Buyer x,
            	\lpay : \Close\x
          	}
        }}
				\\
				\Definition{\Seller}{x,y}{&
              \PRecv\x{
                  \ladd : \Call \Seller {x,y},
                  \lpay : \Wait\x{\POutput\y\lship.{\Close\y}
              }}
        }
				\\
        \Definition{\Carrier}{y}{&
            \PInput\y\lship.{\Wait\y\Done}
        }
      \end{array}
  \]

  Note that $\Buyer$ deterministically sends $\tadd$ to $\Seller$ as the
  first message, whereas he chooses among $\tadd$ and $\tpay$ every other
  interaction. After $\Buyer$ has sent $\tpay$, it closes the session $x$
  with $\Seller$. At this point, $\Seller$ sends $\tship$ to
  $\Carrier$ and closes the session $y$.
  %
  The cast $\Cast\x$ before the invocation of $\Call \Buyer x$ in $\Main$ is meant to
  account for the mismatch between the behavior of the buyer, which always
  adds an odd number of items to the cart, and that of the business, which
  accepts any number of items added to the shopping cart.
  %
  \eoe
\end{example}