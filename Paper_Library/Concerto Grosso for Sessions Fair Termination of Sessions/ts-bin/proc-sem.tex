\beginbass
%
\begin{figure}[t]
  \framebox[\textwidth]{
    \begin{math}
      \displaystyle
      \begin{array}{@{}lr@{~}c@{~}ll@{}}
        \defrule{sb-par-comm} & \NewPar\x{P}{Q} & \pcong & \NewPar\x{Q}{P}
        \\
        \defrule{sb-par-assoc} & \NewPar\x{P}{\NewPar\y{Q}{R}} & \pcong & \NewPar\y{\NewPar\x{P}{Q}}{R}
        & \text{if $x \in \fn{Q}$}
        \\
        & & & & \text{and $y \not\in \fn{P}$}
        \\
        & & & & \text{and $x \not\in \fn{R}$}
        \\
        \defrule{sb-cast-comm} & \Cast\x\Cast\y P & \pcong & \Cast\y\Cast\x P
        \\
        \defrule{sb-cast-new} & \NewPar\x{\Cast\x{P}}{Q} & \pcong & \NewPar\x{P}{Q} &
        \\
        \defrule{sb-cast-swap} & \NewPar\x{\Cast\y{P}}{Q} & \pcong & \Cast\y\NewPar\x{P}{Q}
        & \text{if $x \ne y$}
        \\
        \defrule{sb-call} & \Call{A}{\seqof\x} & \pcong & P
        & \text{if $\Definition{A}{\seqof\x}{P}$}
      \end{array}
    \end{math}
  }
  \caption{Structural pre-congruence of processes}
  \label{fig:pcong_bin} 
\end{figure}
%
\begin{figure}[t]
  \framebox[\textwidth]{
    \begin{mathpar}
      \displaystyle
      	\inferrule[rb-choice]{\mathstrut}{P_1 \pchoice P_2 \red P_k}
        ~ k\in\set{1,2}
        \defrule[rb-choice]{}
        \and
        \inferrule[rb-signal]{\mathstrut}{\NewPar\x{\Close\x}{\Wait\x{P}} \red P}
        \defrule[rb-signal]{}
        \and
        \inferrule[rb-channel]
        	{\mathstrut}
        	{\NewPar\x{\POutput\x\y.P}{\PInput\x{(y)}.Q} \red \NewPar\x{P}{Q}}
        	\defrule[rb-channel]{}
        \and
        \inferrule[rb-pick]
        	{\mathstrut}
        	{\NewPar\x{\PSend\x{\l_i : P_i}_{i\in I}}{Q} \red \NewPar\x{\POutput\x{\l_k}.P_k}{Q}} 
        	~ k\in I, |I| > 1
        	\defrule[rb-pick]{}
        \and
        \inferrule[rb-tag]
        	{\mathstrut}
        	{\NewPar\x{\POutput\x{\l_k}.P}{\PRecv\x{\l_i : Q_i}_{i\in I}} \red \NewPar\x{P}{Q_k}}
        	~ k\in I
        	\defrule[rb-tag]{}
        \and
        \inferrule[rb-par]
        	{P \red Q}
        	{\NewPar\x{P}{R} \red \NewPar\x{Q}{R}}
        	\defrule[rb-tag]{}
        \and
        \inferrule[rb-cast]
        	{P \red Q}
        	{\Cast\x P \red \Cast\x Q}
        	\defrule[rb-cast]{}
        \and
        \inferrule[rb-struct]
        	{P \pcong P' \\ P' \red Q' \\ Q' \pcong Q}
        	{P \red Q}
        	\defrule[rb-struct]{}
    \end{mathpar}
  }
  \caption{Reduction of processes}
  \label{fig:red_bin} 
\end{figure}
%
The operational semantics of processes is defined using a structural
pre-congruence relation $\pcong$ and a reduction relation $\red$, both of which
are defined in \Cref{fig:pcong_bin,fig:red_bin} and described hereafter.
%
Rules \refrule{sb-par-comm} and \refrule{sb-par-assoc} express the usual
commutativity and associativity of parallel composition. In the case of
\refrule{sb-par-assoc}, the side condition $x\in\fn{Q}$ makes sure that the
session $\NewPar\x P Q$ we obtain on the right hand side does indeed connect $P$
and $Q$ through $x$.
The other side conditions $y \not\in \fn{P}$ and $x \not\in \fn{R}$ will
always hold when dealing with well-typed processes.
%
Also note that \refrule{sb-par-assoc} only describes a right-to-left
associativity of parallel composition and that left-to-right associativity is
derivable by the chain of relations
 \[
   \begin{array}{r@{~}l}
     \NewPar\x{\NewPar\y{P}{Q}}{R}
     &
     \pcong
     \NewPar\x{R}{\NewPar\y{P}{Q}}
     \\
     & \pcong
     \NewPar\x{R}{\NewPar\y{Q}{P}}
     \\
     & \pcong
     \NewPar\y{\NewPar\x{R}{Q}}{P}
     \\
     & \pcong
     \NewPar\y{\NewPar\x{Q}{R}}{P}
     \pcong
     \NewPar\y{P}{\NewPar\x{Q}{R}}
   \end{array}
 \]
 when $x\in\fn{Q}$.
%
Axiom \refrule{sb-cast-new} annihilates a cast on $x$ nearby
the binder for $x$, making sure that casts can only be removed and never added.
Axioms \refrule{sb-cast-comm} and \refrule{sb-cast-swap} are used to move casts
closer to their binder so that they can be annihilated with
\refrule{sb-cast-new}. Rule \refrule{sb-call} unfolds process invocations to their
definition.

\begin{remark}[On structural pre-congruence]
	\label{rmk:pcong}
	The reader might be wonder why we adopted a pre-congruence relation instead of a more common
	congruence one. The reason behind this choice is that in general it reduces the number of
	cases to be analyzed in some proofs (see \Cref{lem:subj_cong_bin}) without compromising 
	the properties of the calculus. Moreover, the adoption of a congruence relation would
	lead to some unrealistic cases from the computation point of view. Indeed,
	\refrule{sb-cast-new} would introduce a reflexive application of fair subtyping from
	a session restriction and \refrule{sb-call} would fold a process call.
	%
	\eor
\end{remark}

The reduction rules are mostly unremarkable: \refrule{rb-choice} models the
non-deterministic choice between alternative behaviors; \refrule{rb-pick} models
a non-trivial choice among a set of labels to send; \refrule{rb-signal},
\refrule{rb-label} and \refrule{rb-channel} model synchronizations between a
sender (on the left hand side of the parallel composition) and a receiver (on
the right hand side of the parallel composition) with \refrule{rb-signal}
removing the binder of a closed session; \refrule{rb-par}, \refrule{rb-cast} and
\refrule{rb-struct} close reductions under parallel compositions, under casts and
by structural pre-congruence.
%
In the following we write $\wred$ for the reflexive, transitive closure of
$\red$ and $\wred^+$ for $\wred\red$.

\begin{example}
  \label{ex:bsc_bin_reduction}
  With the definitions given in \Cref{ex:bsc_bin_proc}, it is easy to see that
  there is an infinite reduction sequence starting from $\Main$ in which the
  acquirer keeps adding items to the cart:
  \[
    \begin{array}{@{}c@{~}l@{}}
    	&
      \NewPar\y{
        \NewPar\x{
          \Cast x
          \Call \Buyer x
        }{
          \Call \Seller {x,y}
        }
      }{
        \Call \Carrier y
      }
      \\
      \wred &
      \NewPar\y{
        \NewPar\x{
          \PSend\x{
            \ladd : \Call \Buyer x,
            \lpay : \Close x
          }
        }{
          \Call \Seller {x,y}
        }
      }{
        \Call \Carrier y
      }
      \\
      \red &
      \NewPar\y{
        \NewPar\x{
          \POutput\x\ladd.
          \Call \Buyer x
        }{
          \Call \Seller {x,y}
        }
      }{
        \Call \Carrier y
      }
      \\
      \wred &
      \NewPar\y{
        \NewPar\x{
          \Call \Buyer x
        }{
          \Call \Seller {x,y}
        }
      }{
        \Call \Carrier y
      } 
      \\
      \red & \cdots
    \end{array}
  \]
  
  Nonetheless, $\Main$ is fairly terminating. For example, we have:
  \[
    \begin{array}{c@{~}l}
    	&
      \NewPar\y{
      \NewPar\x{
         \PSend\x{
           \ladd : \Call \Buyer x,
           \lpay : \Close x
         }
       }{
         \Call \Seller {x,y}
       }
     }{
       \Call \Carrier y
     }
      \\
      \red &
      \NewPar\y{
        \NewPar\x{
          \POutput\x\lpay.
          \Close x
        }{
          \Call \Seller {x,y}
        }
      }{
        \Call \Carrier y
      }
      \\
      \wred &
      \NewPar\y{
        \NewPar\x{
          \Close x
        }{
          \Wait\x.
          \POutput\y\lship.
          \Close\y
        }
      }{
        \Call \Carrier y
      }
      \\
      \red &
      \NewPar\y{
        \POutput\y\lship.
        \Close\y
      }{
        \Call \Carrier y
      }
      \\
      \wred &
      \NewPar\y{
        \Close\y
      }{
        \Wait\y
        \Done
      }
      \\
      \red &
      \Done
    \end{array}
  \]

  Note that in general it might be necessary for the acquirer to add one more item to the cart before it can send the payment to the business and the carrier receives a $\lship$ message.
  %
  \eoe
\end{example}