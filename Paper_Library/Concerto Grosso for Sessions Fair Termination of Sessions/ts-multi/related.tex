\beginalto
%
We conclude the chapter by relating the type systems in 
\Cref{ch:ft_bin,ch:ft_multi} to others that can be found
in the literature. In particular, we mainly recall
the references we pointed out in \Cref{sec:related}.

\paragraph{Termination of Binary Sessions.}
%
\cite{LindleyMorris16} define a type system for a functional
language with session primitives and recursive session types that is strongly
normalizing. That is, a well-typed program along with all the sessions it
creates is guaranteed to terminate. This strong result is due to the fact that
the type language is equipped with least and greatest fixed point operators that
are required to match each other by duality.
%
Notably, strong normalization is stronger than fair termination. 
As an example, \Cref{ex:bsc_bin_proc,ex:bsc_multi} are fairly terminating but not
strongly terminating as the buyer can add arbitrarily many, possibly infinitely
many, items to the cart.

\paragraph{Liveness Properties in the $\pi$-Calculus.}
%
\cite{Kobayashi02,Padovani14} define a behavioral type system that guarantees
lock freedom in the $\pi$-calculus. .
%
These works annotate types with numbers representing finite upper bounds
to the number of interactions needed to unblock a particular input/output
action. For this reason, none of our key examples (\Cref{ex:bsc_multi,ex:2bsc_multi,ex:pms_multi})
is in the scope of these analysis techniques.
%
\cite{KobayashiSangiorgi10} show how to enforce lock
freedom by combining deadlock freedom and termination. Our work can be seen as a
generalization of this approach whereby we enforce lock freedom by combining
deadlock freedom (through a mostly conventional session type system) and
\emph{fair} termination. Since fair termination is coarser than termination, the
family of programs for which lock freedom can be proved is larger as well.

\paragraph{Deadlock Freedom.}
% 
Our type system enforces deadlock freedom essentially thanks to the shape of the
rule \refrule{tm-par} (\refrule{tb-par} in \Cref{ch:ft_bin}) which is inspired 
to the cut rule of linear logic. This
rule has been applied to session type systems for binary
sessions \citep{Wadler14,CairesPfenningToninho16,LindleyMorris16} and
subsequently extended to multiparty
sessions \citep{CarboneLMSW16,CarboneMontesiSchurmannYoshida17}. In the latter
case, the rule -- dubbed \emph{multiparty cut} -- requires a coherence condition
among cut types establishing that the session types followed by the single
participants adhere to a so-called global type describing the multiparty session
as a whole. The rule \refrule{tm-par} adopts the same schema, except that the
coherence condition is stronger to entail fair session termination. 
%
The key principle of these formulations of the cut rule as a typing rule for
parallel processes is to impose a tree-like network topology, whereby two
parallel processes can share at most one channel. In the multiparty case, cyclic
network topologies can be modeled within each session (\Cref{ex:pms_multi}) since
coherence implies deadlock freedom.

Having a single construct that merges session restriction and parallel
composition allows for a simple formulation of the typing rules so that dealock
freedom is easily guaranteed. However, many session calculi separate these two
forms in line with the original presentation of the $\pi$-calculus. We think
that our type system can be easily reformulated to support distinct session
restriction and parallel composition by means of
hypersequents \citep{KokkeMontesiPeressotti18,KokkeMontesiPeressotti19}.

A more liberal version of the cut rule, named multi-cut and inspired to
Gentzen's ``mix'' rule, is considered by \citep{AbramskyGN96}
enabling processes to share more than one channel. In this setting,
deadlock freedom is lost but can be recovered by means of a richer type structure
that keeps track of the dependencies between different channels. This approach
has been pioneered by \cite{Kobayashi02, Kobayashi06} for the
$\pi$-calculus and later on refined by \cite{Padovani14}.
%
Other approaches to ensure deadlock freedom based on
\emph{dependency/connectivity graphs} that capture the network topology
implemented by processes have been studied by 
\cite{CarboneDebois10,KobayashiLaneve17,deLiguoroP18,JacobsBalzerKrebbers22}.

\paragraph{Liveness Properties of Multiparty Sessions.}
%
In \cite{ScalasYoshida19} the authors point out that the coarsest liveness
property in the hierarchy of liveness properties that they take into account, which is the one more closely related to fair
termination, cannot be enforced by their type system. In part, this is due to
the fact that their type system relies on a standard subtyping relation for
session types \citep{GayHole05} instead of fair subtyping
\citep{Padovani13,Padovani16}. As we have seen in \Cref{ch:ft_bin}, even for
single-session programs the mere adoption of fair subtyping is not enough and it
is necessary to meet additional requirements.
%
\cite{GlabbeekHofnerHorne21} propose a type
system for multiparty sessions that ensures progress and is not only sound but
also complete. The fairness assumption they make -- called \emph{justness} -- is
substantially weaker than our own (\Cref{def:fair_run}) and such that the unfair
runs are those in which some interactions between participants are
systematically discriminated in favor of other interactions involving a disjoint
set of independent participants. For this reason, their progress property is in
between the two more restrictive liveness predicates of \cite{ScalasYoshida19} 
and can only be guaranteed when it is independent
of the behavior of the other participants of the same session.