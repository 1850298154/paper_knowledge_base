\beginbass
%
We dedicate the rest of \Cref{sec:ts_multi_ts} to the analysis of some examples
that integrate all the features of the presented type system. We start from some
basic examples and then we move to more involved ones. First, in \Cref{ex:bsc_ts_multi} we take into
account our slightly different variant of the running example (\Cref{ex:bsc_multi}). 
For what concerns the problematic processes in \Cref{ssec:boundedness}, they are still
valid in the multiparty context (see \Cref{rm:boundedness_multi}). 
We use the rest of the examples to deal with the processes introduced in \Cref{ssec:proc_ex_multi}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Action/Session/Cast-Boundedness %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{remark}[Boundedness]
\label{rm:boundedness_multi}
	All the problematic processes that we presented in \Cref{ssec:boundedness} are still valid
	in the multiparty scenario and can be dealt with using the techniques that we mentioned for
	the binary case. In particular
	\begin{description}
	\item[Action-boundedness.] Type system with corules.
	\end{description}
	\[
    A \peq A
    \qquad
    B \peq {B \pchoice B}
    \qquad
    C \peq {C \pchoice \pdone}
  \]
	\begin{description}
	\item[Session-boundedness.] Rule \refrule{tm-par} increases the rank by one.
	\end{description}
	\[
    A \peq
      \pres{s}{
        \act{\ep{s}{\rolep}}{\roleq}\oact\set{
          \Tag[a].\pclose{\ep{s}{\rolep}},
          \Tag[b].\pwait{\ep{s}{\rolep}}{A}
        }
        \parop
        \act{\ep{s}{\roleq}}{\rolep}\iact\set{
          \Tag[a].\pwait{\ep{s}{\roleq}}{A},
          \Tag[b].\pclose{\ep{s}{\roleq}}
        }
      }
  \]
	\begin{description}
	\item[Cast-boundedness.] Rule \refrule{tm-cast} increases the rank by the weight of the subtyping
		being applied.
	\end{description}
	\[
  	B(x) \peq \pcast{x}\act{x}\seller\oact\tadd.\pinvk{B}{x}
  \]
	%
	\eor
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%
%%% Running Example %%%
%%%%%%%%%%%%%%%%%%%%%%%

\begin{example}
  \label{ex:bsc_ts_multi} 
  Let us show some typing derivations for fragments of \Cref{ex:bsc_multi}. 
  Let $\S_b$, $S_s$ and $S_c$ be the types from \Cref{ex:bsc_ty_multi}.
  We collapse roles to their initials.
  Let $\S'_b = \rseller\Out\tadd\rseller\Out\tadd.\S'_b + \rseller\Out\tpay.\End[\Out]$.
  Concerning $\Buyer$, we obtain the infinite derivation
  \[
    \begin{prooftree}
      \[
        \[
          \mathstrut\smash\vdots
          \justifies
          \wtp[0]{
            x : \S'_b
          }{
            \pinvk\Buyer{x}
          }
          \using\refrule{tm-call}
        \]
        \justifies
        \wtp[0]{
          x : \rseller\Out\tadd.\S'_b
        }{
          \act{x}\rseller\oact\tadd.\pinvk\Buyer{x}
        }
        \using\refrule{tm-tag}
      \]
      \[
        \justifies
        \wtp[0]{
          x : \End[\Out]
        }{
          \pclose{x}
        }
        \using\refrule{tm-close}
      \]
      \justifies
      \wtp[0]{
        x : \S'_b
      }{
        \act{x}\rseller\oact\set{
          \tadd.\act{x}\rseller\oact\tadd.\pinvk\Buyer{x},
          \tpay.\pclose{x}
        }
      }
      \using\refrule{tm-tag}
    \end{prooftree}
  \]
  %
  and, for each judgment in it, it is easy to find a finite derivation possibly
  using \refrule{com-tag}. Concerning $\Main$ we obtain
  \[
    \begin{prooftree}
      \[
        \mathstrut\smash\vdots
        \justifies
        \wtp[0]{
          \ep{s}\rbuyer : \S'_b
        }{
          \pinvk\Buyer{\ep{s}\rbuyer}
        }
        \using\refrule{tm-call}
      \]
      \[
        \smash\vdots
        \justifies
        \wtp[0]{
          \ep{s}\rseller : S_s
        }{
          \pinvk\Seller{\ep{s}\rseller}
        }
      \]
      \vdots
      \justifies
      \wtp[1]{
        \EmptyCtx
      }{
        \pres\sn{
          \pinvk\Buyer{\ep{s}\rbuyer} \ppar \pinvk\Seller{\ep{s}\rseller} \ppar \pinvk\Carrier{\ep{s}\rcarrier}
        }
      }
      \using\refrule{tm-par}
    \end{prooftree}
  \]
  %
  where the application of \refrule{tm-par} is justified by the fact that
  $\Map\rbuyer{\S'_b} \parop \Map\rseller{S_s} \parop \Map\rcarrier{S_c}$ is coherent.
  We recall that $\S_b \subt[1] \S'_b$ (\Cref{ex:bsc_fair_sub}).
  %
  No participant creates new sessions or performs casts, so they all have zero
  rank. The rank of $\Main$ is 1 since it creates the session $s$.
  %
  \eoe
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 2Buyers-Seller-Shipper %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{example}
\label{ex:2bsc-ts}
In this example we show that the process $\Buyer_1$ playing the role $\rbuyer_1$
in the inner session of \Cref{ex:2bsc_multi} is well typed. For clarity, we recall its
definition here: 
\[
Buyer_1(x,y) \peq \act{y}{\rbuyer_2}\oact\{
	\begin{lines}
	  \tsplit.\act{y}{\rbuyer_2}\iact\{
		\begin{lines}
			\tyes.\pcast{x}
				\act{x}\rseller\oact\tok.
				\act{x}\rcarrier\iact\tbox.
				\pwait{x}
				\pwait{y}
				\pdone,
				\\
			\tno.\pinvk{Buyer_1}{x,y} \},
		\end{lines}
	  \\
	  \tgiveup.
		\pwait{y}
		\pcast{x}
		\act{x}\rseller\oact\tcancel.
		\pwait{x}
		\pdone \}
	\end{lines}
\]

We wish to build a typing derivation showing that $Buyer_1$ has rank $1$ and
uses $x$ and $y$ respectively according to $S$ and $T$, where $S =
\rseller\Out\tok.\rcarrier\In\tbox.\End[\In] + \rseller\Out\tcancel.\End[\In]$
and $T = \rbuyer_2\Out\tsplit.(\rbuyer_2\In\tyes.\End[\In] + \rbuyer_2\In\tno.T)
+ \rbuyer_2\Out\tgiveup.\End[\In]$.
%
As it has been noted previously, what makes this process interesting is that it
uses the endpoint $x$ differently depending on the messages it exchanges with
$\rbuyer_2$ on $y$. Since rule \refrule{tm-tag} requires any endpoint other
than the one on which messages are exchanged to have the same type, the only way
$\Buyer_2$ can be declared well typed is by means of the casts that occur in its
body.
%
For the branch in which $\Buyer_1$ proposes to $\tsplit$ the payment we obtain
the following derivation tree (we show only the $\tyes$ branch, the $\tno$ one is trivial):
\[
	\begin{prooftree}
		\[
			\[
				\[
					\[
						\[
							\[
								\justifies
								\wtp[0]\EmptyCtx\pdone
								\using\refrule{tm-done}
							\]
							\justifies
							\wtp[0]{
								y : \End[\In]
							}{
								\pwait{y}\pdone
							}
							\using\refrule{tm-wait}
						\]
						\justifies
						\wtp[0]{
							x : \End[\In],
							y : \End[\In]
						}{
							\pwait[\dots]{x}
						}
						\using\refrule{tm-wait}
					\]
					\justifies
					\wtp[0]{
						x : \rcarrier\In\tbox.\End[\In],
						y : \End[\In]
					}{
						\act{x}\rcarrier\iact\tbox\dots
					}
					\using\refrule{tm-tag}
				\]
				\justifies
				\wtp[0]{
					x : \rseller\Out\tok.\rcarrier\In\tbox.\End[\In],
					y : \End[\In]
				}{
					\act{x}\rseller\oact\tok\dots
				}
				\using\refrule{tm-tag}
			\]
			\justifies
			\wtp[1]{
				x : S,
				y : \End[\In]
			}{
				\pcast{x}\dots
			}
			\using\refrule{tm-cast}
		\]
		\vdots
		\justifies
		\wtp[1]{
			x : S,
			y : \rbuyer_2\In\tyes.\End[\In] + \rbuyer_2\In\tno.T
		}{
			\act{y}{\rbuyer_2}\iact\set{\tyes\dots, \tno\dots}
		}
		\using\refrule{tm-tag}
	\end{prooftree}
\]

Note how the application of \refrule{tm-cast} is key to change the type of $x$ in
the branch where the proposed split is accepted by $\rbuyer_2$. In that branch,
$x$ is deterministically used to send an $\tok$ message and we leverage on the
fair subtyping relation $S \subt[1] \rseller\Out\tok.\rcarrier\In\tbox.\End[\In]$.
%

For the branch in which $\Buyer_1$ sends $\tgiveup$ we obtain the following
derivation tree:
\[
	\begin{prooftree}
		\[
			\[
				\[
					\[
						\justifies
						\wtp[0]\EmptyCtx{
							\pdone
						}
						\using\refrule{tm-done}
					\]
					\justifies
					\wtp[0]{
						x : \End[\In]
					}{
						\pwait{x}\pdone
					}
					\using\refrule{tm-wait}
				\]
				\justifies
				\wtp[0]{
					x : \rseller\Out\tcancel.\End[\In]
				}{
					\act{x}\rseller\oact\tcancel.
					\pwait{x}
					\pdone
				}
			\]
			\justifies
			\wtp[1]{
				x : S
			}{
				\pcast{x}
				\act{x}\rseller\oact\tcancel.
				\pwait{x}
				\pdone
			}
			\using\refrule{tm-cast}
		\]
		\justifies
		\wtp[1]{
			x : S,
			y : \End[\In]
		}{
			\pwait{y}
			\pcast{x}
			\act{x}\rseller\oact\tcancel.
			\pwait{x}
			\pdone
		}
		\using\refrule{tm-wait}
	\end{prooftree}
\]

Once again the cast is necessary to change the type of $x$, but this time
leveraging on the fair subtyping relation $S \subt[1]
\rseller\Out\tcancel.\End[\In]$.
%
These two derivations can then be combined to complete the proof that the body
of $\Buyer_1$ is well typed:
\[
	\begin{prooftree}
		\qquad
		\mathstrut\smash\vdots
		\qquad
		\qquad
		\qquad
		\smash\vdots
		\qquad
		\justifies
		\wtp[1]{
			x : S,
			y : T
		}{
			\act{y}{\rbuyer_2}\oact\set{\tsplit\dots, \tgiveup\dots}
		}
		\using\refrule{tm-tag}
	\end{prooftree}
\]

Clearly, it is also necessary to find finite derivation trees for all of the
judgments shown above. This can be easily achieved using the corule
\refrule{com-tag}.
%
\eoe
\end{example}

\begin{example}
	\label{ex:non-det}
	Casts can be useful to reconcile the types of a channel that is used
	differently in different branches of a non-deterministic choice. For
	example, below is an alternative modeling of $\Buyer$ from \Cref{ex:bsc_multi}
	where we abbreviate $\role[\seller]$ to $\rseller$ for convenience:
	\[
		\Definition{B}{x}{
			\pcast{x}
			\act{x}\rseller\oact\tadd.
			\act{x}\rseller\oact\tadd.\pinvk{B}{x}
			\pchoice
			\pcast{x}
			\act{x}\rseller\oact\tpay.
			\pclose{x}
		}
	\]

	Note that $x$ is used for sending two $\tadd$ messages in the left branch of
	the non-deterministic choice and for sending a single $\tpay$ message in the
	right branch. Given the session type $S = \rseller\Out\tadd.S +
	\rseller\Out\tpay.\End[\Out]$ and using the fair subtyping relations $S
	\subt[2] \rseller\Out\tadd.\rseller\Out\tadd.S$ and $S \subt[1]
	\rseller\Out\tpay.\End[\Out]$ we can obtain the following typing derivation
	for the body of $B$ (we show only the left branch as the right one contains a
	straightforward application of $S \subt[1] \rseller\Out\tpay.\End[\Out]$):
	\[
		\begin{prooftree}
			\[
				\[
					\[
						\[
							\mathstrut\smash\vdots
							\justifies
							\wtp[1]{
								x : S
							}{
								\pinvk{B}{x}
							}
							\using\refrule{tm-call}
						\]
						\justifies
						\wtp[1]{
							x : \rseller\Out\tadd.S
						}{
							\act{x}\rseller\oact\tadd.\pinvk{B}{x}
						}
						\using\refrule{tm-tag}
					\]
					\justifies
					\wtp[1]{
						x : \rseller\Out\tadd.\rseller\Out\tadd.S
					}{
						\act{x}\rseller\oact\tadd.
						\act{x}\rseller\oact\tadd.\pinvk{B}{x}
					}
					\using\refrule{tm-tag}
				\]
				\justifies
				\wtp[3]{
					x : S
				}{
					\pcast{x}
					\act{x}\rseller\oact\tadd.
					\act{x}\rseller\oact\tadd.\pinvk{B}{x}	
				}
				\using\refrule{tm-cast}
			\]
			\vdots
			\justifies
			\wtp[1]{
				x : S
			}{
				\pcast{x}
				\act{x}\rseller\oact\tadd.
				\act{x}\rseller\oact\tadd.\pinvk{B}{x}
				\pchoice
				\pcast{x}
				\act{x}\rseller\oact\tpay.
				\pclose{x}	
			}
			\using\refrule{tm-choice}
		\end{prooftree}
	\]
	%
	In general, the transformation $\pbranch[i=1..n]{u}{\role}\oact{\Tag_i}{P_i}
	\leadsto \pcast{u}\act{u}{\role}\oact{\Tag_1}.P_1 \pchoice \cdots \pchoice
	\pcast{u}\act{u}\role\oact{\Tag_n}.P_n$ does not always preserve typing, so
	it is not always possible to encode the output of tags using casts and
	non-deterministic choices. As an example, the definition
	%
	\[
		\Definition\SlotMachine{x}{
			\act{x}\rplayer\iact\set{
				\tplay.\act{x}\rplayer\oact\set{
					\twin.\pinvk\SlotMachine{x},
					\tlose.\pinvk\SlotMachine{x}
				},
				\tquit.\pclose{x}
			}
		}
	\]
	implements the unbiased slot machine of \Cref{ex:slot_fair_sub} that waits
	for a message indicating whether a $\rplayer$ wants to $\tplay$ another game or
	to $\tquit$ (we assign role $\rplayer$ to the player). 
	In the former case, the slot machine notifies $\rplayer$ of the
	outcome (either $\twin$ or $\tlose$).
	%
	It is easy to see that $\SlotMachine$ is well typed under the global type
	assignment $\tass\SlotMachine{T}{0}$ where $T =
	\rplayer\In\tplay.(\rplayer\Out\twin.T + \rplayer\Out\tlose.T) +
	\rplayer\In\tquit.\End[\Out]$. In particular, $\SlotMachine$ has rank $0$
	since it performs no casts and it creates no sessions. If we encode the tag
	output in $\SlotMachine$ using casts and non-deterministic choices we end up
	with the following process definition, which is ill typed because it cannot
	be given a finite rank:
	%
	\[
		\Definition{\SlotMachine}{x}{
			\act{x}\rplayer\iact\set{
				\tplay.(
					\pcast{x}
					\act{x}\rplayer\oact\twin.
					\pinvk{\SlotMachine}{x}
					\pchoice
					\pcast{x}
					\act{x}\rplayer\oact\tlose.
					\pinvk{\SlotMachine}{x}
				),
				\tquit.\pclose{x}
			}
		}
	\]

	The difference between this version of $\SlotMachine$ and the above
	definition of $B$ is that $\SlotMachine$ always recurs after a cast, so it
	is not obvious that finitely many casts suffice in order for $\SlotMachine$
	to terminate. 
	%
	\eoe
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Buyer-Seller-Shipper Refined %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{example} 
	\Cref{ex:2bsc-ts}
	shows that casts are essential in the type derivation.
	However, the process would be well typed if we considered a subtyping relation that does not preserve coherence
	\citep{GayHole05} for the involved types are finite.
	Now we refine the buyer from \Cref{ex:bsc_multi} in order to consider more involved sessions. Again, we
	collapse role names to their initials.
	\begin{align*}
		B(x) & \peq
			{\pcast{x}\pinvk{B_1}{x} \pchoice \pcast{x}\pinvk{B_2}{x}} 
		\\
		B_1(x) & \peq
			{\act{x}{\rseller}\oact\Tag[add].\act{x}{\rseller}\oact\set{
  			\Tag[add].\pinvk{B_1}{x},\, 
  			\Tag[pay].\pwait{x}{\pdone} 
			}} 
	  \\  
		B_2(x) & \peq
			{\act{x}{\rseller}\oact\set{
				\Tag[add].\act{x}{\rseller}\oact\Tag[add]. \pinvk{B_2}{x},\, 
  				\Tag[pay].\pwait{x}{\pdone} 
			}}
	\end{align*}
	$B_2$ corresponds to the buyer in \Cref{ex:bsc_multi} while $B_1$ is the acquirer that adds an odd number of items to the cart. 
	$B$ non deterministically chooses to behave according to $B_1$ or $B_2$.
	%
	Let $S_{b_1}$ and $S_{b_2}$ be the session types such that 
	$x : S_{b_1}$ in $B_1$ and $x : S_{b_2}$ in $B_2$ respectively:
	\[
	\begin{array}{ll}
		S_{b_1} = \rseller\Out\Tag[add].(\rseller\Out\Tag[add].S_{b_1} + \rseller\Out\Tag[pay].\End[\Out])
		&
		S_{b_2} = \rseller\Out\Tag[add].\rseller\Out\Tag[add].S_{b_2} + \rseller\Out\Tag[pay].\End[\Out]
	\end{array}
	\]
	In \cref{ex:bsc_fair_sub} we showed that $S \subt[1] S_{b_2}$ where $S =\rseller\Out\tadd.S + \rseller\Out\tpay.\End[\Out]$
	models the acquirer that adds arbitrarily many items to the cart. Analogously, we can prove that $S \subt[2] S_{b_1}$.
	Hence we derive
	\[
	\begin{prooftree}
		\[
			\[
				\vdots
				\justifies
				\wtp[0]{x : S_{b_1}}{\pinvk{B_1}{x}}
				\using\refrule{tm-call}
			\]
			\justifies
			\wtp[2]{x : S}{\pcast{x}\pinvk{B_1}{x}}
			\using\refrule{tm-cast}
		\]
		\[
			\[
				\vdots
				\justifies
				\wtp[0]{x : S_{b_2}}{\pinvk{B_2}{x}}
				\using\refrule{tm-call}
			\]
			\justifies
			\wtp[1]{x : S}{\pcast{x}\pinvk{B_2}{x}}
			\using\refrule{tm-cast}
		\]
		\justifies
		\wtp[1]
			{x : S}
			{\pcast{x}\pinvk{B_1}{x} \pchoice \pcast{x}\pinvk{B_2}{x}}
		\using\refrule{tm-choice}
	\end{prooftree}
	\]
	Again, the casts are crucial to obtain the type derivation of process $B$ because rule 
	\refrule{tm-choice} requires that $B_1$ and $B_2$ are typed in the same context.
	Note that $B_1$ and $B_2$ are typed with rank 0 since no sessions are created and no casts are performed by the processes.
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unbounded No. Of Sessions %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{example}
	\label{ex:pms_ts}
	Here we provide evidence that the process definitions in \Cref{ex:pms_multi} are
	well typed, even if they model processes that can open arbitrarily many
	sessions. In that example, the most interesting process definition is that
	of the worker $\Sort$, which is recursive and may create a new session. In
	contrast, $\Merge$ is finite and $\Main$ only refers to $\Sort$. We claim
	that these process definitions are well typed under the global type
	assignments
	\[
		\tass\Main{}{1}
		\qquad
		\tass\Sort{U}{0}
		\qquad
		\tass\Merge{T, V}{0}
	\]
	where 
	\[
	\begin{array}{lll}
		T = \rmaster\Out\tres.\End[\Out]
		&
		U = \rmaster\In\treq.T
		&
		V = \rworker_1\Out\treq.\rworker_2\Out\treq.\rworker_1\In\tres.\rworker_2\In\tres.\End[\In]
	\end{array}
	\]
	For the branch of $\Sort$ that creates a new session we obtain the
	derivation tree
	\[
		\begin{prooftree}
			\[
				\mathstrut\smash\vdots
				\justifies
				\wtp[0]{
					x : T,
					\ep{t}\rmaster : V
				}{
					\pinvk\Merge{x,\ep{t}\rmaster}
				}
				\using\refrule{tm-call}
			\]
			\[
				\smash\vdots
				\justifies
				\wtp[0]{
					\ep{t}{\rworker_i} : U
				}{
					\pinvk\Sort{\ep{t}{\rworker_i}}
				}
			\]
			\justifies
			\wtp[1]{
				x : T
			}{
				\pres{t}{
					\pinvk\Merge{x,\ep{t}\rmaster} \parop
					\pinvk\Sort{\ep{t}{\rworker_1}} \parop
					\pinvk\Sort{\ep{t}{\rworker_2}}
				}
			}
			\using\refrule{tm-par}
		\end{prooftree}
	\]
	%
	where $i=1,2$. The rank $1$ derives from the fact that the created session involves
	three zero-ranked participants.
	%
	For the body of $\Sort$ we obtain the following derivation tree:
	\[
		\begin{prooftree}
			\[
				\[
					\smash\vdots
					\justifies
					\wtp[1]{
						x : T
					}{
						\pres{t}{
							\pinvk\Merge{x,\ep{t}\rmaster} \parop
							\cdots
						}
					}
					\using\refrule{tm-par}
				\]
				\[
					\[
						\justifies
						\wtp[0]{
							x : \End[\Out]
						}{
							\pclose{x}
						}
						\using\refrule{tm-close}
					\]
					\justifies
					\wtp[0]{
						x : T
					}{
						\act{x}\rmaster\oact\tres\dots
					}
					\using\refrule{tm-tag}
				\]
				\justifies
				\wtp[0]{
					x : T
				}{
					\pres{t}{
						\pinvk\Merge{x,\ep{t}\rmaster} \parop
						\cdots
					}
					\pchoice
					\act{x}\rmaster\oact\tres\dots
				}
				\using\refrule{tm-choice}
			\]
			\justifies
			\wtp[0]{
				x : U
			}{
				\act{x}\rmaster\iact\treq.(
					\pres{t}{
						\pinvk\Merge{x,\ep{t}\rmaster} \parop
						\cdots
					}
					\pchoice
					\act{x}\rmaster\oact\tres\dots
				)
			}
			\using\refrule{tm-tag}
		\end{prooftree}
	\]
	
	In the application of the rule \refrule{tm-choice}, the rank of the whole
	choice coincides with that of the branch in which no new sessions are
	created. This way we account for the fact that, even though $\Sort$
	\emph{may} create a new session, it does not \emph{have to} do so in order
	to terminate.
	%
	\eoe
\end{example}