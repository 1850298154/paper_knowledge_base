\begintreble
%
Nowadays concurrent and distributed systems are ubiquitous in the computer science world.
It is not surprising that there exists a wide research about how to enforce some desired 
properties of communications in such systems.

\section*{A Gentle Introduction}

\paragraph{Sessions}
The $\pi$-calculus is a process calculus used for modeling concurrent systems and it is based
on \emph{channels} that are owned by the entities involved in the communication and that are
used to exchange messages.
Session types \citep{Honda93} are a formalism to describe communication protocols. 
A session is represented by a channel that connects processes and session types are assigned to them.
They describe how the channels will be used by the processes that own them.
Session types have been originally introduced to model the interaction between \emph{two} entities
and they have been later generalized to multiparty \citep{HondaYoshidaCarbone08}.
%
There exists a broad family of desired properties that one would like to enforce in a communication.
Among them, the most common ones are that messages are exchanged in the right order (\emph{protocol fidelity}) 
or that there are no communication errors (\emph{communication safety}).

\paragraph{Safety vs Liveness - Fair Termination}
In general, properties can be divided in \emph{safety} (nothing bad ever happens) and 
\emph{liveness} (something good will eventually happen) ones \citep{OwickiLamport82}.
According to the class to which it belongs, a property is defined using different and dual
techniques: \emph{induction} for safety and \emph{coinduction} for liveness.
Actually, there exist some properties that fall in between as they combine safety and
liveness aspects. We can informally describe them using the motto ``something good always eventually
happens'' and their dual. Hence, such properties are hard to deal with as they mix induction
and coinduction.
In a communication-based scenario, protocol fidelity is a safety property and the eventual termination
of a session is a liveness one.
In this thesis we study \emph{fair termination} which is the property of those sessions that can always
eventually (successfully) terminate under a fairness assumption. As the reader might guess, fair termination
joins a safety and a liveness part. We investigate such property as it entails many well knows properties
that are studied in the literature.

\paragraph{Fair Subtyping}
Subtyping between session types is a fundamental relation in this thesis. It induces
a substitution principle \citep{LiskovWing94} which states that a process that uses an
endpoint according to some type can be substituted with another process that uses the
endpoint according to a supertype. Although the principle seems in the wrong direction
it is proved to be equivalent to the right-to-left variant by taking into account endpoints
instead of processes \citep{Gay16}. 
The original subtyping relation \citep{GayHole05} is studied to preserve the safety properties of
a session but not the livess ones. Indeed an application of the original subtyping can 
break the termination property of the involved session.
In this thesis we rely on \emph{fair subtyping} \citep{Padovani14,Padovani16} which is
a liveness-preserving variant of the subtyping in \cite{GayHole05}.

\paragraph{(Generalized) Inference Systems}
Inference systems are a widely used framework in computer science for defining predicates by means of (meta) rules.
They support both inductive and coinductive definitions and they have been recently generalized
to deal with those predcates that mix the two approaches \citep{AnconaDagninoZucca17}.
Roughly, an inference system, that is, a set of (meta)rules, is interpreted either
inductively or coinductively. In a generalized inference system the key ingredient
is the addition of (meta)corules and the interpretation is obtained by properly mixing the inductive and
the coinductive one. 
Then, inference systems also provide \emph{proof principles} for proving the correctness of
a definition with respect to a semantic one called \emph{specification} in a canonical way.
Correctness is usually expressed in terms of \emph{soundness} and \emph{completeness}.
The reference principles are \emph{induction}, \emph{coinduction} which involve
inductive and coinductive predicates, respectively.
\emph{Bounded coinduction} is a generalization of coinduction and is used when dealing
with definitions through generalized inference systems.
We will rely on (generalized) inference systems for defining most
of the notions we will introduce.

\paragraph{Proof Assistants}
These days there is an increasing interest in \emph{theorem provers}, that is, tools
that allow users to write proofs by relying on a language that resembles a programming language.
The advantage of using proof assistants is that the proofs are certified (provided that the tool is
itself consistent). 
Due to the novelty of the research field, there is a focus in the literature in providing big libraries
with the aim of making the community agree on some design techniques. For example,
when formalizing calculi, De Bruijn indices are usually preferred for dealing with variables.
Many research communities are starting to rely on theorem provers to mechanize existing theories.
The community working on behavioral types is affected by this phenomenon as well.
Moreover, apart from traditional conferences on formal proofs (\eg CPP, ITP), a very first
workshop on \emph{Verification of Session Types} has been organized in 2020 and 2021. 
The main output of such event was the lack of a reference methodology for mechanizing
session-based theories. In this thesis we will refer to the Agda proof assistant \citep{Agda}.
Notably, we refer to theorem provers and proof assistant interchangeably.

\paragraph{Agda}
Agda \citep{Agda} is an interactive proof assistant based on intuitionistic logic. The interactivity aspect
is fundamental as the user is guided step-by-step while mechanizing a proof.
The tool can be download for different platforms and comes with only the very basic
definitions, \eg natural numbers. The \emph{standard library} can be added separately
and it is constantly updated in order to keep the modules consistent with the latest
version of Agda. 
Moreover, Agda has built-in support for both inductive and coinductive predicates.
In \cite{Ciccone20} we made an in-depth analysis of all the techniques that users can
follow when mechanizing predicates and we found out that pure (co)inductive
inference system have a natural and intuitive encoding in Agda.
However, for what concerns those predicates defined by generalized inference systems,
there is no support. Indeed, although a generalized inference system can still be 
defined, the resulting code becomes hard to understand and it contains many duplicated
notions.

\section*{Contributions}

\begin{center}
\Large{Can well-typed programs go well?}
\end{center}

\textbf{Developing type systems for enforcing \emph{liveness} properties of processes is not 
an easy task}. For example, in the context of this thesis the type systems 
of \cite{Kobayashi02,Padovani14} adopt a sophisticated technique for guaranteeing 
that all pending actions will be eventually executed. The question we want to answer
is in sharp contrast with the famous Robin Milner's sentence ``Well typed programs cannot
go wrong'' \citep{Milner78} which points out the fact that type systems are usually made for enforcing 
\emph{safety} aspects.

\paragraph{Fair Termination}
We present type systems for \textbf{enforcing fair termination} in three different scenarios.
First, we deal with \emph{binary} sessions, that is, sessions involving only two
participants. This base case is fundamental to highlight all the technical aspects
and additional properties that the type system must ensure in order to guarantee
fair termination.
Then, we generalize such type system to the \emph{multiparty} case. Although
many notions can be easily adapted from the binary case, there are some technical
details that are hard to deal with. For what concerns the additional properties that
the type system has to enforce, we can still rely on the binary type system since binary
sessions are the simplest multiparty ones. 
At last, we show a type for enforcing fair termination in the linear $\pi$-calculus.
This last part falls in between the previous type systems and those type systems
interpreting session-based calculi in the context of linear logic.
The interesting difference between the type systems for sessions and the one for the $\pi$-calculus
is that in the second there is no notion of fair subtyping.

\begin{center}
\Large{
	Can Agda support definitions mixing induction and coinduction?\\
	Can Agda proofs match the pen-and-paper ones?}
\end{center}

As we mentioned before, Agda supports purely (co)inductive definitions. Moreover,
a predicate defined using an inference system can be naturally encoded.
On the other hand, when we deal with a predicate that involves both induction and coinduction, 
there is no built-in support \citep{Ciccone20}. 
As a result, we can still mechanize such predicates but
the resulting code contains many duplicated notions and it differs from the definition
given through a generalized inference system.
Another drawback of mechanizing notions in Agda is that the proofs become very hard to
be understood as they differ from the hand written ones since they require many additional
lemmas related to the technicalities of the proof assistant, \eg equalities.
Hence, we first ask whether it is possible to \textbf{encode generalized inference systems in Agda
in a natural way}. Then we ask if we can ``hide'' all the Agda related technicalities
so that the \textbf{proofs are shown to the user in a more friendly flavor}.

\paragraph{An Agda Library for Inference Systems}
(Generalized) inference systems are used throughout the entire thesis. 
Since we aimed at mechanizing some results in Agda, we thought about a way for
supporting the framework in the proof assistant. For this sake we present a
\textbf{library} that allows users to formalize inference systems using a syntax that
resembles the one used on paper. Moreover, the library supports the usage of
corules that are not built-in supported (see \cite{Ciccone20} for more details).
Clearly, all the proof principles are encoded as well.
As an important and useful side effect, the codes of the proofs based on the library
resemble the proofs written on paper. We think that this contribution 
can be very helpful for the community since closed proofs are usually very hard
to read and understand.

\paragraph{Mechanizing Properties of Session Types}
We take advantage of the library we developed to \textbf{mechanize some notions in the
session types context}.
We first mechanize an alternative definition of session types that aims at
simplifying the codes as much as possible. Such characterization has also the 
advantage of supporting \emph{dependency} with respect to previously exchanged messages.
Then we focus on three interesting properties of session types and we characterize them
using generalized inference systems: fair termination of a session type, fair compliance
(successful fair termination) of a binary session and fair subtyping.
We mechanize the three inference system as well as their correctness proofs with
respect to the semantic definitions.
As mentioned before, the community working on session types is increasingly interested
in proof assistants but so far there is a lack of a reference methodology.
We hope that our results and our experience will be used for finding 
a guideline on which all the community agrees.


\section*{Structure of the Thesis}

\paragraph{Concerto Grosso}
As the title might suggest, the thesis is structured in three parts as the original italian
\emph{Concerto Grosso} form of baroque music.
Moreover, since binary sessions are the simplest multiparty ones, we will jump between the two
scenarios according to our needs. In general, we will show paradigmatic examples in the binary setting
and we will prove the main notions in the more general multiparty one. 
The continuous alternation of communications between two and more participants 
resembles again the \emph{Concerto Grosso} which is based on a dialogue between a small ensemble
and the full orchestra.
The tempo indications at the beginning of each part are consistent with the fast-slow-fast schema
of the concerto grosso and we use them to jokingly indicate that the part that should be read more
carefully is the central one. At last, in order to help the reader we use treble, soprano and bass clefs to
denote texts inside chapters, sections and subsections, respectively.

\paragraph{Part I: Key Notions}
There are different notions that we will use throughout \Cref{pt:type_systems,pt:agda}.
Thus, we decided to dedicate the first part to introduce all the main ingredients of
the thesis. 
%
At the beginning we discuss the usual classification of properties in safety and liveness ones in \Cref{sec:sft_lvn}.
Then, in \Cref{sec:gis} we introduce (Generalized) inference systems as a reference framework
and in \Cref{sec:st} we introduce syntax and semantics of binary and multiparty session types.
%
We dedicate \Cref{ch:ft} to explain what is \emph{fair termination} and to express it in a general
setting, that is, considering an arbitrary transition system. Then, we instantiate the property
in the session types context.
%
At last, in \Cref{ch:fs} we focus on the subtyping relation between session types.
We first introduce the original subtyping relation \citep{GayHole05} and we show why 
it can break the liveness properties on the session on which it is applied.
We then introduce \emph{fair subtyping} as a liveness-preserving refinement of the original relation.
We present fair subtyping in two different flavours; first using a purely coinductive
inference system and then using a generalized inference system.

\paragraph{Part II: Type Systems}
This part is dedicated to the study of the three type systems for fair termination
and it is split according to the calculus under analysis.
%
In \Cref{ch:ft_bin} we present a type system for a calculus with binary sessions.
\Cref{ch:ft_multi} generalizes such type system to the multiparty case.
At last, in \Cref{ch:ft_ll} we show a type system for a $\pi$-calculus that is
based on linear logic.
%
The three chapters are stuctured similarly.
We first introduce the calculus (and the types) and then we show the typing rules.
We dedicate the rest of each chapter to detail the soundness proofs.
As we mentioned before, in \Cref{ch:ft_bin} we focus on those paradigmatic 
examples that point out the additional properties that the type system must enforce.
Since such examples hold in the multiparty setting as well, in \Cref{ch:ft_multi}
we present some more involved processes. 


\paragraph{Part III: Agda Mechanizations} 
This third and last part focuses on the mechanization aspects.
%
In \Cref{ch:gis_lib} we present the library for supporting in Agda generalized
inference systems. We first mechanize the meta theory of inference systems as well
as the proof principles and then we show some basic examples of usage.
Then in \Cref{ch:agda_prop} we present the definitions through generalized inference
systems of three properties of session types: fair termination of a session type,
fair compliance of a binary session and fair subtyping.
Notably, we mechanize the general notion of \emph{fair termination} and we 
relate it to the semantic definitions of the first two properties.
For each property we show the mechanization of the inference system and
we show how proof principles are used in the correctness proofs.
At last, we detail the proofs of fair compliance.

\section*{Published Works}

We conclude the introduction by relating the content of the thesis with
the published works of the author. 

\paragraph{Fair Termination}
\Cref{ch:ft_bin} is a refined version of \cite{CicconePadovani22}.
Differently from \cite{CicconePadovani22}, here we adopt the new characterization
of fair subtyping that we introduced later in \cite{CicconeDP22}.
\Cref{ch:ft_multi}, \Cref{ch:ft_ll} show the type systems that have been presented in \cite{CicconeDP22}
and in \cite{CicconeP22b}, respectively.

\paragraph{Agda}
The Agda library for (Generalized) Inference Systems in \Cref{ch:gis_lib} has been presented
in \cite{CicconeDagninoZucca21} which is based on \cite{Ciccone20}. 
At last, the Agda formalizations of the properties of session types in \Cref{ch:agda_prop}
have been presented in \cite{CicconeP22@lmcs,CicconePadovani21}.

\paragraph{Not in this thesis}
In \cite{CicconePadovani20} we provide an Agda mechanization of a linear $\pi$-calculus
with dependent types. One of the interesting features of such formalization is that we 
can inject Agda terms in the calculus by using a proper constructor 
for the terms of the calculus.
Although that work covers some topics that are related to the present thesis
(\eg $\pi$-calculus, Agda mechanization, induction/coinduction), we do not give details
about it as it falls outside the core topic the thesis.
Moreover, we are working on an Agda unification library and on 
co-contextual typing inference algorithms for the linear and shared $pi$-calculus
proved to be correct in the proof assistant. Such work is based on \cite{ZalakainD21}.
