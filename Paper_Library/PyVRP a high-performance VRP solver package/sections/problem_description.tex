\section{Problem description}
\label{sec:problem_description}

PyVRP currently supports two VRP variants: CVRP and VRPTW.
The CVRP aims to construct multiple routes, each starting and ending at the same depot, to serve a set of customers while minimising total distance.
The total demand of customers in a single vehicle is limited by the vehicle capacity. 
The VRPTW generalises the CVRP by adding the constraint that each customer must be visited within a certain time window.
\added{
For both CVRP and VRPTW, PyVRP supports minimising distances, not the number of vehicles used.
A simple procedure to support fleet minimisation can be developed on top of PyVRP, by first finding a feasible solution with some number of vehicles, and then removing one vehicle at a time until no feasible solution is found.
}
PyVRP has been designed to handle instances of these problems with up to several thousand customers.

\subsection{CVRP}
Formally, the capacitated VRP consists of customers $i = 1, ..., n$ with demands $q_i \ge 0$, which must be served from a common depot denoted as $0$.
The goal is to visit all customers using a fixed fleet of vehicles, each of which starts at, and returns to, the depot, while minimising the total distance travelled, where the distance from customer (or depot) $i$ to $j$ is denoted as $d_{ij} \ge 0$.
The total demand in each vehicle should not exceed the vehicle capacity $Q > 0$.

\subsection{VRPTW}
For the VRPTW, each customer additionally has a service time $s_i \ge 0$, an earliest arrival time $e_i \ge 0$ and latest arrival time $l_i \ge 0~(e_i \le l_i)$ in between which service should \emph{start}.
A vehicle can wait at customer $i$ when arriving too early, but cannot arrive after $l_i$.
The time to travel from customer (or depot) $i$ to $j$ is given by $t_{ij} \ge 0$.
\added{While in academic benchmarks the duration $t_{ij}$ is typically set equal to the distance $d_{ij}$, PyVRP supports separate distance and duration matrices, as is commonly encountered in practice.}

\subsection{Conventions}
There are different conventions on the definitions of the constraints and objectives for CVRP and VRPTW, especially relating to rounding of (Euclidean) distances and other data \added{in existing benchmark instances} (see e.g.\ \citet{uchoa2017new}). 
PyVRP supports \emph{integer} distances \added{and durations}, which should be provided \emph{explicitly} by the user.
\added{Additionally, PyVRP can be compiled to use double precision data as well, but that is not enabled by default for performance reasons: we found during initial experimentation that working with double precision data is somewhat slower than using integers.}
\added{For working with benchmark instances,} we rely on the \textsc{VRPLIB} package \added{\citep{lan_vrplib_2023}} to compute distances \added{and durations}, and we provide helper functions to scale and then round or truncate them before converting to integers.
This way, we support various conventions, including the one-decimal precision used in the DIMACS VRPTW challenge, and the CVRPLIB benchmark repository at \url{http://vrp.galgos.inf.puc-rio.br/}.
