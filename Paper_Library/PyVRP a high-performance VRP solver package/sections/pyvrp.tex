\section{The PyVRP package}
\label{sec:package}

The PyVRP package is developed in a GitHub repository located at \url{https://github.com/PyVRP/PyVRP}. 
The repository contains the C++ and Python source code, including unit and integration tests, as well as documentation and examples introducing new users to PyVRP.
Additionally, the repository uses automated workflows that build PyVRP for different platforms (currently Linux, Windows, and Mac OS), such that a user can install PyVRP directly from the Python package index using \texttt{pip install pyvrp} without having to compile the C++ extensions themselves.

\subsection{Package structure}
The top-level \texttt{pyvrp} namespace contains some of the components of Section~\ref{sec:technical_implementation}, and important additional classes.
These include \added{the \texttt{Model} modelling interface,} the \texttt{GeneticAlgorithm} and \texttt{Population}, along with a \texttt{read} function that can be used to read benchmark instances in various formats (through the VRPLIB Python package).
Crossover operators that can be used together with the \texttt{GeneticAlgorithm} are provided in \texttt{pyvrp.crossover}.
Further, the \texttt{pyvrp.diversity} namespace constains diversity measures that can be used with the \texttt{Population}.
The \texttt{pyvrp.\replaced{search}{educate}} namespace contains the \texttt{LocalSearch} class, the \deleted{node and route} operators, and the \texttt{compute\_neighbours} function that computes a granular neighbourhood.
Stopping criteria for the genetic algorithm are provided by \texttt{pyvrp.stop}.
These include stopping criteria based on a maximum number of iterations or runtime, but also variants that stop after a number of iterations without improvement.
Finally, \texttt{pyvrp.plotting} provides utilities for plotting and analysing solutions.

\subsection{Example use}
\added{
We present two examples, for different audiences.
The first example in Listing~\ref{lst:model_api} shows the modelling interface of PyVRP, and how that can be used to define and solve a CVRP instance.
This interface is particularly convenient for practitioners interested in solving VRPs using PyVRP.
The second example in Listing~\ref{lst:pyvrp} shows the different components in PyVRP, and how they can be used to solve a VRPTW instance.
This example is helpful for understanding how PyVRP's implementation of HGS works, and can be used as a basis to customise the solution algorithm.
}

\added{
We will first present the modelling interface in Listing~\ref{lst:model_api}.
}

\lstinputlisting[style=mypython, language=Python, caption=Using PyVRP's modelling interface to solve a CVRP instance., label=lst:model_api]{examples/api.py}

\added{
The modelling interface is available as \texttt{Model}, and can be used to define all relevant instance attributes: the depot, clients, vehicle types, and the edges connecting all locations.
After defining an instance, it can be solved by calling the \texttt{solve} method on the model.
Once solving finishes, a result object \texttt{res} is returned.
This object contains the best-found solution (\texttt{res.best}) and statistics about the solver run.
The result object can be printed to display the solution and some relevant statistics.
Additionally, the results can be plotted, which we will show how to do in Listing~\ref{lst:pyvrp}.
}

In Listing~\ref{lst:pyvrp} we solve the 1000 customer \texttt{RC2\_10\_5} instance of the Homberger and Gehring VRPTW set of benchmarks.
\added{Rather than using the modelling interface's high-level \texttt{solve} method, here we set everything up explicitly.}
The code assumes that the \texttt{RC2\_10\_5} instance is available locally.

\lstinputlisting[style=mypython, language=Python, caption=PyVRP example usage., label=lst:pyvrp]{examples/example.py}

\added{
Listing~\ref{lst:pyvrp} first reads a benchmark instance in standard format and constructs a random number generator with fixed seed.
It then defines the local search method.
We use the default granular neighbourhood computed by \texttt{compute\_neighbours}, but this can easily be customised by providing an alternative neighbourhood definition.
Then, we add all node and route operators described in Section~\ref{subsec:local_search} to the local search object.
This is not required: any subset of these operators is also allowed, and might even improve the solver performance in specific cases.
Finally, the penalty manager and population are initialised.
These track, respectively, the weights of constraint violation penalties, and the feasible and infeasible solution subpopulations.
An initial population should also be provided to the genetic algorithm: here we generate 25 random solutions.
A user may wish to apply alternative population generation methods here.
Finally, the genetic algorithm is initialised and run until a stopping criterion is met: in this case, the stopping criterion is 60 seconds of runtime.
We plot the solver trajectory and best observed solution in Figure~\ref{fig:RC2_10_5}.
}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/RC2_10_5.pdf}
    \caption{
        Detailed statistics collected from a single run of Listing \ref{lst:pyvrp}. 
        The top-left figure shows the average diversity of the feasible and infeasible sub-populations.
        It is clear from this figure that periodic survivor selection improves diversity.
        The middle-left figure shows the best and average objectives of both sub-populations, which improve over time as the search progresses.
        The bottom-left figure shows iteration runtimes (in seconds), \added{including a trendline}.
        Finally, the figure on the right plots the best observed solution.
    }
    \label{fig:RC2_10_5}
\end{figure}

\subsection{\added{Extending PyVRP}}

\added{
Before writing new code for PyVRP, a few things must be decided about the new constraint.
Hard constraints might require changes to PyVRP data structures.
Soft constraints typically require modifications to the cost evaluation functions.
Additionally, the new constraint likely requires additional data attributes that must be added to PyVRP's data instance object, and solution representation.
Once that new data is available, the search method can be updated to compute the correct cost deltas of each available move.
Some of the cost delta evaluation may need to be cached to ensure an efficient implementation---this is particularly the case for time-related costs, which PyVRP already supports.
Entirely new problem aspects might need to develop such caching as part of the extension.
}

\added{
Since we have developed several extensions to PyVRP already, there are some examples available of previous work.
We have summarised guidelines for extending PyVRP in our online documentation, available at \protect\url{https://pyvrp.org/dev/new_vrp_variants.html}.
}
