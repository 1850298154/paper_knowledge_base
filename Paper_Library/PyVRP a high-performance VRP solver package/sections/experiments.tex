\section{Experiments}
\label{sec:experiments}

In this section we present PyVRP's performance on widely used CVRP and VRPTW benchmark instances.
\added{We compare PyVRP's performance with both the best known solutions (BKSs), and with results from the literature, accounting for CPU differences by adjusting the time limits based on the PassMark score.}
\replaced{PyVRP is benchmarked}{All our benchmarks are performed} on an \replaced{AMD EPYC 7H12}{Intel Xeon Gold 5118} CPU with a PassMark single thread performance of \replaced{2014}{1807}.
\added{We benchmark PyVRP version 0.5.0, which is available as a static archive on the IJOC GitHub repository~\citep{wouda_et_al_2023_code_repo}.}
The BKSs were obtained from the CVRPLIB repository on 28 February 2023.

\subsection{CVRP}
We evaluate our solver for CVRP on the X benchmark instances of \cite{uchoa2017new}.
This set includes 100 instances and covers diverse problem characteristics, such as customer geography, demand distributions and route lengths.
We follow the convention to minimise the total distance.
The distances are computed by taking the Euclidean distances rounded to the nearest integer.
The parameter settings used in our experiments are shown in Table~\ref{tab:parameters} in Appendix~\ref{app:parameters}.
We solve each instance with ten different seeds and present the average total distance rounded to one decimal.
We compare our solver \replaced{with}{against} the results of state-of-the-art CVRP solvers HGS-2012 \citep{vidal2013hybrid} and HGS-CVRP \citep{vidal2022hybrid}.
We use the time limits of \cite{vidal2022hybrid}: each instance is solved for $T_{\max} = n \times 240/100$ seconds, where $n$ denotes the number of customers in the instance.
The smallest instance of 100 customers is thus solved for 4 minutes, and the largest instance with 1000 customers is solved for 40 minutes. 
The experiments from \cite{vidal2022hybrid} were run on a single core of an Intel Gold 6148 CPU with PassMark single thread performance of 2183. 
We normalise the time limit by multiplying $T_{\max}$ with 2183 / \replaced{2014}{1807} to compensate for the CPU differences.

\begin{table}
    \centering
    \caption{Benchmark results for CVRP on X instances of \citet{uchoa2017new}.}
    \input{tables/cvrp-results-summary.tex}
    \label{tab:cvrp-results-summary}
\end{table}

Table~\ref{tab:cvrp-results-summary} presents the summarised results for CVRP.
We report both the \emph{mean gap} $\frac{1}{n}\sum_i \frac{c_i}{\text{BKS}_i} - 1$, as well as the \emph{gap of the mean} $\frac{\frac{1}{n}\sum_i c_i}{\frac{1}{n}\sum_i \text{BKS}_i} - 1$. 
Here $i$ represents a single instance, $c_i$ denotes the objective value of the solver's solution, and $\text{BKS}_i$ the best known solution value. 
The gaps are expressed as percentages.
PyVRP obtains a mean gap of 0.22\% and a gap of the mean of \replaced{0.27}{0.30}\% on the solved instances. 
Despite the fact that PyVRP has not been specifically designed for the CVRP, these gaps are only slightly higher than the gaps of specialised CVRP solvers like HGS-2012 (mean gap 0.21\% and gap of mean 0.28 \%) and HGS-CVRP (mean gap 0.11\% and gap of mean 0.16\%). 
The complete results for each instance can be found in Table~\ref{tab:cvrp-results} in Appendix~\ref{app:cvrp-results}.

\subsection{VRPTW}
We evaluate our solver on the well-known Homberger and Gehring VRPTW instance set \citep{homberger1999two}.
The set includes five categories of instance sizes with 200, 400, 600, 800 and 1000 customers.
For brevity, we only presents results here for the 1000 customer instances.
The relative performance differences on smaller instances are similar to the results on the 1000 customer instances.
Following the DIMACS competition convention, we minimise the total travel distance and set a time limit of two hours for 1000 customer instances on a CPU with reference PassMark score of 2000.
We normalise the time limits for our choice of CPU, so we multiply the time limits by 2000 / \replaced{2014}{1807} in our numerical experiments.
We solve each instance with ten different seeds and present the average total distance rounded to 1 decimal.
The parameter settings of our solver are shown in Table~\ref{tab:parameters} and largely follow the parameter values used by \cite{kool2022hybrid} and \cite{van_doorn_solving_2022}.
We compare PyVRP \replaced{with}{against} the solutions found by \cite{kool2022hybrid}, denoted as HGS-DIMACS.
Since the original DIMACS results were reported as gaps to a reference solution provided by the DIMACS organisation, we also include the gaps \replaced{between these reference solutions and the reference BKSs}{with respect to these reference solutions}.

\begin{table}
    \centering
    \caption{Benchmark results for VRPTW on 1000 customer instances of \citet{homberger1999two}.}
    \input{tables/vrptw-results-summary.tex}
    \label{tab:vrptw-results-summary}
\end{table}

Table~\ref{tab:vrptw-results-summary} summarises the results for VRPTW. 
The complete results for each instance can be found in Table~\ref{tab:vrptw-results} in Appendix~\ref{app:vrptw-results}.
We again report both the mean gap and the gap of the mean.
PyVRP achieves a mean gap of \replaced{0.40}{0.45}\% and gap of mean of \replaced{0.46}{0.54}\% on the VRPTW benchmark instances, which is slightly higher than that of HGS-DIMACS (mean gap of 0.32\% and gap of mean 0.37\%).
The difference in performance can be explained by the simplified implementation of PyVRP.
As a result of this simplification, PyVRP would have ended up in second place in the DIMACS VRPTW competition.
\added{Furthermore, during extended runs, PyVRP managed to improve 27 of the 300 best known solutions of the complete Homberger and Gehring instances.}

% Improved instances
%  'R1_4_2',
%  'R1_4_3',
%  'R1_4_9',
%  'R2_4_10',
%  'R1_6_2',
%  'R2_6_4',
%  'R2_6_7',
%  'RC1_6_1',
%  'RC2_6_10',
%  'C2_8_4',
%  'R2_8_1',
%  'R2_8_10',
%  'R2_8_3',
%  'R2_8_4',
%  'R2_8_5',
%  'R2_8_7',
%  'RC1_8_1',
%  'RC1_8_6',
%  'RC1_8_7',
%  'RC1_8_8',
%  'RC1_8_9',
%  'RC2_8_6',
%  'RC2_8_9'}
%  'RC2_10_10',
%  'RC2_10_7',
%  'RC2_10_8',
%  'C1_10_3',
