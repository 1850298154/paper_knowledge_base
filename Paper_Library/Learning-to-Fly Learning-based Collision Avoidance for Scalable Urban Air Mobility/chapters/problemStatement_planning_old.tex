\subsection{UAS planning with STL specifications}
\label{sec:problem_planning}

Fly-by-logic, the method of \cite{pant2018fly}, generates trajectories by centrally planning for fleets of UAS with STL mission specifications, e.g. for the specification $\varphi_{\text{reach-avoid}}$ of example \ref{ex:reach_avoid_exmp}. It does by maximizing a smooth approximation ($\srob_\formula$) of the robustness function \cite{pant2017smooth} by picking waypoints (connected via jerk-minimzing splines \cite{MuellerTRO15}) for each UAS through centralized, non-convex optimization.

While the method shows success in planning for multiple multi-rotor 
UAS, its performance degrades as the number of UAS being planned for 
increases. There are two main reasons for this: a) it solves a 
(non-convex) optimization involving the variables of all the UAS, so 
the problem becomes harder as the number of variables increase, and 
b) for $J$ UAS, it has to account for $J \choose 2$ terms for 
pair-wise separation between the UAS (eq. \ref{eq:timed_RA}). So 
increasing the number of UAS makes the problem harder to solve. For 
these reasons, the method cannot be used for real-time planning. In 
addition, for a large airspace with a small number of UAS, centrally 
taking the $J \choose 2$ constraints into account might not be 
necessary as possible collisions between UAS could be possibly 
infrequent. 

Taking these observations into account, we use the underlying optimization of  \cite{pant2018fly} to generate trajectories \footnote{we could also have used the method of \cite{Raman14_MPCSTL}, but instead use \cite{pant2018fly} because of it being computationally faster and tailored for multi-rotor robots.}, but allow each UAS to independently (and in parallel) solve for their own STL specification. This is captured in the following problem:

\begin{myprob}
\label{prob:STLtraj}
For UAS $j$, given STL specification $\varphi_j$, generate trajectory 
$\sstraj_j$ such that $\sstraj_j \models \varphi_j$. 
\end{myprob}


%Each UAS $d$, is given its mission as a STL specification $\phi_d$. This specification is defined over the variables of just UAS $d$, and does not involve any other UAS. An example of such a specification is $\phi_1 = \always_I \neg (p_1 \in \text{Unsafe}) \land \eventually_I (p_1 \in \text{Goal})$, corresponding to a timed reach-avoid problem. Given such a specification a UAS, each UAS $d$ uses the method of \cite{pant2018fly} to generate trajectories that satisfy $\phi_d$:

Each UAS solves this problem (to generate a trajectory of duration 
$hrz(\varphi_j)$) by solving an optimization of the form:

\begin{equation}
\label{eq:single_FbL}
\begin{split}
\text{max}_{\mathbf{w}_j} \,\srob_{\varphi_j}(L\mathbf{w}_j) \\
F\mathbf{w_j} \leq l
\end{split}
\end{equation}

Here, $\srob_{\varphi_j}$ is the smooth robustness, and $L$ is a 
linear map that takes a sequence of waypoints $\mathbf{w}_j$ (vectors 
in 3D position and velocity space) to generate a discrete-time 
trajectory $\sstraj_j=L(\mathbf{w}_j)$ of duration $hrz(\varphi_j)$. 
This trajectory consists of spline segments that minimize the 
integral of jerk over time going from one waypoint to the next 
\cite{MuellerTRO15}. The linear constraints on the waypoints are such 
that they ensure kinematic feasibility (Theorem 3.2 in 
\cite{pant2018fly}) of the resulting trajectories, i.e. the 
velocities and accelerations of the UAS are within predefined bounds. 
For brevity , we omit the details here, but the full formulation can 
be found in \cite{pant2018fly}. The resulting robustness value of the 
generated trajectory $\sstraj_j$, $\rho_{\varphi_j}$, defines the 
robustness tube around the trajectory. 

By allowing each UAS to plan for itself independent of the others, we have ignored the mutual separation requirement in the STL-based planning problem. Instead we rely on online collision avoidance to pairwise ensure that UAS do not crash with each other. This is covered in the following section.

\textbf{Note:} In the following sections, $\mathbf{x}$ will refer to a full-state (discrete-time, finite duration) trajectory for a UAS. We will also use $\mathbf{p}$ to refer to the position components in that trajectory, or the position trajectory. $x_k$ (and $p_k$) refer to the components of the trajectory at time step $k$.

%The robustness value $\rho_d*$ achieved through solving this optimization can be interpreted as a discrete tube in the position space $P_d$ such that as long as the discrete time positions of the UAS remain inside the robustness cubes of size $2\rho_d$ centered around the planned positions, $\phi_d$ is satisfied (see Theorem \ref{thm:rob objective}). See fig \ref{fig:concept} for a visualization of this interpretation. It should be noted that such a trajectory (and its robustness tube) can be generated by other methods as well, e.g. that of \cite{Raman14_MPCSTL}, but we use \cite{pant2018fly} because of it being computationally faster and tailored for multi-rotor robots.