In this section, we describe \emph{sparsified enhanced conflict-based search} (\secbs), a new algorithm for solving the locally-dense \mpp instances. 
% 
In locally-dense \mpp instances, the total number of robots in a map is not necessarily high. 
% 
But in the start/goal configurations, robots might be distributed unevenly.
% 
In these instances, the local density at some locations is extremely high, i.e., $\approx 100\%$.
% 
Assume that the local area of the vertex $v$ is the $W\times W$ square area centered at $v$.
% 
The local density at vertex $v$ is defined as $\rho_l(v)=\frac{n_v}{A_v}$, where $n_v$ is the number of robots located in the local area of $v$ and $A_v$ is the number of non-obstacle vertices in the local area of $v$.


%We propose  a hybrid algorithm named \secbs for solving locally dense and congested \mpp instances.
% 
% 
The hybrid \secbs algorithm is outlined in Alg.~\ref{alg:secbs} and Alg.~\ref{alg:greedy}.
% 
The basic idea of \secbs is to convert the congested configurations into some intermediate configurations that are less dense and correlated and thus easier to solve. 
% 
\secbs first tries to find an intermediate start configuration $X_S'$ and an intermediate goal configuration $X_G'$ which are more sparse than original starts and goals.
% 
Then the original problem breaks into three sub-problems, $P_1(\mathcal{G},X_S,X_S'),P_2(\mathcal{G},X_S',X_G'),P_3(\mathcal{G},X_G',X_G)$.
% 
Since the intermediate states are less dense than the original starts and goals, robots are less correlated, and as a consequence, solving $P_2(\mathcal{G},X_S',X_G')$ using \ecbs takes less time than solving the original problem.
% 
While for $P_1$ and $P_3$, they can be formulated as unlabeled \mpp and be solved in polynomial time using  algorithms in \cite{yu2012distance,yu2013multi} (line 4-5). 
% 
The final solution can be obtained by merging the paths for the sub-problems (line 7).
% 

Obviously, the sparsification procedure introduces additional overhead on the optimality.
% 
Finding a good intermediate state is essential for balancing the computation time and solution quality.
% 
The intermediate configurations should try to satisfy the following:
% 
(i). $X_S'$ and $X_G'$ should be close to the original states as much as possible; 
% 
(ii). The local density for each robot is controlled under a preferred robot density $\rho^{*}$, if possible.
% 
% The local density around at vertex $u$, denoted as $\rho(u)$, is defined as the number of robots within a $W\times W$ square centered at $u$ divided by the number of non-obstacle nodes. 
% 
Finding the intermediate state can be formulated as an optimal assignment problem, which may be solved using integer linear programming.
% 
However, this would be very time-consuming.
%
Instead, we develop an efficient suboptimal greedy algorithm for finding the assignment.


\begin{algorithm}
\begin{small}
\DontPrintSemicolon
\SetKwProg{Fn}{Function}{:}{}
\SetKw{Continue}{continue}
  \KwIn{Starts $X_S$, goals $X_G$, preferred density $\rho^{*}$}
  \Fn{\textsc{SECBS}({$S,G$})}{
 \caption{\secbs \label{alg:secbs}}
\vspace{1mm}
$X_S''\leftarrow\texttt{SparsifyConfig}(X_S,X_G,\rho^{*})$\;
\vspace{1mm}
$X_G''\leftarrow\texttt{SparsifyConfig}(X_G,X_S,\rho^{*})$\;
\vspace{1mm}
$X_S',P_S\leftarrow \texttt{UMRPP}(X_S,X_S'')$\;
\vspace{1mm}
$X_G',P_G\leftarrow \texttt{UMRPP}(X_G,X_G'')$\;
\vspace{1mm}
$P_M\leftarrow \texttt{ECBS}(X_S',X_G')$\;
\vspace{1mm}
$solution\leftarrow \texttt{Merge}(P_S,P_M,P_G)$\;
\vspace{1mm}
\Return $solution$\;
}
\end{small}
\end{algorithm}

Alg.~\ref{alg:secbs} describes how we find the intermediate configuration.
% 
It runs in a decoupled manner and finds the best location for each robot one  by one greedily.
% 
For each robot $i$, we use A* to  explore the nodes in the graph where the A* heuristic is set to be the sum of the distance  from its start and goal.
% 
For the node $u$ to expand, we check if we choose $u$ as the intermediate vertex for robot $i$ whether the local density at each vertex in CONFIG  is still less than $\rho^{*}$.
% 
If that is true, we set $u$ as an intermediate vertex and add it to CONFIG.
% 
The configurations found by the greedy algorithm are used as the unlabeled configurations $X_S''$ and $X_G''$.
% 
The unlabeled \mpp solver finds the intermediate paths $P_S$ and $P_G$ and assigns the intermediate vertices to the robots to get the labeled configurations $X_S', X_G'$.
% 
\begin{algorithm}
\begin{small}
\DontPrintSemicolon
\SetKwProg{Fn}{Function}{:}{}
\SetKw{Continue}{continue}
 \caption{SparsifyConfig \label{alg:greedy}}
 $\text{CONFIG}\leftarrow\{\}$\;
\vspace{1mm}
\For{$i$ in $[1,...,n]$}{
$n\leftarrow (s_i,dist(s_i,g_i))$\;
\vspace{1mm}
$\text{OPEN}\leftarrow \{n\}$\;
\vspace{1mm}
$\text{CLOSE}\leftarrow \{\}$\;
\vspace{1mm}
\While{$\textsc{OPEN}\neq \emptyset$}{
\vspace{1mm}
$(u,f)\leftarrow \text{OPEN}.pop()$\;
\vspace{1mm}
\If{$u\in \textsc{CLOSE}$}{continue\;}
\vspace{1mm}
$\text{CLOSE}.add(u)$\;
\vspace{1mm}
\If{$\texttt{CheckDensity}(u,\textsc{CONFIG},\rho^{*}) \vspace{1mm}
\wedge u\not\in \textsc{CONFIG}$}{
\vspace{1mm}
$\text{CONFIG}.add(u)$\;
\vspace{1mm}
break\;
}
\For{$v\in u.neighbors$}{
\vspace{1mm}
$f\leftarrow dist(v,s_i)+dist(v,g_i)$\;
\vspace{1mm}
$\text{OPEN}.push((v,f))$\;
}
}
}
\Return CONFIG\;
\end{small}
\end{algorithm}

As for merging the paths, simply concatenating the paths which may make the solution very suboptimal in terms of \soc \cite{guo2021spatial}.
% 
This is because robots need to be synchronized to execute the planned paths of each subproblem and some of the robots have to wait unnecessarily. 
% 
We use the method based on Minimum Communication Policy (MCP)~\cite{ma2016information} in \cite{Guo2023TowardEP}. 
% 
This method tries to move the robots to their next vertex in their original plan as quickly as possible, which leads to a solution with better \soc optimality.
