\subsection{Multi-Robot Path Planning on Graphs}
A graph-based Multi-Robot Path Planning (\mpp) problem is defined on a graph $\mathcal{G} = (\mathcal{V},\mathcal{ E})$. 
% 
We assume that $\mathcal{G}$ is a grid graph. 
% 
That is, given integers $w$ and $h$ as the graph's {\em width} and {\em height}, 
% 
the vertex set can be represented as $\mathcal{V} \subseteq \{(i, j) \mid 1 \leq i \leq w, 1 \leq j \leq h,i\in \mathbb{Z},j\in \mathbb{Z}\}$. 
% 
The graph is $4$-way connected, i.e., for a vertex $v = (i, j)$, the set of its neighboring 
vertices are defined as $\mathcal{N}(v) = \{(i + 1, j),(i - 1, j),(i, j + 1),(i, j - 1)\} \bigcap \mathcal{V}$. 
% 
The problem involves $n$ robots $r_1, \dots, r_n$, 
where each robot $r_i$ has a unique start state $s_i \in \mathcal{V}$ and a unique goal state $g_i \in \mathcal{V}$. 
% 
We denote the joint start configuration as $X_S = \{s_1, \dots, s_n\}$ and the goal configuration as $X_G = \{g_1, \dots, g_n\}$. 
% 


The objective of \mpp is to find a set of feasible paths for all robots. 
% 
Here, a {\em path} for robot $r_i$ is defined as a sequence of $T + 1$ vertices 
$P_i = (p_i^0, \dots, p_i^T)$ that satisfies: 
(i) $p_i^0 = s_i$; 
(ii) $p_i^T = g_i$; 
(iii) $\forall 1 \leq t \leq T, p_i^{t - 1} \in N(p_i^t)$. %\sh{Extra $\}$}
Apart from the feasibility of each individual path, for $P$ to be collision(conflict)-free , 
$\forall 1 \leq t \leq T, 1 \leq i < j \leq n$, $P_i, P_j$ must satisfy 
\begin{enumerate}[leftmargin=7mm]
    \item There is no \emph{vertex collision}: $p_i^t \neq p_j^t$; 
    \item There is no \emph{edge collision}: $ (p_i^{t - 1}, p_i^t) \neq (p_j^t, p_j^{t - 1})$.
\end{enumerate}
and the following criteria are used to evaluate solution quality:
\begin{enumerate}[leftmargin=7mm]
    \item Makespan (\makespan): the time required to move all robots to their desired positions;
    \item Sum-of-cost (\soc): the cumulative cost function that sums over 
all robots of the number of time steps required to reach the goals. For each robot, denoting $t_i$ 
such that $\forall t_i \leq t \leq T, p_i^t = g_i$, the sum-of-costs objective is calculated as 
$\min \sum_{1 \leq i \leq n} t_i$. 
\end{enumerate}
In general, these two objectives create  a  Pareto  front \cite{yu2013structure}, and it  is  not always possible to simultaneously optimize these objectives.

\subsection{Enhanced Conflict Based Search (ECBS)}

\ecbs($w_1$)\cite{barer2014suboptimal} is a variant of CBS \cite{sharon2015conflict} that is  $w_1$-suboptimal, which employs the focal search method \cite{pearl1982studies}  in both its high-level and low-level searches  rather than best-first searches. 
% 

A focal search, like A*, uses an OPEN list whose nodes $n$ are sorted in increasing order of their $f$-values $f(n)=g(n)+h(n)$, where $h(n)$ are the primary heuristic values. 
% 
Unlike A*, a focal search with suboptimality factor $w_1$ also uses a FOCAL list of all nodes currently in the OPEN list whose $f$-values are no larger than $w_1$ times the currently smallest $f$-value in the OPEN list.
% 
The nodes in the FOCAL list are sorted in increasing order of their secondary heuristic values.
% 
A* expands a node in the OPEN list with the smallest $f$-value, but a focal search expands a node in the FOCAL list instead with the smallest secondary heuristic value.
% 
Thus, the secondary heuristic values should favor a node in the FOCAL list close to a goal node to speed up the search and thus exploit the leeway afforded by $w_1$ that A* does not have available. 
% 
If the primary heuristic values are admissible, then a focal search is $w_1$-suboptimal.
% 
The secondary heuristic values can be inadmissible.
% 

The high-level and low-level searches of ECBS($w_1$) are both focal searches.
% 
During the generation of a high-level node $N$, ECBS($w_1$) performs a low-level focal search with OPEN list $\text{OPEN}_i(N)$ 
and FOCAL list $\text{FOCAL}_i(N)$ for the robot $i$ affected by the added constraint. 
% 
The number of collisions(\noc) is used as the secondary heuristic value for the high-level and low-level searches, allowing ECBS ($w_1$) to generate high-level nodes with fewer collisions compared to CBS, which improves its efficiency. 
% 
However, the path costs can become large for ECBS($w_1$) with large values of $w_1$ due to the larger leeway afforded by $w_1$. 
% 
The robots might move around in wiggly lines, increasing the chance of collisions, thus increasing the number of collisions in the high-level and low-level nodes of ECBS($w_1$) and slowing it down.
% 
Thus, larger values of $w_1$ do not necessarily entail smaller runtimes of ECBS($w_1$).
% 
In this paper, the \soc suboptimality bound is chosen to be $w_1=1.5$, which is a good choice according to the original paper\cite{barer2014suboptimal}.

\subsection{DDM}
\ddm~\cite{barer2014suboptimal}, standing for \emph{\textbf{d}iversified path and \textbf{d}atabase-driven \textbf{m}ulti-robot path planner}, is a fast suboptimal \mpp solver.
% 
It first generates a shortest  path  between  each  pair  of  start  and  goal  vertices and then resolves local conflicts among the initial paths. 
% 
In generating the initial paths, a path diversification heuristic is introduced that attempts to make the path ensemble use all  graph  vertices  in  a  balanced  manner,  
% 
which  minimizes the  chance  that  many  robots  aggregate  in  certain  local areas, causing unwanted congestion, in order to reduce the number of conflicts of the initial paths. 
% 

Then, in resolving the path conflicts, a database resolution heuristic is introduced, which builds a min-makespan solution database for  all $2\times 3$ and $3\times3$ sub-problems and  ensures  quick  local  conflict  resolution  via  database retrievals. 
% 
Specifically, for each conflicting robot pair in each step, \ddm tries to find a $2\times 3$ or $3\times 3$ subgraph that contains these robots.
% 
Temporary goals are assigned to the robots within the subgraph to resolve the conflict.
% 
The paths for routing them to the temporary goals can be obtained easily by accessing the precomputed database.
% 
Obviously, each time resolving a conflict using subgraphs will introduce an extra overhead to the paths' length.
% 
In dense environments, the number of conflicts needed to resolve is high, and as a result, \ddm can be very suboptimal under these scenarios.