\subsection{The Generalized Sliding-Tile Puzzle}
In the \emph{generalized sliding-tile puzzle} (\gstp), on a rectangular $m_1 \times m_2$ grid $G=(V, E)$ lies $n < m_1m_2$ tiles, uniquely labeled $1, \ldots, n$. 
%
A \emph{configuration} of the tiles is an injective mapping from $\{1, \ldots, n\} \to V = \{(v_y, v_x)\}$ where $1 \le v_y \le m_1$ and $1 \le v_x \le m_2$. 
%
Tiles must be reconfigured from a random configuration $\mathcal S=\{s_1, \ldots, s_n\}$ to some goal configuration $\mathcal G=\{g_1, \ldots, g_n\}$, usually a row-major ordering of the tiles, subject to certain constraints. 
%
Specifically, let the \emph{path} of tile $i$, $1\le i \le n$, be $p_i : \mathbb{N}_0 \to V$, and so \gstp seeks a \emph{feasible path set} $P = \{p_1, \ldots, p_n\}$ such that the following constraints are met for all $1\le i, j\le n$, $i \ne j$ and $\forall t \geq 0$: 
\begin{itemize}
    \item Continuous uniform motion: $p_i(t+1) = p_i(t)$ or $(p_i(t+1), p_i(t)) \in E$,
    \item Completion: $p_i(0) = s_i$ and $p_i(T) = g_i$ for some $T\ge 0$,
    \item No meet collision: $p_i(t) \neq p_j(t)$,
    \item No head-on collision: $(p_i(t)=p_j(t+1) \land p_i(t+1) = p_j(t)) = false$,
    \item Corner-following constraint: let $e_i(t) = p_i(t+1) - p_i(t)$ be the movement direction vector. If $p_i(t+1) = p_j(t)$, then $e_i(t) \not\perp e_j(t)$.
\end{itemize}

Let $T_P$ be the smallest $T\ge 0$ such that the completion constraint is met for a given path set $P$. Naturally, it is desirable to compute $P$ with minimum $T_P$. We define the decision version of makespan-optimal \gstp as follows. 

\vspace{2mm}
\noindent\mogstp\\
\noindent INSTANCE: A \gstp instance and a positive integer $K$.\\
\noindent QUESTION: Is there a feasible path set $P$ with $T_P \le K$?
%\vspace{2mm}

\subsection{\ttfsat}\label{sec:224}
We will need a specialized SAT instance called \ttfsat for our hardness result, defined as follows. 

\vspace{2mm}
\noindent \ttfsat\\
\noindent \textbf{INSTANCE}: A boolean satisfiability instance with $n$ variables $x_1, \ldots x_n$ and $n$ clauses $c_1, \ldots c_n$. Each clause $c_j$ has $4$ literals, and each variable $x_i$ appears across all clauses exactly $4$ times in total, twice negated and twice unnegated.

\noindent \textbf{QUESTION}: Is there an assignment to $x_1, \ldots, x_n$ such that each clause $c_i$ has exactly two true literals?
\vspace{2mm}

\ttfsat was shown to be NP-complete in \cite{RATNER1990111}, which is subsequently employed to show the hardness of the $(N^2-1)$-puzzle.
% Note that a \ttfsat is satisfiable if and only if exactly $2n$ literals are true. 


\subsection{Feasibility and Known Makespan Bounds}
It is well-known that the $(N^2-1)$-puzzle may not always have a solution \cite{loyd1959mathematical} due to the configurations forming two connected graphs. More formally, it can be shown that the configurations of an $(N^2-1)$-puzzle are partitioned into two groups, each of which is isomorphic to the \emph{alternating group} $A_{N^2-1}$ \cite{wilson1974graph}. Because moves on a \gstp instance on an $N \times N$ grid with a single escort can be ``slowed down'' to equivalent moves on an $(N^2-1)$-puzzle, they share the same feasibility. The same remains true for rectangular grids. Checking feasibility can be performed in linear time \cite{wilson1974graph}. On the other hand, also clear from \cite{wilson1974graph}, when there are two or more escorts, a \gstp instance is always feasible. To summarize,
%
\begin{lemma}
\gstp with a single escort may be infeasible. The feasibility of \gstp with a single escort can be checked in linear time. \gstp with two or more escorts is feasible. 
\end{lemma}

Given a feasible $(N^2-1)$-puzzle, each tile can be moved to its goal in $O(N)$ steps since a tile is within $O(N)$ distance to its goal and $O(1)$ steps are needed to switch two tiles. This suggests an $O(N^3)$ algorithm, which readily extends to an $O(m_1m_2\max(m_1,m_2))$ step algorithm on an $m_1\times m_2$ grid. This is also an upper bound for \gstp with a single escort. \gstp with more escorts is studied in the context of automated garages \cite{guo2023efficient}, with results on $\Theta(m_1m_2)$ escorts and $(2m_1 + 2m_2 - 4)$ escorts. To summarize, the following is known: 
\vspace{2mm}

\newcolumntype{Y}{>{\centering\arraybackslash}X}
\noindent
\begin{small}
\begin{tabularx}{\columnwidth}{| c | Y |}
\hline
Number of escorts  &  Makespan upper bound \\ \hline
$1$ & $O(m_1m_2\max(m_1,m_2))$  \\ \hline
$(2m_1+2m_2-4)$ & $O(m_1m_2)$ \\ \hline
$\Theta(m_1m_2)$ & $O(\max(m_1,m_2))$ \\ \hline
\end{tabularx}
\end{small}

It is easy to see that $\Omega(\max(m_1, m_2))$ is a makespan lower bound in expectation. It can be shown that the makespan lower bound is close to $(m_1 + m_2)$ with high probability when there are $\Omega(m_1m_2)$ tiles \cite{guo2022sub15}.

%The \gstp has been previously studied in the context of automated garages \cite{guo2023efficient}, where they showed that 
%\begin{proposition}
%    \gstp on an $m_1 \times m_2$ grid has a $O(m_1 + m_2)$ makespan algorithm where there are $\Theta(m_1 m_2)$ escorts.
%    In addition, when there are $2m_1 + 2m_2 - 4$ escorts, there is a $O(m_1 m_2)$ makespan algorithm.
%    The first algorithm matches the high probability makespan lower bound $\Omega(m_1 + m_2)$ when there are $\Omega(m_1 m_2)$ tiles, whereas the second algorithm is not tight.
%\end{proposition}
%To prove this, they utilized Rubik Tables for their overall strategy and simulated permutations on a given row/column by padding it on both of the long sides with escorts to act as two highways moving in opposite directions.
%When there are $2m_1 + 2m_2 - 4$ escorts, the shuffle applied to the entire grid, and in the case of $\Theta(m_1 m_2)$ escorts, a constant number of instances could be simulated in parallel.

%The lower bounds came from previous work that showed that when there are $\Theta(m_1 m_2)$ tiles, the makespan of random \gstp instances is bounded below by $m_1 + m_2 - o(m_1 + m_2)$ with arbitrarily high probability as $m_1 + m_2 \to \infty$, which establishes the $\Omega(m_1 + m_2)$ lower bound.

\subsection{The Rubik Table Algorithm}\label{sec:rta}
A notable tool, Rubik tables \cite{szegedy2023rubik}, has been applied to derive polynomial-time, $1.x$-optimal solutions to classical MAPF problems on grids \cite{guo2022sub15}. This tool will also be employed in this work. We will use the following theorem with an associated algorithm. 

\begin{theorem}[Rubik Table Algorithm for 2D Grids \cite{szegedy2023rubik}] Let an $m_1\times m_2$ grid be filled with tiles labeled $1, \ldots, m_1m_2$. A row (resp., column) shuffle can arbitrarily permute a row (resp., column) of tiles. Then, the tiles can be rearranged from any configuration to the row-major configuration using $m_1$ row shuffles, followed by $m_2$ column shuffles, and then $m_1$ row shuffles. Alternatively, the tiles can be rearranged using $m_2$ column shuffles, followed by $m_1$ row shuffles, and then another $m_2$ column shuffles. 
\end{theorem}

Fig.~\ref{fig:rta} illustrates running the Rubik table algorithm over a $4\times 3$ grid, using a row-column-row shuffle sequence. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\columnwidth]{figs/rubik-43-w.pdf}
    \caption{Applying the Rubik table algorithm to rearrange tiles on a $4\times 3$ grid using a sequence of row shuffles, followed by column shuffles, followed by row shuffles.}
    \label{fig:rta}
\end{figure}
