% Shortened version for ACC
% Before shortening math proofs

\documentclass[letterpaper, 10pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
\overrideIEEEmargins

\usepackage{geometry}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{amsmath}

\usepackage{amssymb} 
\usepackage[noadjust]{cite}
\usepackage{bm}
\usepackage{subfigure}
\usepackage{acronym}
\usepackage{paralist}
\usepackage{float}
\usepackage{epstopdf}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{multicol} % For two-column equations
\usepackage{accents}
% \usepackage{breqn}
\newcommand{\subparagraph}{}
\usepackage{titlesec}

% This gets rid of some error in a package conflict between amsthm and some other package on the definition of the "proofs" environment.
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}

% Sets the geometry to IEEE specs
\geometry{left=54pt,right=54pt,top=54pt,bottom=54pt}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

% Use if your images are in an Overleaf subfolder
% \graphicspath{ {SemiCircPics/} }

% ***THIS FILE WILL NOT WORK WITHOUT THE COMMANDS IN THE FILE JUcmds!!!***
\include{JUcmds}

% \newtheorem{lemma}{Lemma}
\theoremstyle{plain}
\newtheorem{problem}{Problem}


\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}
\newcommand{\rmax}{r_{\max}}
\newcommand{\bsig}{\bm \sigma}

% Changes algorithm package ForAll to ForEach
\renewcommand{\algorithmicforall}{\textbf{for each}}

\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\footnotesize}
\makeatother

% Removes the obnoxious "do"s from the algorithmic environment. Remove to have the do's come back.
\renewcommand\algorithmicdo{}

% Scale command for figures
\def\figsc{1}

% Fix float separations
\setlength{\textfloatsep}{7pt}

% Squeeze section title spacing
\titlespacing\section{0pt}{11pt plus 4pt minus 2pt}{2pt plus 2pt minus 2pt}




\begin{document}

% \title{\LARGE \bf Resilient Formation Control with Input Bounds}
\title{\LARGE \bf Determining r-Robustness of Digraphs Using Mixed Integer Linear Programming}

% \title{\LARGE \bf Achieving Formations in the Presence of Adversaries for Resilient Directed Acyclic Graph}

\author{James Usevitch and Dimitra Panagou
\thanks{The authors are with the Department of Aerospace Engineering, University of Michigan, Ann Arbor; \texttt{usevitch@umich.edu}, \texttt{dpanagou@umich.edu}.}
\thanks{The authors would like to acknowledge the support of the Automotive Research Center (ARC) in accordance with Cooperative Agreement W56HZV-14-2-0001 U.S. Army TARDEC in Warren, MI, and the Award No W911NF-17-1-0526.}
}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\acrodef{wrt}[w.r.t.]{with respect to}
\acrodef{apf}[APF]{Artificial Potential Fields}
\begin{abstract}
Convergence guarantees of many resilient consensus algorithms are based on the graph theoretic properties of $r$- and $(r,s)$-robustness. These algorithms guarantee consensus of normally behaving agents in the presence of a bounded number of arbitrarily misbehaving agents if the values of the integers $r$ and $s$ are sufficiently high. However, determining the largest integer $r$ for which an arbitrary digraph is $r$-robust is highly nontrivial. This paper introduces a novel method for calculating this value using mixed integer linear programming. The method only requires knowledge of the graph Laplacian matrix, and can be formulated with affine objective and constraints, except for the integer constraint. Integer programming methods such as branch-and-bound can allow both lower and upper bounds on $r$ to be iteratively tightened. Simulations suggest the proposed method demonstrates greater efficiency than prior algorithms.

% Many resilient control algorithms have been developed which are based upon the graph theoretic properties of $r$- and $(r,s)$-robustness. These properties are often used to describe the ability of nominally behaving agents in a network to achieve agreement on variables of interest despite the misbehavior of a bounded number of adversarial agents. However, determining the largest integer $r$ for which an arbitrary digraph is $r$-robust is a nontrivial matter. This paper introduces a novel method for calculating this value of $r$ using zero-one integer programming. The method only requires knowledge of the graph Laplacian matrix, and can be formulated with affine objective and constraints, except for the integral constraint. Integer programming methods such as branch-and-bound can allow both lower and upper bounds on the largest $r$ to be iteratively tightened, whereas prior algorithms are only able to iteratively tighten the upper bound on $r$. Simulations are presented which suggest the proposed method demonstrates greater efficiency than previous algorithms.
\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}
\label{intro}

Consensus on shared information is fundamental to the operation of multi-agent systems. In context of mobile agents, it enables formation control, agent rendezvous, sensor fusion, and many more objectives. Although a vast literature of algorithms for consensus exist, many are unable to tolerate the presence of adversarial attacks or faults. 
Recent years have seen an increase of attention on \emph{resilient} algorithms that are able to operate despite such misbehavior. 
Many of these algorithms have been inspired by work such as \cite{Lamport1982}, which is one of the seminal papers on consensus in the presence of adversaries; \cite{leblanc2013resilient,Zhang2012robustness,LeBlanc_2013_Res_Continuous} which outline discrete- and continuous-time algorithms along with necessary and sufficient conditions for scalar consensus in the presence of Byzantine adversaries; and \cite{Vaidya2012iterative,Vaidya2013byzantine,Tseng2013iterative,Tseng2014asynchronous}, which outline algorithms for multi-agent vector consensus of asynchronous systems in the presence of Byzantine adversaries. Some of the most recent results that draw upon these works include resilient state estimation \cite{Mitra2018secure}, resilient rendezvous of mobile agents \cite{Park2017fault,park2016efficient}, resilient output synchronization \cite{leblanc2017resilient}, resilient simultaneous arrival of interceptors \cite{li2018robust}, resilient distributed optimization \cite{sundaram2018distributed,su2016fault}, reliable broadcast \cite{tseng2015broadcast,Zhang2012robustness}, and resilient multi-hop communication \cite{su2017reaching}.

% OLD Intro
% The study of multi-agent algorithms resistant to the malicious influence of adversarial actions is seeing a rapid increase of attention in the literature. The 
% %seminal work on agreement in the presence of Byzantine adversaries 
% authors of \cite{Lamport1982}, the authors of \cite{leblanc2013resilient,Zhang2012robustness,LeBlanc_2013_Res_Continuous}, and the authors of \cite{Vaidya2012iterative,Vaidya2013byzantine,Tseng2013iterative} have inspired a wide range of results dealing with resilient state estimation \cite{Mitra2018secure}, approximate vector agreement with asynchronous systems \cite{Tseng2014asynchronous}, resilient rendezvous of mobile agents \cite{Park2017fault,park2016efficient}, resilient output synchronization \cite{leblanc2017resilient}, resilient simultaneous arrival of interceptors \cite{li2018robust}, resilient distributed optimization \cite{sundaram2018distributed,su2016fault}, reliable broadcast \cite{tseng2015broadcast,Zhang2012robustness}, and resilient multi-hop communication \cite{su2017reaching}. Resilience in this context refers to the ability of normally behaving agents to accomplish specific objectives despite receiving corrupted or malicious information from adversarial communication neighbors. 
% The behavior of such adversarial agents is generally characterized as either Byzantine [REFERENCE] or malicious [REFERENCE].

Many of these results are based upon the graph theoretical properties known as $r$-robustness and $(r,s)$-robustness \cite{leblanc2013resilient,Zhang2012robustness}. These notions were defined after it was shown that traditional graph theoretic metrics (e.g. connectivity) were insufficient to analyze the convergence properties of certain resilient algorithms based on purely local information \cite{Zhang2012robustness}. The properties of $r$- and $(r,s)$-robustness 
% were first used to describe the conditions under which the W-MSR \cite{leblanc2013resilient} and ARC-P \cite{leblanc2013resilient} resilient algorithms will converge in the presence of a locally bounded adversary model. Since then, these conditions 
have been used in sufficient conditions for several resilient consensus algorithms including the ARC-P \cite{LeBlanc_2013_Res_Continuous}, W-MSR \cite{leblanc2013resilient}, SW-MSR \cite{saldana2017resilient}, and DP-MSR \cite{dibaji2017resilient} algorithms. Given an upper bound on the global or local number of adversaries in the network, these resilient algorithms guarantee convergence of normally behaving agents' states to a value within the convex hull of initial states if the integers $r$ and $s$ are sufficiently large.

A key challenge in implementing these resilient algorithms is that determining the $r$- and $(r,s)$-robustness of arbitrary digraphs is an NP-hard problem in general \cite{leblanc2013algorithms,zhang2015notion}. 
The first algorithmic analysis of determining the values of $r$ and $s$ for arbitrary digraphs was given in \cite{leblanc2013algorithms}. The algorithms in this work employ an exhaustive search to determine the maximum values of $r$ and $s$ for a given digraph, 
% Due to the combinatorial nature of the search, these algorithms 
and have exponential complexity w.r.t. the number of nodes in the network. 
% In \cite{zhang2015notion} it was explicitly shown that determining whether a graph is $r$-robust for a given integer $r$ is coNP-complete.
Subsequent work has focused on methods to circumvent this difficulty, including
% These include deriving 
graph construction methods which increase the graph size while preserving initial values of $r$ and $s$ \cite{leblanc2013resilient,Guerrero2016formations},
% or
demonstrating the behavior of $r$ as a function of particular graph properties 
% Probabilistic conditions on the value of $r$ for various random networks are studied in
\cite{zhang2015notion,shahrivar2017spectral,zhao2017connectivity},
% In \cite{shahrivar2015robustness} it is shown that for all undirected graphs the maximum value of $r$ can be lower bounded by the isoperimetric constant\footnote{Also called the Cheeger constant} and half the algebraic connectivity of the graph. Lemma 7 in \cite{leblanc2013resilient} demonstrates that for any digraph, the maximum value of $r$ is at least one if and only if the digraph contains a spanning tree.
lower bounding $r$ with the isoperimetric constant and algebraic connectivity of undirected graphs \cite{shahrivar2015robustness},
% Recent efforts have even used 
and even using
machine learning to correlate characteristics of
% Erd\H{o}s-R\'enyi random graphs 
certain graphs to the values of $r$ and $s$ \cite{wang2018using}. Finding more efficient ways of determining the \emph{exact} robustness of digraphs however is still an open problem.

In this paper, we introduce a novel method for determining the maximum value of $r$ for which an arbitrary digraph is $r$-robust by solving a mixed integer linear programming (MILP) problem. The problem only requires knowledge of the graph Laplacian matrix and can be formulated with affine objective and constraints, with the exception of the integer constraint.
% we prove that determining the maximum value of $r$ for which an arbitrary digraph is $r$-robust can be found by solving a zero-one integer linear optimization problem, with objective and all constraints affine except for the integral constraint. 
To the best of our knowledge, this is the first time the problem has been formulated in this way. This contribution provides several advantages. First, these results open the door for the extensive literature on integer programming to be applied to the $r$-robustness determination problem. In particular, applying branch-and-bound algorithms to the problem can allow for lower and upper bounds on a digraph's $r$-robustness to be iteratively tightened. Prior algorithms are only able to tighten the upper bound on the maximum robustness for a given digraph.
Second, this formulation enables commercially available solvers such as Gurobi or MATLAB's \emph{intlinprog} to be used to find the maximum robustness of any digraph. Finally, experimental results using this new formulation suggest a reduction in computation time as compared to the centralized algorithm proposed in \cite{leblanc2013algorithms}.

This paper is organized as follows: notation and relevant definitions are introduced in Section \ref{sec:notation}. The problem formulation is given in Section \ref{sec:problemformulation}. Our main result of formulating the $r$-robustness determination problem as a mixed integer linear programming problem is given in Section \ref{sec:rrobustdeterm}. Simulations are presented in Section \ref{sec:simulations}, and we present conclusions and directions for future work in Section \ref{sec:conclusion}.

\section{Notation}
\label{sec:notation}

The real numbers and integers are denoted $\R$ and $\Z$, respectively. The  nonnegative real numbers and integers are denoted $\R_+$ and $\Z_+$, respectively. $\R^n$ denotes an $n$-dimensional vector space over the field $\R$, $\Z^n$ represents an $n$ dimensional vector with nonnegative integer vectors, and $\{0,1\}^n$ represents a binary vector of length $n$. Scalars are denoted in normal text (e.g. $x \in \R$) while vectors are denoted in bold (e.g. $\bm x \in \R^n$).
% , with the $i$th entry of $\bm x$ denoted $\bm x_i$. 
The notation $x_i$ denotes the $i$th entry of vector $\bm x$. 
The inequality symbol $\gleq$ denotes a componentwise inequality between vectors; i.e. for $\bm x,\bm y \in \R^n$, $\bm x \gleq \bm y \implies x_i \leq  y_i\ \forall i \in \{1,\ldots,n\}$. An $n$-dimensional vector of ones is denoted $\bm 1_n$, and an $n$-dimensional vector of zeros is denoted $\bm 0_n$. In both cases the subscript $n$ will be omitted when the size of the vector is clear from the context. The union, intersection, and set complement operations are denoted by $\cup,\ \cap$, and $\setminus$, respectively. 
% A backslash is used to denote a set complement, e.g. $S \setminus \Omega$ denotes the objects in the set $S$ but not in the set $\Omega$. 
The cardinality of a set is denoted as $|S|$, and the empty set is denoted $\{ \emptyset \}$. The infinity norm on $\R^n$ is denoted $\nrm{\cdot}_\infty$. The notation $C(n,k) = n!/(k!(n-k)!)$ denotes the binomial coefficient with $n,k \in \Z_+$. Given a set $S$, the power set of $S$ is denoted $\Pc(S) = \{A : A \subseteq S \}$.

A directed graph (digraph) is denoted as $\D = (\V,\E)$, where $\V = \{1,\ldots,n\}$ is the set of indexed nodes and $\E$ is the edge set. 
A directed edge is denoted $(i,j)$, with $i,j \in \V$. The set of in-neighbors for an agent $j$ is denoted $\N_j = \{i \in \V : (i,j) \in \E \}$. The minimum in-degree of a digraph $\D$ is denoted $\delta^{in}(\D) = \min_{j \in \V} |\N_j|$.
In this paper we consider \emph{simple} digraphs of $n$ nodes, meaning digraphs without self loops $\big((i,i) \notin \E\ \forall i \in \V \big)$ and without redundant edges (i.e. at most one directed edge $(i,j) \in \E$ exists from $i$ to $j$).
Occasionally, $\G = (\V,\E)$ will be used to denote an undirected graph where $(i,j) \in \E \iff (j,i) \in \E$ $\forall i,j \in \V$.
The graph Laplacian $L$ for a digraph (or undirected graph) is defined as follows, with $L_{j,i}$ denoting the entry in the $j$th row and $i$th column:

% {\small 
%         \medmuskip=0mu
%         \thinmuskip=0mu
%         \thickmuskip=0mu
        % \nulldelimiterspace=-1pt
        % \scriptspace=0pt
\begin{equation}
\label{eq:Laplacian}
    L_{j,i} = \begin{cases}
        |\N_j| & \text{if } j = i \\
        -1 & \text{if } i \in \N_j \\
        0 & \text{if } i \notin \N_j
    \end{cases}
\end{equation}
% }
% Laplacian matrices are generally not symmetric for directed graphs, but always symmetric for undirected graphs.
% A partitioning of a set $S$ into subsets $S_1,\ldots,S_l$ is defined as...

\section{Problem Formulation}
\label{sec:problemformulation}

We begin with the definitions of $r$-reachability and $r$-robustness:

\begin{define}[\cite{leblanc2013resilient}]
Let $r \in \Z_+$ and $\D=(\V,\E)$ be a digraph. A nonempty subset $S \subset \V$ is $r$-reachable if $\exists i \in S$ such that $|\N_i \backslash S| \geq r$.
\end{define}

%  The definition of $r$-robustness is as follows:
% When analyzing the reachabilities of $S_1^k$ or $S_2^k$ to determine robustness, we are interested in the maximum integers $r_1$ and $r_2$ for which each respective set is reachable.
% The definition of $r$-robustness is also given in \cite{leblanc2013resilient}:

\begin{define}[\cite{leblanc2013resilient}]
\label{def:rrobust}
Let $r \in \Z_+$. A nonempty, nontrivial digraph $\D = (\V,\E)$ on $n$ nodes $(n \geq 2)$ is $r$-robust if for every pair of nonempty, disjoint subsets of $\V$, at least one of the subsets is $r$-reachable. By convention, the empty  graph $(n = 0)$ is 0-robust and the trivial graph $(n=1)$ is 1-robust.
\end{define}
If a set $S$ is $r$-reachable, it is $r'$-reachable for any $0 \leq r' \leq r$.
Similarly, if a graph is $r$-robust it is also $r'$-robust for any $0 \leq r' \leq r$. 
% From this fact it follows that it is most useful to know the maximum integer $r$ for which the graph is $r$-robust.
% In light of this, the maximal $r$-robustness problem is given as follows:

This paper addresses the following problem:
\begin{problem}
\label{prob:robust}
    Given an arbitrary digraph $\D$, determine the maximum integer $r$ for which $\D$ is $r$-robust.
\end{problem}

\begin{remark}
\label{rmk:rho}
    We denote the maximum integer $r$ for which a given digraph $\D$ is $r$-robust as $r_{\max}(\D) \in \Z_+$.
\end{remark}
% The solution to problem \ref{prob:robust} will be denoted as $r_{\max}(\D) \in \Z_{+}$, i.e. $r_{\max}(\D)$ is the maximum integer for which the graph $\D$ is $r$-robust.
It should be clear from Definition \ref{def:rrobust} that determining $\rmax(\D)$ involves checking the reachability of pairs of nonempty, disjoint subsets in a graph. Let the set $\mathcal{T} \subset \Pc(\V) \times \Pc(\V)$ be defined as 
%$\mathcal{T} =  \{ (S_1,S_2) \in \Pc(\V) \times \Pc(\V) \text{ such that } |S_1| > 0,\ |S_2| > 0,\ |S_1 \cap S_2| = 0 \}$.
\begin{align}
        \mathcal{T} =  \big\{ (S_1,S_2) \in \Pc(\V) \times \Pc(\V) : |S_1| > 0,\ |S_2| > 0,\ & \nonumber \\
        |S_1 \cap S_2| = 0 \big\}& \label{eq:Tdef}
\end{align}
The set $\mathcal{T}$ therefore contains all possible pairs of nonempty, disjoint subsets of $\V$. It was shown in \cite{leblanc2013algorithms} that $|\mathcal{T}| = \sum_{p=2}^n \pmxs{n \\ p} (2^{p} -2)$.\footnote{Since $(S_1,S_2) \in \mathcal{T} \implies (S_2,S_1) \in \mathcal{T}$, the total number of \emph{unique} nonempty, disjoint subsets is $(1/2)|\mathcal{T}|$, denoted as $R(n)$ in \cite{leblanc2013algorithms}.}
% In light of this fact, an exhaustive search of the possibilities is impractical for large values of $n$.
% In \cite{leblanc2013algorithms}, it was shown that the total number of such pairs is $R(n) = \sum_{p=2}^n \pmxs{n \\ p} (2^{p-1} -1)$.
% \begin{equation}
% \label{eq:worsttotalsets}
%     R(n) = \sum_{p=2}^n \pmx{n \\ p} (2^{p-1} -1).
% \end{equation}
% [DELETE THIS]
% In other words, there are $R(n)$ unique ways to choose 2 nonempty, disjoint subsets from the set of nodes $\V$. [DO WE NEED THIS PARAGRAPH?]


% The following notation is used to distinguish different choices of such subsets from each other: a triple $(S_1,S_2,S_0)$ represents one particular way of dividing $\V$ into the subsets $S_1,S_2,S_0 \subset \V$ with $|S_1| > 0$, $|S_2| > 0$, and $S_1 \cap S_2 = \{\emptyset \}$.\footnote{Equivalently, the notation in [VAIDYA'S WORK] can be used which considers subsets $L,R,C \subset \V$. $L$ and $R$ are analogous to sets $S_1$ and $S_2$, with $C$ being analogous to $S_0$.} $S_1$ and $S_2$ represent the two nonempty, disjoint subsets, and the (possibly empty) subset $S_0$ represents all nodes which are neither in $S_1$ nor $S_2$. Each possible triple for the given graph is indexed by the set $\mathcal{I} = \{1,\ldots,R(n) \}$, e.g. $(S_1^k,S_2^k,S_0^k)$ with $k \in \mathcal{I}$.\footnote{With this notation, given $k_1,k_2 \in \mathcal{I}$ with $k_1 \neq k_2$, then either $S_1^{k_1} \neq S_1^{k_2}$ or $S_2^{k_1} \neq S_2^{k_2}$ or $S_0^{k_1} \neq S_0^{k_2}$.} Examples are shown in figure [INSERT HERE].
% \subsection{The $r$-Robustness Determination Problem}



% \subsection{Denoting All Nonempty, Disjoint Subsets}

% In section \ref{sec:rrobustdeterm}, we will demonstrate that determining $r_{\max}(\D)$ can be found by solving the following zero-one integer programming problem:

% \begin{equation}
%         \begin{aligned}
%             & \underset{\bm \sigma_1,\bm \sigma_2}{\text{minimize}}
%             & & \nrm{\bmx{L & \bm 0 \\ \bm 0 & L} \bmx{\bm \sigma_1 \\ \bm \sigma_2} + (n-1) \bmx{\bm 1 \\ \bm 1}}_\infty - (n-1) \\
%             & \text{subject to}
%             & & \sigma_{1,i}, \sigma_{2,i} \in \{0,1\}, \; i = 1, \ldots, n \\
%             & & & \bm \sigma_1 + \bm \sigma_2 \gleq \bm 1\\
%             & & & \bm \sigma_1, \bm \sigma_2 \notin \text{span}(\bm 1),
%         \end{aligned}
% \end{equation}
% where $L$ is the matrix Laplacian of $\D$. In addition, it will be shown that this can be formulated as an optimization problem with affine (and therefore convex) objective and constraints, except for the integer constraint on $\bm \sigma_1$ and $\bm \sigma_2$. 

% In section \ref{sec:twosetprob}, we will consider the special situation where the value of $r_{\max}(\D)$ is determined by a case where $S_1 \cup S_2 = \V$, i.e. $|S_0| = 0$. Several counterexamples are presented to show that this scenario in general does not hold for arbitrary digraphs or undirected graphs. However, when it can be proven that this situation holds for a digraph (or undirected graph), we show that $r_{\max}(\D)$ can be determined by the less complex integer programming problem

% \begin{equation*}
%         \begin{aligned}
%             & \underset{\bm v}{\text{minimize}}
%             & & \nrm{L \bm v}_\infty \\
%             & \text{subject to}
%             & & v_i \in \{0,1\}, \; i = 1, \ldots, n \\
%             & & &\bm v \notin \text{span}(\bm 1)
%         \end{aligned}
% \end{equation*}
% which again can be formulated with affine objective and constraints, except for the integer constraint. In addition, it is proven that this situation holds for all graphs which are either $k$-circulant directed or undirected graphs.

\subsection{Alternate Formulation of Maximum $r$-Robustness}

In our first result, we derive an equivalent way of expressing the maximum robustness $r_{\max}(\D)$ of a digraph $\D$.
% NODE REACHABILITY
% By a slight abuse of notation, the reachability of a \emph{node} in a set is defined as follows:
% \begin{define}
%     Consider a node $i \in \V$ and a subset $S \subset \V$ with $ i \in S$. The reachability of $i$ in $S$ is defined as the number of in-neighbors of $i$ outside of $S$, or $|\N_i \backslash S|$.
% \end{define}
Given an arbitrary digraph $\D=(\V,\E)$ and a subset $S \subset V$, we define the reachability function $\Rc : \Pc(\V) \rarr \Z_+$ as follows:
\begin{align}
% \label{eq:reach}
\label{eq:reachmax}
    \Rc(S) &= \begin{cases}
    \max_{i \in S } |\N_i \backslash S | & \text{if } S \neq \{\emptyset\} \\
    0 & \text{if } S = \{\emptyset\}
    \end{cases}
    % &= \max_{i \in S } \eta_m^k(i)
\end{align}
In other words, $\Rc(S)$ returns the maximum integer $r$ for which the set $S$ is $r$-reachable. 
% For completeness, we define $\Rc(\{\emptyset\}) = 0$ and $\Rc(\V) = 0$.
The following Lemma presents an explicit formulation which yields $r_{\max}(\D)$:

\begin{lemma}
\label{lem:rrobalt}
    Let $\D = (\V,\E)$ be an arbitrary nonempty, nontrivial, simple digraph with $|\V| = n$. The following holds:
    \begin{equation}
    \label{eq:rrobalt}
        \begin{aligned}
            r_{\max}(\D) =& \underset{S_1,S_2 \in \Pc(\V)}{\text{minimize}}
            & & \max\pth{\Rc(S_1) , \Rc(S_2)} \\
            & \text{subject to}
            & & |S_1| > 0,\ |S_2| > 0,\ |S_1 \cap S_2| = 0 \\
            % & & & |S_2| > 0 \\
            % & & & |S_1 \cap S_2| = 0
        \end{aligned}
    \end{equation}
\end{lemma}

\begin{proof}
    For brevity, define the function
    \begin{equation*}
        g(S_1,S_2) = \max\pth{\Rc(S_1) , \Rc(S_2)},\ g: \Pc(\V) \times \Pc(\V) \rarr \Z_+
    \end{equation*}
    % Note $g: \Pc(\V) \times \Pc(\V) \rarr \Z_+$. 
    % We must first show $\forall (S_1,S_2)\in \mathcal{T}$, either $\Rc(S_1) \geq r_{\max}(\D)$ or $\Rc(S_2) \geq r_{\max}(\D)$. 
    Note that $g(S_1,S_2) = m \implies \Rc(S_1) = m$ or $\Rc(S_2) = m$. Let $(S_1^*, S_2^*)$ be a minimizer of the right hand side (RHS) of \eqref{eq:rrobalt}. Then $g(S_1^*,S_2^*) \leq g(S_1,S_2)\ \forall (S_1,S_2) \in \Tc$. Therefore $\forall (S_1,S_2) \in \Tc,$ either $\Rc(S_1) \geq g(S_1^*,S_2^*)$ or $\Rc(S_2) \geq g(S_1^*,S_2^*)$. Therefore the graph is $g(S_1^*,S_2^*)$-robust, implying $r_{\max}(\D) \geq g(S_1^*,S_2^*)$.
    
    To show $r_{\max}(\D) = g(S_1^*,S_2^*)$, we prove by contradiction. By definition, $\D$ is $r_{\max}(\D)$-robust (Remark \ref{rmk:rho}). Suppose $r_{\max}(\D) > g(S_1^*,S_2^*)$. This implies $\Rc(S_1^*) < r_{\max}(\D)$ and $\Rc(S_2^*) < r_{\max}(\D)$. Since $\exists (S_1^*,S_2^*) \in \Tc$ such that $\Rc(S_1^*) < r_{\max}(\D)$ and $\Rc(S_2^*) < r_{\max}(\D)$, this implies $\D$ is not $r_{\max}(\D)$-robust. This contradicts the fact that $\D$ is $r_{\max}(\D)$-robust by definition. Therefore, $r_{\max}(\D) = g(S_1^*,S_2^*)$.
\end{proof}

\begin{remark}
    \label{rmk:implicit}
    Using the definition of $\mathcal{T}$ in \eqref{eq:Tdef}, the constraints on the RHS of \eqref{eq:rrobalt} can be made implicit \cite[section 4.1.3]{boyd2004convex} as follows:
    \begin{equation}
    % \label{eq:rrobalt}
        \begin{aligned}
            r_{\max}(\D) =& \underset{(S_1,S_2) \in \mathcal{T}}{\text{minimize}}
            & & \max\pth{\Rc(S_1) , \Rc(S_2)} 
        \end{aligned}
    \end{equation}
\end{remark}

% The constraints on the right hand side of equation \eqref{eq:rrobalt} constrain the feasible set to subsets which are compatible with the definition of $r$-robustness.

\section{$r$-Robustness Determination as an MILP}
\label{sec:rrobustdeterm}

% \subsection{Determining the Maximum Reachability}

The next step in the analysis is to demonstrate how the expression $\max\pth{\Rc(S_1) , \Rc(S_2)}$
%\begin{align*}
%\max\pth{\Rc(S_1) , \Rc(S_2)},
%\end{align*}
can be calculated as a function of the graph Laplacian matrix.
Recall that $n = |\V|$, and define the indicator vector $\bm \sigma(\cdot) : \Pc(\V) \rarr \{0,1\}^{n}$ as follows: for any $S \in \Pc(\V)$,
\begin{align}
\label{eq:sigmadef}
    \bm \sigma_j(S) &= \begin{cases}
        1 & \text{if } j \in S \\
        0 & \text{if } j \notin S
    \end{cases},\ j = \{1,\ldots,n \}
\end{align}


% Let $\bm \sigma_1^k$ be a vector such that the $j$th entry $ \sigma_j^1^k$ is 1 if $j \in S_1^k$ and 0 otherwise, i.e.
% \begin{align}
%      \sigma_j^1^k = \begin{cases}
%         1 & \text{if } j \in S_1^k \\
%         0 & \text{if } j \notin S_1^k.
%     \end{cases} \label{eq:sig1}
% \end{align}
In other words the $j$th entry of $\bm \sigma(S)$ is 1 if the node with index $j$ is a member of the set $S \in \Pc(\V)$, and zero otherwise. It is straightforward to verify that $\bm \sigma(\cdot)$ is a bijection. Therefore given $\bm x \in \{0,1\}^n$, the set $\bm \sigma^{-1}(\bm x) \in \Pc(\V)$ is defined by $\bm x_j = 1 \implies j \in \bm \sigma^{-1}(\bm x)$ and $\bm x_j = 0 \implies j \notin \bm \sigma^{-1}(\bm x)$.
% The notation $\bm \sigma(S_1) = \bm \sigma^1$ or $\bm \sigma(S_2) = \bm \sigma^2$ is sometimes used to reflect the sets $S_1$ and $S_2$. 
% The following Lemma will demonstrate that the Laplacian matrix $L$ of $\D$ and the function $\bm \sigma(\cdot)$ can be used to obtain reachabilities of nodes $j \in S$. 

\begin{lemma}
\label{lem:Ljsig}
    Let $\D= (\V,\E)$ be an arbitrary nonempty, nontrivial, simple digraph, let $L$ be the Laplacian matrix of $\D$, and let $S \in \Pc(\V)$. Then the following holds for all $j \in \{1,\ldots,n\}$:
    \begin{align}
    	\label{eq:Avicii}
        L_j \bm \sigma(S) &= \begin{cases}
            |\N_j \backslash S|, & \text{if } j \in S, \\
            -|\N_j \cap S|, & \text{if } j \notin S,
        \end{cases}
    \end{align}
    where $L_j$ is the $j$th row of $L$. Furthermore,
    \begin{align}
    	\label{eq:Coldplay}
    	\Rc(S) = \max_j L_j \bm \sigma(S),\ j \in \{1,\ldots,n\}.
    \end{align}
\end{lemma}
%\vspace{-2.5em}
\begin{proof}
The term $\bm \sigma(S)$ is shortened to $\bm \sigma$ for brevity. Recall that the entry in the $j$th row and $i$th column of $L$ is denoted $L_{j,i}$. The definition of $L$ from \eqref{eq:Laplacian} implies
    \begin{align}
    	L_j \bm \sigma &= (L_{j,j}) \sigma_j + \sum_{q \in \{1,\ldots,n\} \backslash j } (L_{j,q}) \sigma_q  \nonumber \\
         &= |\N_j| \sigma_j   - \sum_{q \in \N_j \cap S } \sigma_q  - \sum_{q \in \N_j \backslash S } \sigma_q. \label{eq:superman}
    \end{align}
Since by \eqref{eq:sigmadef}, $q \in S$ implies $\sigma_q = 1$, the term $\sum_{q \in \N_j \cap S } \sigma_q = |\N_j \cap S|$. In addition, since $q \notin S$ implies $\sigma_q = 0$, the term $\sum_{q \in \N_j \backslash S } \sigma_q = 0$. By this, equation \eqref{eq:superman} simplifies to $L_j \bm  \sigma  = |\N_j| \sigma_j   - |\N_j \cap S |$.

The value of the term $|\N_j| \sigma_j$ depends on whether $j \in S$ or $j \notin S$. If $j \in S$, then $\sigma_j = 1$, implying $ L_j \bm  \sigma  = |\N_j| - |\N_j \cap S | = \pth{|\N_j \cap S | + |\N_j \backslash S |} -  |\N_j \cap S | = |\N_j \backslash S |$.
%\begin{align*}
%    L_j \bm  \sigma  &= |\N_j| - |\N_j \cap S | = \pth{|\N_j \cap S | + |\N_j \backslash S |} -  |\N_j \cap S | \\
%    &= |\N_j \backslash S |.
%\end{align*}
If $j \notin S $, then $\sigma_j = 0$ implying $L_j \bm  \sigma  = -|\N_j \cap S |$. This proves the result for equation \eqref{eq:Avicii}.

To prove \eqref{eq:Coldplay}, we first consider nonempty sets $S \in \Pc(\V) \backslash \{\emptyset\}$. By the results above and \eqref{eq:reachmax}, the maximum reachability of any $S \in \Pc(\V) \backslash \{ \emptyset \}$ is found by
\begin{equation}
    \Rc(S) = \max_{j \in  S} |\N_j \backslash S| = \max_{j \in S} (L_j \bm \sigma(S)). \label{eq:juicyfruit}
\end{equation}
By its definition, $\Rc(S) \geq 0$. Observe that
if $j \in S$ then $L_j \bm \sigma(S) = |\N_j \backslash S| \geq 0$, implying $\max_{j \in S} L_j \bm \sigma(S) \geq 0$.
Conversely,
if an agent $j$ is \emph{not} in the set $S$, then the function $L_j \bm \sigma(S)$ takes the nonpositive value $-|\N_j \cap S|$. This implies $\max_{j \notin S} L_j \bm \sigma(S) \leq 0$.
By these arguments, we therefore have $\max_{j \notin S} L_j \bm \sigma(S) \leq 0 \leq \max_{j \in S} L_j \bm \sigma(S)$, which implies
%$\max_{j \in \{1,\ldots,n \}} L_j \bm \sigma(S) = \max\pth{(\max_{j \in S} L_j \bm \sigma(S)), (\max_{j \notin S} L_j \bm \sigma (S))} = \max_{j \in S} L_j \bm \sigma(S)$.
\begin{align}
	\max_{j \in \{1,\ldots,n \}} L_j \bm \sigma(S) &= \max\pth{(\max_{j \in S} L_j \bm \sigma(S)), (\max_{j \notin S} L_j \bm \sigma (S))} \nonumber \\
	&= \max_{j \in S} L_j \bm \sigma(S). \label{eq:gingerale}
\end{align}
%This implies that $\max_{j \in \{1,\ldots,n \}} (L_j \bm \sigma(S)) = \max_{j \in S} (L_j \bm \sigma(S))$, and
Therefore by equations \eqref{eq:gingerale} and \eqref{eq:juicyfruit}, the maximum reachability of $S$ is found by the expression
% $\Rc(S) = \max_j (L_j \bm \sigma(S)) = \max_{j \in S} (L_j \bm \sigma(S))$
\begin{equation}
    \label{eq:reachS}
    \Rc(S) = \max_j (L_j \bm \sigma(S)),\ j \in \{1,\ldots,n\}.
\end{equation}
Lastly, if $S = \emptyset$, then by \eqref{eq:reachmax} we have $\Rc(S) = 0$. In addition, $\bm \sigma(S) = \bm 0$, implying that $\max_j L_j \bm \sigma(S) = 0 = \Rc(S),\ j \in \{1,\ldots,n\}$.    
\end{proof}

Lemma \ref{lem:Ljsig} can be used to rewrite the objective function of \eqref{eq:rrobalt} in terms of the Laplacian matrix of $\D$:

\begin{lemma}
\label{lem:maxequal}
Let  $\D = (\V,\E)$ be an arbitrary nonempty, nontrivial, simple digraph. Let $L$ be the Laplacian matrix of $\D$, and let $L_j$ be the $j$th row of $L$. Let $\Tc$ be defined as in \eqref{eq:Tdef}. Then for all $(S_1,S_2) \in \Tc$ the following holds:
\begin{align}
    &\max \pth{\Rc(S_1),\Rc(S_2)} = \nonumber \\
     &\max \pth{ \max_i \pth{L_i \bm \sigma(S_1)}, \max_j \pth{L_j \bm \sigma(S_2)} } \\
     &\hspace{.5em} i,j \in \{1,\ldots,n\}. \nonumber
\end{align}
\end{lemma}

%\vspace{-2em}

\begin{proof}
By Lemma \ref{lem:Ljsig}, $\Rc(S_1) = \max_i L_i \bm \sigma(S_1)$ for $i \in \{1,\ldots,n\}$, and $\Rc(S_2) = \max_j L_j \bm \sigma(S_2)$ for $j \in \{1,\ldots,n\}$. The result follows.    
\end{proof}
\vspace{-.5em}
From Lemma \ref{lem:rrobalt}, Lemma \ref{lem:maxequal}, and Remark \ref{rmk:implicit},
we can immediately conclude that $\rmax(\D)$ satisfies
\begin{align}
    \label{eq:rrobalt5000}
            &\rmax(\D) = \nonumber \\
            &\underset{(S_1,S_2) \in \Tc}{\min}
             \max \big(\max_i \pth{L_i \bm \sigma(S_1)}, \max_j \pth{L_j \bm \sigma(S_2)} \big).
\end{align}
Note that the terms $\bm \sigma(S_1)$ and $\bm \sigma(S_2)$ are each $n$-dimensional binary vectors. Letting $\bm b^1 = \bm \sigma(S_1)$ and $\bm b^2 = \bm \sigma(S_2)$, the objective function of \eqref{eq:rrobalt5000} can be written as $\max \big(\max_i \pth{L_i \bm b^1}, \max_j \pth{L_j \bm b^2} \big)$. Every pair $(S_1,S_2) \in \Tc$ can be mapped into a pair of binary vectors $(\bm b^1, \bm b^2)$ by the function $\Sigma : \Tc \rarr \{0,1\}^n \times \{0,1\}^n$, where $\Sigma(S_1,S_2) = (\bm \sigma(S_1), \bm \sigma(S_2)) = (\bm b^1, \bm b^2)$.
By determining the image of $\Tc$ under $\Sigma(\cdot,\cdot)$, the optimal value of \eqref{eq:rrobalt5000} can be found by minimizing over pairs of binary vectors $(\bm b_1, \bm b_2) \in \Sigma(\Tc)$ directly. Using binary vector variables instead of set variables $(S_1,S_2)$ will allow \eqref{eq:rrobalt5000} to be written directly in a MILP form.
%The set $\Tc$ is finite, implying that e
%
%Given a set of elements $\{(\bm b^1, \bm b^2) \in \{0,1\}^n \times \{0,1\}^n : \exists (S_1, S_2) \in \Tc \text{ s.t. } \bm b^1 = \bm \sigma(S_1), \bm b^2 = \bm \sigma(S_2) \}$
%
%This formulation still uses elements of $\Tc$ as the optimization variables. Changing the optimization variables to an appropriate set of binary vectors will allow $\rmax(\D)$ to be determined with an MILP formulated. This can be done as follows:
%denote the objective function of \eqref{eq:rrobalt5000} as $f(\bm \sigma(S_1),\bm \sigma(S_2)) = \max \pth{ \max_i \pth{L_i \bm \sigma(S_1)}, \max_j \pth{L_j \bm \sigma(S_2)} }$.
%%Observe that the objective of \eqref{eq:rrobalt5000} is a function of $\bm \sigma(S_1)$ and $\bm \sigma(S_2)$, and
%Consider a mapping $\Sigma : \Tc \rarr \{0,1\}^n \times \{0,1\}^n$ defined by $\Sigma(S_1,S_2) = (\bm \sigma(S_1),\bm \sigma(S_2))$. Then $f(\bm \sigma(S_1),\bm \sigma(S_2)) = f \circ \Sigma (S_1,S_2)$. Determining the elements $(\bm b^1, \bm b^2) \in \Sigma(\Tc) \subset \{0,1\}^n \times \{0,1\}^n$ will allow us to optimize over these elements directly rather than $(S_1,S_2)$. Note that for any $(\bm b^1, \bm b^2) \in \Sigma(\Tc)$, there exists an $(S_1,S_2) \in \Tc$ such that $\bm b^1 = \bsig(S_1)$ and $\bm b^2 = \bsig(S_2)$.
Towards this end, the following Lemma defines the set $\Sigma(\Tc)$:

\begin{lemma}
\label{lem:bijec}
    Let $\D = (\V,\E)$ be an arbitrary nonempty, nontrivial, simple digraph, and let $\Tc$ be defined as in \eqref{eq:Tdef}.
    Define the function $\Sigma: \mathcal{T} \rarr \{0,1\}^n \times \{0,1\}^n$ as
    \begin{equation}
    \label{eq:Sigma}
        \Sigma(S_1,S_2) = (\bm \sigma(S_1),\bm \sigma(S_2)),\ (S_1,S_2) \in \Tc.
    \end{equation}
    Define the set $\Bc \subset \{0,1\}^n \times \{0,1\}^n$ as
    \begin{align}
        \mathcal{B} = \bigg\{&  (\bm b^1, \bm b^2) \in \{0,1 \}^n \times \{0,1 \}^n : 1 \leq \bm 1^T \bm b^1 \leq (n-1), \nonumber \\
         &1 \leq \bm 1^T \bm b^2 \leq (n-1),\
         \bm b^1 + \bm b^2 \gleq \bm 1 \bigg\}. \label{eq:Bset}
    \end{align}
    Then both of the following statements hold:
    \begin{enumerate}
    \item The image of $\Tc$ under $\Sigma$ is equal to $\Bc$, i.e. $\Sigma(\Tc) = \Bc$
    \item The mapping $\Sigma : \Tc \rarr \Bc$ is a bijection.
    \end{enumerate}
%    both of the following statements hold:
%    \begin{enumerate}
%    	\item $\Sigma : \Tc \rarr \Bc$ is surjective.
%    	\item $\Sigma : \Tc \rarr \Bc$ is injective.
%    \end{enumerate}
%    This implies that the mapping $\Sigma : \Tc \rarr \Bc$ is a bijection.
\end{lemma}

%\vspace{-2em}

\begin{proof}
We prove \emph{1)} by showing first that $\Sigma(\Tc) \subseteq \Bc$, and then $\Bc \subseteq \Sigma(\Tc)$. Any $(S_1,S_2) \in \Tc$ satisfies $|S_1| > 0$, $|S_2| > 0$, $|S_1 \cap S_2| = 0$ as per \eqref{eq:Tdef}. Observe that
\begin{align*}
	|S_1| > 0 &\implies \bm 1^T \bsig(S_1) \geq 1, \\
	|S_2| > 0 &\implies \bm 1^T \bsig(S_2) \geq 1.
\end{align*}
Because $S_1,S_2 \subset \V$ and $|S_1 \cap S_2| = 0$, then $|S_1| < n$. Otherwise if $|S_1| = n$ then either $|S_2| = 0$ or $|S_1 \cap S_2| \neq 0$, which both contradict the definition of $\Tc$. Therefore $|S_1| < n$, and by similar arguments $|S_2| < n$. Observe that
\begin{align*}
	|S_1| < n &\implies \bm 1^T \bsig(S_1) \leq n- 1, \\
	|S_2| < n &\implies \bm 1^T \bsig(S_2) \leq n-1.
\end{align*}
Finally, $|S_1 \cap S_2| = 0$ implies that $j \in S_1 \implies j \notin S_2$ and $j \in S_2 \implies j \notin S_1$ $\forall j \in \{1,\ldots,n\}$. Therefore $\sigma_j(S_1) = 1 \implies \sigma_j(S_2) = 0$ and $\sigma_j(S_2) = 1 \implies \sigma_j(S_1) = 0$.
%This implies $\bm \sigma(S_1) + \bm \sigma(S_2) \gleq \bm 1$.
This implies that
\begin{align*}
	|S_1 \cap S_2| = 0 \implies \bm \sigma(S_1) + \bm \sigma(S_2) \gleq \bm 1.
\end{align*}
Therefore for all $(S_1,S_2) \in \Tc$,
%$(\bsig(S_1), \bsig(S_2))$
$(\bm \sigma(S_1), \bm \sigma(S_2)) = $ $\Sigma(S_1,S_2)$ satisfies the constraints of the set on the RHS of \eqref{eq:Bset}. This implies that $\Sigma(\Tc) \subseteq \Bc$.

Next, we show $\Bc \subseteq \Sigma(\Tc)$ by showing that for all $(\bm b^1, \bm b^2) \in \Bc$,
%that satisfies the constraints of the RHS of \eqref{eq:Bset}, 
there exists an $(S_1,S_2) \in \Tc$ such that $(\bm b^1, \bm b^2) = \Sigma(S_1,S_2)$. Choose any $(\bm b^1, \bm b^2) \in \Bc$ and define sets $(S_1,S_2)$ as follows
for $j \in \{1,\ldots,n\}$:
%$b^1_j = 1 \implies j \in S_1$, $\bm b^1 = 0 \implies j \notin S_1$, $b^2_j = 1 \implies j \in S_2$, and $\bm b^2$
\begin{align}
	b^1_j = 1 &\implies j \in S_1, &b^2_j = 1 &\implies j \in S_2, \nonumber \\
	b^1_j = 0 &\implies j \notin S_1, &b^2_j = 0 &\implies j \notin S_2. \label{eq:Medusa}
\end{align}
For the considered sets $(S_1,S_2)$, $1 \leq \bm 1^T \bm b^1$ implies $ |S_1| > 0$ and $1 \leq \bm 1^T \bm b^2$ implies $ |S_2| > 0$. In addition since $\bm b^1 + \bm b^2 \gleq \bm 1$, we have $b^1_j = 1 \implies b^2_j = 0$ and $b^2_j = 1 \implies b^1_j = 0$.
By our choice of $S_1$ and $S_2$, we have $b_j^1 = 1 \implies j \in S_1$, and from previous arguments $b_j^1 = 1 \implies b_j^2 = 0 \implies j \notin S_2$. Similar reasoning can be used to show that $b_j^2 = 1 \implies j \notin S_1$. 
These arguments imply that $|S_1 \cap S_2| = 0$. 
Consequently, $(S_1,S_2)$ satisfies all the constraints of $\Tc$ and is therefore an element of $\Tc$. Clearly, by \eqref{eq:Medusa} we have $\Sigma(S_1,S_2) = (\bm b^1,\bm b^2)$, which shows that there exists an $(S_1,S_2) \in \Tc$ such that $(\bm b^1, \bm b^2) = \Sigma(S_1,S_2)$. Since this holds for all $(\bm b^1, \bm b^2) \in \Bc$, this implies $\Bc \subseteq \Sigma(\Tc)$. Therefore $\Sigma(\Tc) = \Bc$.

We now prove \emph{2)}. Since $\Sigma(\Tc) = \Bc$, the function $\Sigma : \Tc \rarr \Bc$ is surjective.
% by showing that $\Sigma(S_1,S_2)$ is both surjective and injective. By our previous arguments, for any $(\bm b^1, \bm b^2) \in \Bc$ there exists an $(S_1,S_2) \in \Tc$ such that $\Sigma(S_1,S_2) = (\bsig(S_1),\bsig(S_2)) = (\bm b^1, \bm b^2)$. Therefore $\Sigma$ is surjective.
To show that it is injective, consider any $\Sigma(S_1,S_2) \in \Bc$ and $\Sigma(\bar{S}_1, \bar{S}_2) \in \Bc$ such that $\Sigma(S_1,S_2) = \Sigma(\bar{S}_1, \bar{S}_2)$. This implies $(\bsig(S_1),\bsig(S_2)) = (\bsig(\bar{S}_1), \bsig(\bar{S}_2))$. Note that $(\bsig(S_1),\bsig(S_2)) = (\bsig(\bar{S}_1), \bsig(\bar{S}_2))$ if and only if $\bsig(S_1) = \bsig(\bar{S}_1)$ and $\bsig(S_2) = \bsig(\bar{S}_2)$. Since the indicator function $\bm \sigma : \Pc(\V) \rarr \{0,1\}^n$ is itself injective, this implies $S_1 = \bar{S}_1$ and $S_2 = \bar{S}_2$, which implies $(S_1,S_2) = (\bar{S}_1,\bar{S}_2)$. Therefore $\Sigma : \Tc \rarr \Bc$ is injective.    
\end{proof}

Using Lemma 4 allows us to present the following mixed integer linear program which solves for $\rmax(\D)$:

\begin{theorem}
\label{thm:rrobust}
    Let $\D= (\V,\E)$ be an arbitrary nonempty, nontrivial, simple digraph and let $L$ be the Laplacian matrix of $\D$. The maximum $r$-robustness of $\D$, denoted $\rmax(\D)$, is obtained by solving the following minimization problem:
    \begin{align}
            \rmax(\D) =& \hspace{.5em} \underset{\bm b^1,\bm b^2}{\min}
            & & \max \pth{ \max_i \pth{L_i \bm b^1}, \max_j \pth{L_j \bm b^2} } \nonumber \\
            & \hspace{-.5em} \text{\textup{subject to}}
            & & \bm b^1 + \bm b^2 \gleq \bm 1 \nonumber \\
            & & & 1 \leq \bm 1^T \bm b^1 \leq (n-1) \nonumber \\
            & & & 1 \leq \bm 1^T \bm b^2 \leq (n-1) \label{eq:finalprobS0} \nonumber \\
            & & & \bm b^1, \bm b^2 \in \{0,1\}^n.
    \end{align}
\end{theorem}

%\vspace{-3em}

\begin{proof}
From Lemmas \ref{lem:rrobalt} and \ref{lem:maxequal}  we have
\begin{align}
            \rmax(\D) = \nonumber \\
             \underset{S_1,S_2 \in \Pc(\V)}{\min}
            & & \max \pth{ \max_i \pth{L_i \bm \sigma(S_1)}, \max_j \pth{L_j \bm \sigma(S_2)} } \nonumber \\
             \text{subject to}
            & & |S_1| > 0,\ |S_2| > 0,\ |S_1 \cap S_2| = 0, \nonumber
    \end{align}
for $i,j \in \{1,\ldots,n\}$. As per Remark \ref{rmk:implicit}, the definition of $\mathcal{T}$ can be used to make the constraints implicit:
\begin{align}
        \label{eq:rrobT}
            &\rmax(\D) = \nonumber \\
            &\underset{(S_1,S_2) \in \mathcal{T}}{\min}
             \max \pth{ \max_i \pth{L_i \bm \sigma(S_1)}, \max_j \pth{L_j \bm \sigma(S_2)} },           
\end{align}
for $i,j \in \{1,\ldots,n\}$. Since $\Sigma: \mathcal{T} \rarr \Bc$ is a bijection by Lemma \ref{lem:bijec}, \eqref{eq:rrobT} is equivalent to
\begin{align}
    \label{eq:implicitB}
            \rmax(\D) =& \underset{(\bm b^1, \bm b^2) \in \Bc}{\min}
            & & \max \pth{ \max_i \pth{L_i \bm b^1}, \max_j \pth{L_j \bm b^2} } \nonumber \\
            & & & i,j \in \{1,\ldots,n\}.
\end{align}
Making the constraints of \eqref{eq:implicitB} explicit yields \eqref{eq:finalprobS0}.    
\end{proof}


This minimization problem can actually be reformulated to an mixed integer linear programming problem where the objective and all constraint functions are affine except for the integer constraint. This is shown in the following corollary:

\begin{cor}
\label{cor:equivgen}
Let $\D = (\V,\E)$ be an arbitrary nonempty, nontrivial, simple digraph, and let $L$ be the Laplacian matrix of $\D$. The maximum $r$-robustness of $\D$, denoted $\rmax(\D)$, is obtained by solving the following mixed integer linear program:
\begin{align}
            \rmax(\D)=
            \hspace{.5em} \underset{t, \bm b}{\min \hspace{.5em}}
            &\ t \nonumber\\
             \hspace{.5em} \text{\textup{subject to \hspace{.5em}}}
             & t \in \R,\ \bm b \in \Z^{2n} \nonumber \\
             &0 \leq t \nonumber\\
             &\bmx{L & \bm 0 \\ \bm 0 & L} \bm b \gleq t \bmx{\bm 1 \\ \bm 1} \nonumber\\
              &\bm 0 \gleq \bm b \gleq \bm 1 \nonumber\\
              &\bmx{I_{n\times x} & I_{n \times n}}\bm b \gleq \bm 1 \nonumber\\
              &1 \leq  \bmx{\bm 1^T & \bm 0} \bm b \leq n-1 \nonumber\\
              &1 \leq \bmx{\bm 0 & \bm 1^T} \bm b \leq n-1 \label{eq:probaffine}
%              & t \in \R \nonumber\\
%              &\bm b \in \Z^{2n}. 
\end{align}
\end{cor}

%\setcounter{equation}{\the\numexpr\value{equation}+1\relax}

\begin{proof}
    The variables $\bm b^1$ and $\bm b^2$ from \eqref{eq:finalprobS0} are combined into the variable $\bm b \in \Z^{2n}$ in \eqref{eq:probaffine}; i.e. $\bm b =\bmxs{(\bm b^1)^T & (\bm b^2)^T}^T $. The first and fourth constraints of \eqref{eq:probaffine} restrict $\bm b \in \{0,1 \}^{2n}$. Next, it can be demonstrated \cite[Chapter 4]{boyd2004convex} that the formulation ${\min_{\bm x}} \max_i (x_i)$ is equivalent to
    \begin{equation*}
        \begin{aligned}
        & \underset{t, \bm x}{\min}
        & & t \\
        & \text{subject to}
        & &0 \leq t,\ \bm x \gleq t \bm 1. \\
        \end{aligned}
    \end{equation*}
    Reformulating the objective of the RHS of \eqref{eq:finalprobS0} in this way yields the objective, and second and third constraints of \eqref{eq:probaffine}:
    \begin{equation}
        \begin{aligned}
            & \underset{t, \bm b}{\min}
            & & t \\
            & \text{subject to}
            &  &0 \leq t \\
            & & &\bmx{L & \bm 0 \\ \bm 0 & L} \bm b \gleq t \bmx{\bm 1 \\ \bm 1}. \\
        \end{aligned}
    \end{equation}
    The fifth, sixth, and seventh constraints of \eqref{eq:probaffine} restrict $(\bm b^1, \bm b^2) \in \Bc$ and are simply a reformulation of the first three constraints in \eqref{eq:finalprobS0}.
\end{proof}

%
%%
%%% FLAG 
%%
%

% \begin{remark}
%     The constraint $\bm \sigma \in \Z^{2n}$ makes the minimization problem nonconvex, despite the objective function and all other constraints being affine.
% \end{remark}

% \begin{remark}
%     If an upper bound and a tighter lower bound than 0 are available for the graph's robustness, then the bounds on $t$ can be adjusted to be $\alpha \leq t \leq \beta$, where $\alpha,\beta > 0$ are the known lower and upper bounds on the graph robustness, respectively.
% \end{remark}

% \begin{remark}
%         Since the value of $r$ is always an integer, the variable $t$ can also be restricted to be an integer. This is not required however, since the entries of the Laplacian matrix and the entries of $\bm b$ are all integers.
% \end{remark}

\subsection{Discussion}

% \subsection{Complexity Analysis}

% [Compare complexity of our approach with that of LeBlanc et al.]

Since $r$-robustness is equivalent to $(r,1)$-robustness,\footnote{See section VII-B of \cite{leblanc2013resilient}.} the solution to the optimization problem in Theorem \ref{thm:rrobust} determines the maximum $r$ for which the graph is $(r,1)$-robust. As per \cite{leblanc2013resilient,leblanc2013algorithms}, in general the parameter $r$ has higher precedence than $s$ when ordering a set of graphs by robustness. In addition, $(r'+s'-1)$-robustness implies $(r',s')$-robustness \cite{leblanc2012thesis},\footnote{E.g. $(2F+1)$-robustness for $F \in \Z_+$ implies $(F+1,F+1)$-robustness.} and so a certain degree of $(r,s)$-robustness can be inferred from knowing the maximum value of $r$.

When comparing the optimization problem in Theorem \ref{thm:rrobust} with the algorithms in \cite{leblanc2013algorithms}, it is important to note that those in \cite{leblanc2013algorithms} determine both of the parameters $r$ and $s$ for which graphs are $(r,s)$-robust. Since the method in Theorem \ref{thm:rrobust} only determines the largest $r$ for which a digraph is $(r,1)$-robust (with $s$ fixed at 1), it cannot be directly compared to Algorithm 3.2, $DetermineRobustness(\A(\D))$ in \cite{leblanc2013algorithms}. 
% This is because $DetermineRobustness$ determines the maximum value of both $r$ and $s$. 
However, by replacing each initialization $s \larr n$ in $DetermineRobustness$ with the initialization $s \larr 1$, a modified algorithm is obtained which only determines $(r,1)$-robustness and can be directly compared with the method in Theorem \ref{thm:rrobust}. This modified algorithm is presented as Algorithm \ref{alg:modified} and serves as the benchmark against which we compare the performance of the MILP formulation presented in this paper (see Section \ref{sec:simulations}).
In addition, the initialization condition $r \larr \min(\delta^{\text{in}}(\D),\ceil{n/2})$ in $DetermineRobustness$ incorrectly classifies some rooted outbranchings as 0-robust (those with in-degree of the root being 0), when they are actually 1-robust (see Lemma 7 of \cite{leblanc2013resilient}). We have revised the initialization of $r$ accordingly.
The reader is referred to \cite{leblanc2013algorithms} for the definition of the function R\textsc{obustholds}$(A,S_1,S_2,r,s)$. In short, the function returns the boolean \textbf{true} if the number of $r$-reachable nodes from $S_1$ and $S_2$ is at least $s$, and \textbf{false} otherwise.

\begin{algorithm}
\caption{\small{Modified version of D\textsc{etermineRobustness}}}\label{alg:modified}
\begin{algorithmic}[1]
\State $r \leftarrow \min\pth{\max\pth{\delta^{\text{in}}(\D),1},\ceil{\frac{n}{2}}}$
\State $s \leftarrow 1$ \Comment{\emph{(Different than Alg. 3.2 in \cite{leblanc2013algorithms})}}
\State \textbf{comment:} $\delta^{\text{in}}(\D)$ is the min. in-degree of nodes in $\D$
\ForAll{$k \larr 2$ to $n$}
    \State \hspace{-1.9em} \textbf{comment:} $\mathcal{K}_k$ is the set of $C(n,k)$ unique subsets of $\V$
    \ForAll {$K_i \in \mathcal{K}_k\ (i = 1,2,\ldots,C(n,k))$}
    \ForAll {$P_j \in \mathcal{P}_{K_i}\ (j = 1,2,\ldots,2^{k-1}-1)$}
    \State \hspace{-2.2em}  \begin{tabular}{l l} \textbf{comment:} &$\mathcal{P}_{K_i}$ is set of partitions of $K_i$ into $S_1$ \\
    &and $S_2$ \end{tabular}
    \State ${isRSRobust \larr \text{R\textsc{obustholds}}}(A,S_1,S_2,r,s)$
    \If{($isRSRobust == $ \textbf{false}) \textbf{and} $s > 0$}
        \State $s \larr s -1$
    \EndIf
    \While{$isRRobust == $ \textbf{false} \textbf{and} $(r > 0)$}
        \While{$isRSRobust == $ \textbf{false} \textbf{and} $(s > 0)$}
            \State $isRRobust$
            \State \hspace{2em}$\larr \text{R\textsc{obustholds}}(A,S_1,S_2,r,s)$
            \If{\textbf{not} $isRSRobust$}
                \State $s \larr s-1$
            \EndIf
        \EndWhile
        
        \If{$isRSRobust == $ \textbf{false}}
            \State $r \larr r-1$
            \State $s \larr 1$  \Comment{\emph{(Different than Alg. 3.2 in \cite{leblanc2013algorithms})}}
        \EndIf
    \EndWhile
    
    \If{$r == 0$}
        \State \textbf{return} $r$
    \EndIf 
    \EndFor
    \State \textbf{end for}
    \EndFor
    \State \textbf{end for}
\EndFor
\State \textbf{end for}
% \Procedure{Algo1}{}
% \For{\texttt{<condition>}}
%         \State \texttt{<my stuff>}
%       \EndFor
% \EndProcedure
\end{algorithmic}
\end{algorithm}
% \vspace{-1em}


There are only two ways Algorithm \ref{alg:modified} will terminate: either the algorithm finds an $S_1 $ and $S_2 $ pair which are both 0-reachable, or the algorithm checks all possible unique pairs of subsets. Any subsets $S_1,S_2$ found such that $(S_1,S_2) \in \mathcal{T}$ and $\max(\Rc(S_1),\Rc(S_2)) < \beta$ for $\beta \in \Z_+$ is a certificate that the graph is \emph{not} $\beta$-robust \cite{zhang2015notion}; hence $r_{\max}(\D) < \beta$. It is only possible for Algorithm \ref{alg:modified} to tighten the \emph{upper bound} on $r_{\max}(\D)$ unless all pairs of relevant subsets are checked.

% On the other hand, the formulation in Corollary \ref{cor:equivgen} can be solved with a branch-and-bound (B\&B) algorithm. In these algorithms,

% [REVISE THIS] On the other hand, the formulation in Corollary \ref{cor:equivgen} can be solved with a branch-and-bound (B\&B) algorithm. For linear integer programs, B\&B algorithms first relax the integral constraint and solve the underlying convex optimization problem. The resulting ``relaxed" objective value is a valid lower bound on the objective value of the original problem. For each optimal variable in the relaxed problem with fractional value (e.g. $\alpha \notin \Z$), two new problems are formed by first constraining that variable to be greater than the integer above the fractional value ($\geq \ceil{\alpha}$), then constraining that variable to be less than the integer below the fractional value ($\leq \floor{\alpha}$). A \emph{search tree} of subproblems is formed by solving the relaxation of the existing subproblems, then branching into further subproblems based on the integrality of the resulting solutions.
% When any feasible integer solution to the IP is found, it is an upper bound on the objective value. An \emph{incumbent} is tracked by recording the currently known integer solution with best objective value. However, a \emph{lower bound} on the optimal objective value can also be obtained by taking the minimum objective value over the relaxations of all the subproblems. Optimality is achieved when the incumbent's objective and the lower bound are equal. [FATHOMING?]

On the other hand, since the optimal value of Corollary \ref{cor:equivgen} is equal to $r_{\max}(\D)$ it is possible for a \emph{lower} bound on the robustness of $\D$ to be tightened over time by using a branch-and-bound (B\&B) algorithm \cite{wolsey2007mixed,vanderbei2015linear}. A lower bound on $r_{\max}(\D)$ is often more useful than an upper one, since $r_{\max}(\D) \geq \gamma$ implies that $\D$ is $r$-robust for all $0 \leq r \leq \gamma$.
% Space constraints prevent a detailed review of the functionality of B\&B algorithms; the reader is referred to any elementary textbook on integer programming for more details. 
The crucial advantage of B\&B algorithms is that both a global upper bound \emph{and lower bound} on the objective value are calculated and iteratively tightened as successive convex relaxations of the optimization problem are solved. When the gap between these bounds becomes zero, optimality is obtained. However, the search can also be terminated if the lower bound on the objective reaches a sufficiently high value. In context of robustness determination,
this therefore introduces the possibility of calculating approximate lower bounds on $r_{\max}(\D)$ for arbitrary nonempty, nontrivial, simple digraphs (and undirected graphs) without needing to fully solve for $r_{\max}(\D)$. A more detailed examination of the convergence rate for this lower bound is left for future work.


\section{Simulations}
\label{sec:simulations}

Simulations were conducted to compare the computation time of our formulation against Algorithm \ref{alg:modified}, the modified version of $DetermineRobustness$ proposed in \cite{leblanc2013algorithms}. Computations were performed in MATLAB 2018a on a desktop computer with an Intel Core i7-6700 CPU (3.40GHz) capable of handling 8 threads, and with 31GB of RAM.
The simulations tested the time required for the algorithms to calculate the \emph{exact} maximum $r$-robustness for various types of graphs. The algorithms tested were Algorithm \ref{alg:modified}, which is a modification of $DetermineRobustness$ in \cite{leblanc2013algorithms}, and the proposed formulation in Corollary \ref{cor:equivgen} solved using MATLAB's \emph{intlinprog} function. Four classes of random graphs were tested: Erd\H{o}s-R\'enyi random undirected graphs, directed random graphs, $k$-in directed random graphs, and $k$-out directed random graphs \cite{bollobas2001random}.\footnote{$k$-in random graphs are constructed in the same manner as $k$-out random graphs, but with the edge directions reversed.} 
% In addition, three types of non-random graphs were tested: complete, $k$-circulant undirected, and $k$-circulant directed graphs \cite{Usevitch2017}. 
Various values of $n$ were selected ranging from $7$ to $15$, and for each value of $n$ the algorithms were tested on 100 graphs. Additionally, the proposed MILP formulation was tested on random digraphs with values of $n$ ranging from $18$ to $30$, where 100 graphs were tested for each value of $n$.  For Erd\H{o}s-R\'enyi graphs and random digraphs, simulations were performed for edge formation probabilities $p \in \{.3, .5, .8 \}$. For the $k$-in and $k$-out random digraphs, simulations were performed for $k \in \{3,4,5\}$. Due to space constraints, only graphs for values $p = .5$, $p=.8$, and $k = 4$ are shown.
In all trials for the $n$ values where both algorithms were tested, the maximum $r$-robustness of the MILP formulation found for the graph was \emph{exactly} equal to the maximum $r$-robustness returned by the exhaustive search method Algorithm 1. 
The computation time of both algorithms demonstrate an exponential trend. However, for $n \geq 8$ the average computation time for the MILP algorithm is clearly less than the average computation time for Algorithm \ref{alg:modified}. 

% Each algorithm was run on the same set of 100 Erd\H{o}s-R\'enyi graphs and 100 digraphs. For each algorithm and value of $n$, the computation time was averaged over all graphs with the exception of graphs which were 0-robust. The results are shown in Figure [INSERT HERE]. The averaged computation times for graphs which were 0-robust are plotted separately in Figure [INSERT HERE]. The reason for this separation is that the computation time for 0-robust graphs tended to be drastically smaller for all algorithms. The results for these graphs are plotted separately to compare each algorithm's ability to determine whether a graph was 0-robust or not.

% It should be pointed out that the algorithm in [LEBLANC2013] determines $(r,s)$-robustness rather than $r$-robustness. However, since $r$-robustness is equivalent to $(r,1)$-robustness [SOURCE] the algorithm can easily be modified to provide a suitable benchmark for the formulation proposed in this paper. More specifically, in the algorithm $DetermineRobustness$ the value of $s$ can be initialized at 1 instead of $n$ to test only for $(r,1)$-robustness. 



\begin{figure}
    \centering
    \includegraphics[width=\figsc\columnwidth]{Images/randdir_p05_n100x_LB_intlin_MILP.eps}
    \caption{Computation time for determining maximum $r$-robustness of random directed graphs with parameter $p = 0.5$. Note the logarithmic scale on the y-axis. The vertical lines indicate the spread between max and min times, respectively, for each value of $n$.}
    % \label{fig:my_label}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\figsc\columnwidth]{Images/randdir_p08_n100x_LB_intlin_MILP.eps}
    \caption{Computation time for determining maximum $r$-robustness of random directed graphs with parameter $p = 0.8$.}
    % \label{fig:my_label}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\figsc\columnwidth]{Images/Erdos_p05_n100x_LB_intlin_MILP.eps}
    \caption{Computation time for determining maximum $r$-robustness of \Erdosrenyi random graphs with parameter $p = 0.5$.}
    \label{fig:Erdosp05}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\figsc\columnwidth]{Images/kinrand_k4_n100x_LB_intlin_MILP.eps}
    \caption{Computation time for determining maximum $r$-robustness of $k$-in random directed graphs with parameter $k = 0.5$. }
    \label{fig:kinrand_k04}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\figsc\columnwidth]{Images/koutrand_k4_n100x_LB_intlin_MILP.eps}
    \caption{Computation time for determining maximum $r$-robustness of $k$-out random directed graphs with parameter $k = 0.5$. }
    \label{fig:koutrand_k04}
\end{figure}

% [We compared our algorithm against a blend of $DetermineRobustness$ and $CheckRobustness$. We used an algorithm which can be thought of as $DetRob$ with $s$ always initialized at the value 1, or $CheckRobustness$ run iteratively with $r$ decreasing from $degmin$ and $s=1$ for each iteration.]

\section{Conclusion}
\label{sec:conclusion}
This paper formulated the problem of determining the largest integer $r$ for which an arbitrary simple digraph is $r$-robust as a mixed integer linear program. This formulation was shown to have affine objective and constraints, except the integer constraint. Simulations suggest that this formulation demonstrates reduced computation time as compared to prior algorithms. Future work will include investigating techniques from the integer programming literature to further improve the efficiency of this method.


% \section{Appendix}
% \label{sec:appendix}


% \subsection{Counterexample 1}

% %[UNDIRECTED GRAPH WITH 3-CLIQUES]

% \begin{theorem}
% \label{thm:undircounter}
%     Consider the undirected graph $\G$ shown in Figure \ref{fig:undircounter} with the depicted sets $(S_1^k,S_2^k, S_0^k)$. For all other nonempty, disjoint sets $S_1^q$ and $S_2^q$ such that $S_1^q \cup S_2^q = \V$,
%     \begin{equation}
%         \max_m \Rc(S_m^q) > \max_m \Rc(S_m^k) = 2,\ m \in \{1,2 \},
%     \end{equation}
%     implying that the $r$-robustness of $\G$ is determined by a partitioning $(S_1^{k'},S_2^{k'},S_0^{k'})$ with a nonempty $S_0^{k'}$.
% \end{theorem}

% \begin{proof}
%     We prove by contradiction. Suppose there exists nonempty, disjoint $S_1^q, S_2^q$ such that $S_1^q \cup S_2^q = \V$ and $\max_m \Rc(S_m^q) \leq \max_m \Rc(S_m^k) = 2,\ m \in \{1,2 \}$. We will attempt to find such subsets $S_1^q$ and $S_2^q$.
    
%     Without loss of generality suppose $1 \in S_1^q$. To ensure $\max_m \Rc(S_m^q) \leq 2$, we must have $\Rc(S_1^q) \leq 2$ and $\Rc(S_2^q) \leq 2$. Since the in-degree of $1$ is $6$, there must be at least 4 more nodes in $S_1^q$, otherwise $\Rc(S_1^q) \geq 3$.
    
%     Note that there are two cliques: sets $\{2,3,4\}$ and $\{5,6,7\}$. Suppose the clique $\{2,3,4 \}$ is entirely in $S_1^q$, yielding $\{1,2,3,4 \} \in S_1^q$. In this case $S_1^q$ has a reachability of $3$ due to node 1. If we add one node from the remaining clique $\{5,6,7\}$ to $S_1^q$ (e.g. node 5), then the two remaining nodes in $S_2^q$ (e.g. 6 and 7) will each have 3 in-neighbors outside their own set, implying $S_2^q$ is 3-reachable (e.g. 6 has $\{1,4,5 \}$ as in-neighbors, 7 has $\{1,3,5 \}$ as in-neighbors). If instead two nodes from the remaining clique are added to $S_1^q$ (e.g. 5 and 6), then one node (e.g. 7) will be in $S_2^q$ by itself.
%     %For example, if we put node 5 in $S_1^q$ such that $S_1^q = \{1,2,3,4,5 \}$, then $S_2^q = \{6,7\}$ and $S_2^q$ is 3-reachable (node 6 has $\{1,4,5 \}$ as in-neighbors and 7 has $\{1,3,5 \}$ as in-neighbors). A similar result holds if either 6 or 7 are added to $S_1^q$ instead of 5. 
%     If any node from one of the cliques is in $S_2^q$ by itself (e.g. $S_2^q = \{7\}$), it will have 3 in-neighbors in $S_1^q$ (e.g. nodes 1, 5, and 6).
    
%     Similar arguments hold if we begin by including the clique $\{5,6,7 \}$ in $S_1^q$ instead of $\{2,3,4 \}$. Therefore if any whole clique is included in $S_1^q$, we have $\max_m \Rc(S_m^q) \geq 3$.
    
%     It follows that the only possibilities for a $(S_1^q,S_2^q)$ pair where $\max_m \Rc(S_m^q)$ might be less than or equal to 2 are when $S_1^q$ does not include all the nodes from either of the cliques. Again, if $S_1^q$ does not contain at least 4 other nodes besides node 1, then the reachability of $S_1^q$ will be at least 3. Therefore two nodes from each clique must be included in $S_1^q$. This implies that there will be two nodes in $S_2^q$, one from each clique. However, each of these two nodes will have at least 3 in-neighbors from $S_1^q$: node 1 and the two nodes from their respective cliques. For example, if $S_1^q = \{1,2,3,5,6 \}$ and $S_2^q = \{4,7 \}$, node 4 will have $1,2,3$ as in-neighbors and node 7 will have $1,5,6$ as in-neighbors.
    
%     All possible cases where $S_1^q \cup S_2^q = \V$ are covered by these arguments. Therefore $S_1^q \cup S_2^q = \V \implies \max_m \Rc(S_m^k) \geq 3$. Since $\max_m \Rc(S_m^k) = 2$ for the given configuration with $S_0^k \neq \{\emptyset \}$, we have 
    
%     \begin{equation}
%         \max_m \Rc(S_m^q) > \max_m \Rc(S_m^k),\ m \in \{1,2 \}
%     \end{equation}
    
%     Since $S_0^k$ is nonempty, this implies that the $r$-robustness of this graph cannot be determined by a case where $S_1^q \cup S_2^q = \V$.
    
    
    
% \end{proof}

% \begin{remark}
%         We clarify that this proof does not explicitly show that the given partitioning $(S_1^k,S_2^k,S_0^k)$ yields the value $r_{\max}(\G)$. It simply proves that the partitioning which yields $r_{\max}(\G)$ must have a nonempty $S_0$ set. However, the reader may verify by checking all nonempty disjoint subsets that the given partitioning $(S_1^k,S_2^k,S_0^k)$ indeed yields $r_{\max}(\G)$.
%     \end{remark}



% \subsection{Counterexample 2}

% % [DIRECTED GRAPH WITH 3-CLIQUES]

% \begin{theorem}
%     Consider the digraph $\D_1$ shown in Figure \ref{fig:dircounter} with the depicted sets $(S_1^k,S_2^k, S_0^k)$. For all other nonempty, disjoint sets $S_1^q$ and $S_2^q$ such that $S_1^q \cup S_2^q = \V$,
%     \begin{equation}
%         \max_m \Rc(S_m^q) > \max_m \Rc(S_m^k) = 2,\ m \in \{1,2 \},
%     \end{equation}
%     implying that the $r$-robustness of $\D_1$ is determined by a partitioning $(S_1^{k'},S_2^{k'},S_0^{k'})$ with a nonempty $S_0^{k'}$.
% \end{theorem}

% \begin{proof}
%     The result may be proven using a method similar to the proof of Theorem \ref{thm:undircounter}.
% \end{proof}

%%% DO NOT UNCOMMENT startA

%\subsection{Counterexample 3?}
%
%% [DIRECTED GRAPH WITH GENERALIZED N-CLIQUES]
%
%\begin{theorem}
%    Consider the digraph $\D_2$ with clique sizes as a function of $s$ shown in Figure [INSERT HERE] with the given sets $(S_1^k,S_2^k, S_0^k)$. For all other nonempty, disjoint sets $S_1^q$ and $S_2^q$ such that $S_1^q \cup S_2^q = \V$,
%    \begin{equation}
%        \max_m \Rc(S_m^q) > \max_m \Rc(S_m^k) = 2,\ m \in \{1,2 \},
%    \end{equation}
%    implying that the $r$-robustness of $\D_2$ is determined by a partitioning $(S_1^{k'},S_2^{k'},S_0^{k'})$ with a nonempty $S_0^{k'}$ for all $s \geq 3$.
%\end{theorem}
%
%\begin{proof}
%    [Prove for the case where the clique]
%\end{proof}

%%% DO NOT UNCOMMENT endA

\bibliographystyle{IEEEtran}

\bibliography{ACC2019.bib}

\end{document}
