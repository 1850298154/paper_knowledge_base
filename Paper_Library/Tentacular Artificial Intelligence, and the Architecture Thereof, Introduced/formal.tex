% To make the above notions more concrete, we use a two-level
% formalism. The above scenarios have different AI agents interacting
% with each other in a concurrent manner in the real world. While Most
% AI formalizations deal with information processing, there are
% formalisms for modeling concurrent computation.  We need one formalism
% that interleaves both these different levels of abstraction. For
% modeling concurrent computation that goes across different agents, we
% use the actor calculus. The actor calculus has been used successfully
% to model and build concurrent computing systems in the real world. For
% the second level of information processing, we use a computational
% logic. 


%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\begin{figure}[h!]
 \centering
 {
  \includegraphics[width=\linewidth]{./star_fig.pdf}}
 \caption{Space of Logical Calculi.  \textit{There are five dimensions
     that cover the entire, vast space of logical calculi.  The due
     West dimension holds those calculi powering the Semantic Web
     (which are generally short of first-order logic =
     $\mathcal{L}_1$), and include so-called \textbf{description
       logics}.  Both NW and NE include logical systems with wffs that
     are allowed to be infinitely long, and are needless to say hard
     to compute with and over.  SE is higher-order logic, which has
     a robust automated theorem-proving community gathered around it.
     It's the SW direction that holds the cognitive calculi described
     in the present paper, and associated with TAI; and the star refers
     to those specific cognitive calculi called out in these pages by
     us.}}
 \label{fig:star_fig}
\end{figure}
%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


To make the above notions more concrete, we use a version of a
computational logic.  The logic we use is \textbf{deontic cognitive
  event calculus} (\DCEC).  This calculus is a first-order modal
logic. Figure ~\ref{fig:star_fig} shows the region where \DCEC\ is
located in the overall space of logical calculi. \DCEC\ belongs to the
\textbf{cognitive calculi} family of logical calculi (denoted by a
star in Figure~\ref{fig:star_fig} and expanded in
Figure~\ref{fig:cc_family}). \DCEC\ has a well-defined syntax and
inference system; see Appendix A of \cite{nsg_sb_dde_2017} for a full
description. The inference system is based on natural deduction
\cite{gentzen_investigations_into_logical_deduction}, and includes all
the introduction and elimination rules for first-order logic, as well
as inference schemata for the modal operators and related structures

This system has been used previously in
\cite{nsg_sb_dde_2017,dde_self_sacrifice_2017} to automate versions of
the doctrine of double effect \DDE, an ethical principle with
deontological and consequentialist components.  While describing the
calculus is beyond the scope of this paper, we give a quick overview
of the system below.  Dialects of \DCEC\ have also been used to
formalize and automate highly intensional (i.e. cognitive) reasoning
processes, such as the false-belief task
\cite{ArkoudasAndBringsjord2008Pricai} and \textit{akrasia}
(succumbing to temptation to violate moral principles)
\cite{akratic_robots_ieee_n}. {Arkoudas and Bringsjord
  \shortcite{ArkoudasAndBringsjord2008Pricai} introduced the general
  family of \textbf{cognitive event calculi} to which \DCEC\ belongs,
  by way of their formalization of the false-belief task.} More
precisely, \DCEC\ is a sorted (i.e.\ typed) quantified modal logic
(also known as sorted first-order modal logic) that includes the event
calculus, a first-order calculus used for commonsense reasoning.

 
%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\begin{figure}[h!]
 \centering
 {
  \includegraphics[width=0.75\linewidth]{./CCFamily.pdf}}
\caption{Cognitive Calculi. \textit{The \textbf{cognitive calculi}
    family is composed of a number of related
    calculi. \protect\citeauthor{ArkoudasAndBringsjord2008Pricai} introduced
    the first member in this family, $\mathcal{CEC}$, to model the
    false-belief task. The smallest member in this family,
    $\mu\mathcal{C}$, has been used to model uncertainty in quantified
    beliefs \protect\cite{govindarajulu2017strength}. \DCEC\ and variants have
    been used in the modelling of ethical principles and theories and
    their implementations.}}
 \label{fig:cc_family}
\end{figure}
%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



\subsection{Syntax}
\label{subsect:syntax}

As mentioned above, \DCEC\ is a sorted calculus.  A sorted system can
be regarded as analogous to a typed single-inheritance programming
language.  We show below some of the important sorts used in \DCEC.\\
 
\begin{footnotesize}
\rowcolors{2}{gray!10}{white}
\def\arraystretch{1.25}

\begin{tabular}{lp{5.8cm}}  
\toprule
\textbf{Sort}    & \textbf{Description} \\
\midrule
\type{Agent} & Human and non-human actors.  \\

\type{Time} &  The \type{Time} type stands for
time in the domain.  E.g.\ simple, such as $t_i$, or complex, such as
$birthday(son(jack))$. \\

 \type{Event} & Used for events in the domain. \\
 \type{ActionType} & Action types are abstract actions.  They are
  instantiated at particular times by actors.  Example: eating.\\
 \type{Action} & A subtype of \type{Event} for events that occur
  as actions by agents. \\
 \type{Fluent} & Used for representing states of the world in the
  event calculus. \\
\bottomrule
\end{tabular}
\end{footnotesize} \\

The syntax has two components: a first-order
core and a modal system that builds upon this first-order core.  The
figures below show the syntax and inference schemata of \DCEC.    The first-order core of \DCEC\ is
the \emph{event calculus} \cite{mueller_commonsense_reasoning}.
Commonly used function and relation symbols of the event calculus are
included.  Fluents, event and times are the three major sorts of the event
calculus. Fluents represent states of the world as first-order
terms. Events are things that happen in the world at specific instants
of time. Actions are events that are carried out by an agent. For any
action type $\alpha$ and agent $a$, the event corresponding to $a$
carrying out $\alpha$ is given by $action(a, \alpha)$. For instance
if $\alpha$ is \textit{``running''} and $a$ is \textit{``Jack'' },
$action(a, \alpha)$ denotes \textit{``Jack is running''}.
Other calculi (e.g.\ the \emph{situation calculus}) for
modeling commonsense and physical reasoning can be easily switched out
in-place of the event calculus.

 \begin{scriptsize}
\begin{mdframed}[linecolor=white, frametitle=Syntax,
  frametitlebackgroundcolor=gray!10, backgroundcolor=gray!05,
  roundcorner=8pt]
 \begin{equation*}
 \begin{aligned} 
    \mathit{S} &::= 
    \begin{aligned}
      & \Agent \sep \ActionType \sep \Action \sqsubseteq
      \Event \sep \Moment  \sep \Fluent \\
    \end{aligned} 
    \\ 
    \mathit{f} &::= \left\{
    \begin{aligned}
      & action: \Agent \times \ActionType \rightarrow \Action \\
      &  \initially: \Fluent \rightarrow \Boolean\\
      &  \holds: \Fluent \times \Moment \rightarrow \Boolean \\
      & \happens: \Event \times \Moment \rightarrow \Boolean \\
      & \clipped: \Moment \times \Fluent \times \Moment \rightarrow \Boolean \\
      & \initiates: \Event \times \Fluent \times \Moment \rightarrow \Boolean\\
      & \terminates: \Event \times \Fluent \times \Moment \rightarrow \Boolean \\
      & \prior: \Moment \times \Moment \rightarrow \Boolean\\
    \end{aligned}\right.\\
        \mathit{t} &::=
    \begin{aligned}
      \mathit{x : S} \sep \mathit{c : S} \sep f(t_1,\ldots,t_n)
    \end{aligned}
    \\ 
    \mathit{\phi}&::= \left\{ 
    \begin{aligned}
     & q:\Boolean \sep  \neg \phi \sep \phi \land \psi \sep \phi \lor
     \psi \sep \forall x: \phi(x) \sep \\\
 &\perceives (a,t,\phi)  \sep \knows(a,t,\phi) \sep     \\ 
& \common(t,\phi) \sep
 \says(a,b,t,\phi) 
     \sep \says(a,t,\phi) \sep  \believes(a,t,\phi) \\
& \desires(a,t,\phi)  \sep \intends(a,t,\phi) \\ & \ought(a,t,\phi,(\lnot)\happens(action(a^\ast,\alpha),t'))
      \end{aligned}\right.
  \end{aligned}
\end{equation*}
\end{mdframed}
\end{scriptsize}


The modal operators present in the calculus include the standard
operators for knowledge $\knows$, belief $\believes$, desire
$\desires$, intention $\intends$, etc.  The general format of an
intensional operator is $\knows\left(a, t, \phi\right)$, which says
that agent $a$ knows at time $t$ the proposition $\phi$.  Here $\phi$
can in turn be any arbitrary formula. Also,
note the following modal operators: $\mathbf{P}$ for perceiving a
state, 
$\mathbf{C}$ for common knowledge, $\mathbf{S}$ for agent-to-agent
communication and public announcements, $\mathbf{B}$ for belief,
$\mathbf{D}$ for desire, $\mathbf{I}$ for intention, and finally and
crucially, a dyadic deontic operator $\mathbf{O}$ that states when an
action is obligatory or forbidden for agents. It should be noted that
\DCEC\ is one specimen in a \emph{family} of extensible
cognitive calculi.
 
The calculus also includes a dyadic (arity = 2) deontic operator
$\ought$. It is well known that the unary ought in standard deontic
logic leads to contradictions.  Our dyadic version of the operator
blocks the standard list of such contradictions, and
beyond.\footnote{A overview of this list is given lucidly in
  \cite{sep_deontic_logic}.}

Declarative communication of $\phi$ between $a$ and $b$ at time $t$ is
represented using the $\says(a,b,t, \phi)$.


\subsection{Inference Schemata}


The figure below shows a fragment of the inference schemata for \DCEC.
First-order natural deduction introduction and elimination rules are
not shown. Inference schemata $I_\mathbf{K}$ and $I_\mathbf{B}$ let us
model idealized systems that have their knowledge and beliefs closed
under the \DCEC\ proof theory.  While humans are not deductively
closed, these two rules lets us model more closely how more deliberate
agents such as organizations, nations and more strategic actors
reason. (Some dialects of cognitive calculi restrict the number of
iterations on intensional
operators.) % $I_1$ and $I_2$ state respectively that it is common
% knowledge that perception leads to knowledge, and that it is common
% knowledge that knowledge leads to belief.  $I_3$ lets us expand out
% common knowledge as unbounded iterated knowledge.  $I_4$ states that
% knowledge of a proposition implies that the proposition holds.  $I_5$
% to $I_{10}$ provide for a more restricted form of reasoning for
% propositions that are common knowledge, unlike propositions that are
% known or believed.
$I_{13}$ ties intentions directly to perceptions
(This model does not take into account agents that could fail to carry
out their intentions).  $I_{14}$ dictates how obligations get
translated into known intentions.


\begin{scriptsize}


\begin{mdframed}[linecolor=white, frametitle=Inference Schemata
  (Fragment), nobreak=true, frametitlebackgroundcolor=gray!10, backgroundcolor=gray!05, roundcorner=8pt]
\begin{equation*}
\begin{aligned}
% &\mbox{Sample rules below. For more rules, see
%   \cite{akratic_robots_ieee_n}.}\\
  &\hspace{40pt} \infer[{[I_{\knows}]}]{\knows(a,t_2,\phi)}{\knows(a,t_1,\Gamma), \ 
    \ \Gamma\vdash\phi, \ \ t_1 \leq t_2}  \\ 
& \hspace{40pt} \infer[{[I_{\believes}]}]{\believes(a,t_2,\phi)}{\believes(a,t_1,\Gamma), \ 
    \ \Gamma\vdash\phi, \ \ t_1 \leq t_2} \\
%  &\infer[{[I_1]}]{\common(t,\perceives(a,t,\phi)
%    \lif\knows(a,t,\phi))}{}\\ 
% &\infer[{[I_2]}]{\common(t,\knows(a,t,\phi)
%     \lif\believes(a,t,\phi))}{}\\
 %   &\infer[{[I_3]}]{\knows(a_1, t_1, \ldots
 %     \knows(a_n,t_n,\phi)\ldots)}{\common(t,\phi) \ t\leq t_1 \ldots t\leq
 %     t_n}\hspace{5pt}
 % \infer[{[I_4]}]{\phi}{\knows(a,t,\phi)}\\
%   & \infer[{[I_5]}]{\common(t,\knows(a,t_1,\phi_1\lif\phi_2))
%     \lif \knows(a,t_2,\phi_1) \lif \knows(a,t_3,\phi_2)}{}\\
% & \infer[{[I_6]}]{\common(t,\believes(a,t_1,\phi_1\lif\phi_2))
%     \lif \believes(a,t_2,\phi_1) \lif \believes(a,t_3,\phi_2)}{}\\
% & \infer[{[I_7]}]{\common(t,\common(t_1,\phi_1\lif\phi_2))
%     \lif \common(t_2,\phi_1) \lif \common(t_3,\phi_2)}{} \\
% & \infer[{[I_8]}]{\common(t, \forall x. \  \phi \lif \phi[x\mapsto
%   t])}{} \hspace{6pt}
%   \infer[{[I_9]}]{\common(t,\phi_1 \liff \phi_2 \lif \neg
%     \phi_2 \lif \neg \phi_1)}{}\\
% & \infer[{[I_{10}]}] {\common(t,[\phi_1\land\ldots\land\phi_n\lif\phi]
%   \lif [\phi_1\lif\ldots\lif\phi_n\lif\psi])}{}\\
% & \infer[{[I_{11a}]}]{\believes(a,t,\psi)}{\believes(a,t,\phi)\ \ \phi
%   \lif \psi}\
% \hspace{6pt} \infer[{[I_{11b}]}]{\believes(a,t,\psi \land \phi)}{\believes(a,t,\phi)\ \ \believes(a,t,\psi)}\\ 
& \hspace{20pt} \infer[{[I_4]}]{\phi}{\knows(a,t,\phi)}
\hspace{18pt}\infer[{[I_{13}]}]{\perceives(a,t', \psi)}{t<t', \ \ \intends(a,t,\psi)}\\
&\infer[{[I_{14}]}]{\knows(a,t,\intends(a,t,\chi))}{\begin{aligned}\ \ \ \ \believes(a,t,\phi)
 & \ \ \
 \believes(a,t,\ought(a,t,\phi, \chi)) \ \ \ \ought(a,t,\phi,
 \chi)\end{aligned}}
\end{aligned}
\end{equation*}
\end{mdframed}
\end{scriptsize}



 \subsection{Semantics}

 The semantics for the first-order fragment is the standard
 first-order semantics. The truth-functional connectives
 $\land, \lor, \rightarrow, \lnot$ and quantifiers $\forall, \exists$
 for pure first-order formulae all have the standard first-order
 semantics. The semantics of the modal operators differs from what is
 available in the so-called Belief-Desire-Intention (BDI) logics
 {\cite{bdi_krr_1999}} in many important ways.  For example, \DCEC\
 explicitly rejects possible-worlds semantics and model-based
 reasoning, instead opting for a \textit{proof-theoretic} semantics
 and the associated type of reasoning commonly referred to as
 \textit{natural deduction}
 \cite{gentzen_investigations_into_logical_deduction,proof-theoretic_semantics_for_nat_lang}.
 Briefly, in this approach, meanings of modal operators are defined
 via arbitrary computations over proofs. 



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
