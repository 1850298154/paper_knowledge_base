Given a (globally or locally) deadlocked run of $\largesys$ 
we construct (globally or locally) deadlocked run of $\cutoffsys$, 
where $c$ depends on the nature of the given run. 
We do this using the construction template. 

Let $\mB=\{B_1,...,B_n\}$.
The template depends on set $\mC \subseteq \{B_1,...,B_c\}$:
\li
  \-[a.] set $y(A)=x(A)$
  \-[b.] for every $B_i \in \mC$, set $y(B_i)=x(B_i)$
  \-[c.] for every $q \in \visInf{\mB\smi\mC}{x}$, 
         devote one process of \cutoffsys that floods $q$
  \-[d.] for every $q \in \visFin{\mB\smi\mC}{x}$, 
         devote one process of \cutoffsys that floods $q$ 
         and then evacuates into $\visInf{\mB\smi\mC}{x}$
  \-[e.] let other processes (if any) mimic some process from (c)
\il

\myparagraph{1) Local Deadlock}
We distinguish three cases: 
\li
  \-[1a)] $A$ deadlocks, $B_1$ moves infinitely often
  \-[1b)] $A$ moves infinitely often, $B_1$ deadlocks
  \-[1c)] $A$ neither deadlocks nor moves infinitely often, 
          $B_1$ deadlocks, $B_2$ moves infinitely often.
\il

\myparagraphraw{1a:} ``$A$ deadlocks, $B_1$ moves infinitely often''. 

Let $c=|B|+1$, and $\mC=\{B_1\}$.
Note that $\visInf{B_2..B_n}{x} \neq \emptyset$. 
The resulting construction uses 
$|\visFin{B_2..B_n}{x}| + |\visInf{B_2..B_n}{x}| + 1 
 \leq 
 |B| + 1$ 
copies of B.
\ak{seems tight}\ak{correctness}

\myparagraphraw{1b:} ``$A$ moves infinitely often, $B_1$ deadlocks''. 

Let $c=|B|+1$, and $\mC=\{B_1\}$.
Let $q_\bot$ be the state in which $B_1$ deadlocks.
Instantiate the construction template.

Process $B_1$ of \cutoffsys is deadlocked in $y$ starting from some moment $d$,
because any state it sees (in $\visInf{A,B_2..B_n}{x}$)
was also seen by $B_1$ in \largesys in $x$ at some moment $d' \geq d$
(note that $d'$ may be not the same moment as $d$).
%\footnote{Note about open systems: here we use the fact from the definitions 
%          that inputs to $B_1$ do not change.
%          This ensures that the set of states that $B_1$ should not see in order
%          to stay deadlocked does not change over time.}


\myparagraphraw{1c:} ``$A$ neither deadlocks nor moves infinitely often, 
                       $B_1$ deadlocks, $B_2$ moves infinitely often''. 

Instantiate the construction template with $c=|B|+2$ and $\mC = \{B_1,B_2\}$.
\ak{seems not tight}\ak{correctness}

\smallskip
Finally, $|B|+2$ is a (possibly not tight) cutoff for local deadlock detection problem.


\myparagraph{2) Global Deadlock}
Let $x=(s_1,e_1,p_1)...(s_d,e_d,\bot)$ be a globally deadlocked run of $\largesys$ 
with $n\geq c$.

Let us abuse the definition of $\visInf{\mF}{x}$ and $\visFin{\mF}{x}$,
in Eq.~\ref{disj:def_vinf_wrt} and \ref{disj:def_vfin_wrt} resp., 
and adapt it to the case of finite runs.
To this end, given a finite run $x=(s_1,e_1,p_1)...(s_d,e_d,\bot)$, 
extend it to the infinite sequence $(s_1,e_1,p_1)...(s_d,e_d,\bot)^\omega$, 
and apply the definition of $\visInf{\mF}{x}$ and $\visFin{\mF}{x}$ to the sequence.

Let $\mD_1$ be the set of processes deadlocked in unique states:
$\forall p\in \mD_1 \not\exists p' \neq p: s_d(p')=s_d(p)$.
Instantiate the construction template with $\mC = \mD_1$ and $c=2|B|-1$.
\footnote{$2|B|-1$ copies is enough, because: 
          $\visFin{\mB\smi\mC}{x} \cap \visInf{\mB\smi\mC}{x} = \emptyset$,
          $\visInf{\mB\smi\mC}{x} \cap \visInf{\mC}{x} = \emptyset$,
          and if $\visFin{\mB\smi\mC}{x} \neq \emptyset$, 
          then $\visInf{\mB\smi\mC}{x} \neq \emptyset$.}
\ak{seems not tight}

%The construction uses $|dead1| + |dead2| + |\visited_{\fin-P_\bot^1}(x)| \leq 2|B|-1$ copies of B.\ak{seems not tight}\ak{CHECK}\ak{correctness}

\myparagraph{3) Deadlocks}
As the cutoff for the deadlock detection problem we take the largest cutoff in (1)-(2), namely, $2|B|-1$, but it may be not tight -- finding the tight cutoffs for local deadlock and for deadlock detection problems is an open problem.

\ak{tried to refine but could not -- the trial is commented out}
% AK: try to utilize the existence of the order?
% Now let us refine the estimate:
% \li
% \- `unique finite state' is any state in $\visited_{\fin+P_1_\bot}$ that either is not in $ \visited_{\fin-P_1_\bot} $, or the state that appears not in $]f_q,l_q[_{-P_1_\bot}$
% 
% \- intuitively, state is unique finite if we cannot make it `visible' by using the flooding and evacuating construction wrt. $ \visited_{\fin-P_1_\bot} $, $\visited_{\inf-P_1_\bot}$. Otherwise, if state is not unique finite then  we can flood the state and then evacuate into $ \visited_{\inf-P_1_\bot} $ 
% 
% \- let $U^c \subseteq P_1_\bot$ be the set of processes that have unique finite states on its run to $q_\bot \in \visited_\bot^1$. Let $U^f = P_1_\bot\smi U^c$.
% 
% \- note that for any $p \in U^f$ any its finite state can be flooded and then evacuated into $ \visited_{\inf-P_1_\bot} $ using local runs of $\mathcal{B}\smi P_1_\bot$ processes. Intuitively, this means that $U^f$ processes' finite states are not needed.
% 
% \- let us divide $\visited_\bot^1$ into two disjiont sets: $\visited_\bot^c$ (and corr. processes are $U^c$) is the set of states whose deadlocked paths do have a unique finite state, and $\visited_\bot^f$ (and corr. processes are $U^f$) is the set of states whose deadlocked paths do not have a unique finite state.
% \il
% 
% Define $ \visited_{\fin-U^c} $ and $ \visited_{\inf-U^c} $ wrt. $U^c$.
% Then the construction is:
% \li
%   \-[a.] $y(A)=x(A)$
%   \-[b.] copy the runs of $U^c$ processes (that end in $\visited_\bot^c$)
%   \-[c.] flood states in $ \visited_{\inf-U^c} $
%   \-[d.] for any $ q \in \visited_{\fin-U^c} $ devote one process that floods it and then evacuates into $ \visited_{\inf-U^c} \smi \visited_\bot^f$. Note that we can evacuate a state from $ \visited_{\fin-U^c} $ into $ \visited_{\inf-U^c} \smi \visited_\bot^f $, because processes $U^f$ do not contribute to the evacuation by definition.\ak{vague}
%   \-[e.] let other processes (if any) mimic a process from (c)
% \il
% The construction uses $|\visited_\bot^c| + | \visited_{\inf-U^c} | + | \visited_{\fin-U^c} |$. Note that:
% \li
%   \- $\visited_\bot^c$, $ \visited_{\inf-U^c} $ are disjoint
%   \- $\visited_{\inf-U^c}$, $\visited_{\fin-U^c}$ are disjoint
%   \- possibly $\visited_\bot^c \cap \visited_{\fin-U^c} \neq \emptyset$
% \il 
% If some $p \in U^c$, then it has at least one unique finite state $q$: possibly $q \in  \visited_{\inf-U^c} $ or $q \in \visited_{\fin-U^c}$, but $q \not\in \visited_\bot^c$. \ak{stuck here -- it is possible that all $U^c$ processes share a single unique finite state}

\sj{my idea for smaller cutoff in comments}

%What about this:
%separate states into:
%
%\noindent
%$\visited^2_\bot$        (deadlock-2 states)\\
%$\visited^1_{unique}$        (deadlock-1 states that do not appear in paths to $\visited^2_\bot$)\\
%$\visited^1_{both}$        (deadlock-1 states that do appear in paths to $\visited^2_\bot$)\\
%$\visited_\fin$        (non-deadlock states visited in *any* local path)\\
%
%Now, $\visited^1_{unique}, \visited^1_{both}, \visited^2_\bot$ and $\visited_\fin$ are disjoint (and contain all states appearing in $x$).
%Then:
%\begin{itemize}
%\item copy paths from $\visited^1_{unique}$\\
%\item flood states from $\visited^1_{both}$ and $\visited^2_\bot$\\
%\item flood and evacuate states from $\visited_\fin$
%\end{itemize}
%
%Why is it OK to flood states from $\visited^1_{both}$ instead of copying them?
%Because we know that from these states, we can evacuate to some state in $\visited^2_\bot$, so it cannot happen that states from $\visited_\fin$ will be stuck in $\visited^1_{both}$ when evacuating.
%
%Only problem I see: evacuation may depend on state of $A$.







