\begin{proof}[Proof idea]
We separate the proof into two main constructions that will be re-used in later proofs.
Let $c = \card{B}+2$ and $n \geq c$. In the following, we will call $\largesys$ the \emph{large system}, and $\cutoffsys$ the \emph{cutoff system}.

\medskip
\noindent
Direction $\implies$:\\
Let $x=(s_1,e_1,p_1), (s_2,e_2,p_2) \ldots$ be a run \sj{should runs start with $0$ or $1$?} of $\largesys$ that satisfies $\pexists h(A,B^{(1)})$.
We can construct a run $y$ of the cutoff system $\cutoffsys$ such that $y(A, B_1)\simeq x(A, B_1)$, using the following two steps: 
\begin{enumerate}
  \item \emph{Flooding Construction}:\sj{TODO: separate flooding from other constructions}
  given a run $x$ of $\largesys$, we construct local runs $\yflood(A)$, $\yflood(B_1)$, $\yflood(B_2)$, \ldots, $\yflood(B_c)$ for the processes of the cutoff system. We let $\yflood(A,B_1) = x(A,B_1)$, ensuring that the resulting run will satisfy the property $h(A,B^{(1)})$. To ensure that all transitions of $A$ and $B_1$ are enabled, we may need other processes that are in certain local states at a given time. Let $\visited(x) \subseteq T_B$ be the set of all $B$-states that are reached in run $x$. We devote to every $q \in \visited(x)$ one copy of template $B$ that moves to state $q$ on the shortest path exhibited in $x$, and then stutters there forever. Thus, at every point in time $t$ if there is a process $B_i$ with $x_t(B_i)=q$, then we also have a process $B_j$ with $\yflood_t(B_j)=q$. Finally, if neither $A$ nor $B_1$ move infinitely often in $x$, we need to add another copy of $B$ to $\yflood$, with some local run from $x$ that moves infinitely often. All transitions of this process will be enabled by the same argument as above for $A$ and $B_1$.

\begin{figure}[h]
% \setlength{\abovecaptionskip}{-7pt plus 3pt minus 2pt} % Chosen fairly arbitrarily 
\centering
\scalebox{0.7}{
\input{img/disj_flooding_construction}
}
\caption{Illustration of the flooding construction.\ak{Add flooding of the init state}}
\label{disj:fig:FloodingConstruction}
% \vspace{-5pt}
\end{figure}
  
  \item \emph{Interleaving Construction}:
	Note that in the resulting (pseudo-)run $\yflood$ we may have steps where multiple processes move at the same time, or where no process moves. The interleaving construction converts $\yflood$ into the desired run $y$ by restoring an interleaving semantics. To this end, it may add local stuttering of one or several processes to ensure that at most one process moves at any time, and it may remove global stuttering to ensure that at least one process moves. The resulting run $y$ satisfies $y(A, B_1) \simeq x(A, B_1)$ and is not deadlocked.
\end{enumerate}


Direction $\Longleftarrow$:
By repeated application of the Monotonicity Lemma.
\end{proof}