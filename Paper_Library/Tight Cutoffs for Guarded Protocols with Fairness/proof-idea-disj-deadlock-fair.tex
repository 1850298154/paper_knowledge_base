\begin{proof}[Proof idea]
% Note that if system $\largesys$ has a global deadlock, then the fairness does not influence the cutoff, and exactly the same proof as in Lemma~\ref{le:disj:deadlocks}, case `Global Deadlocks', can be reused here (with the cutoff being $|B|$). 
% For this reason, below we consider only the case of strictly local deadlocks.
 
\sj{Need high-level version of this.} Given a deadlocked and strong-fair if infinite run $x$ of $\largesys$, we construct a deadlocked and strong-fair if infinite run $y$ of $\cutoffsys$. The proof combines the ideas from all previous proofs, in particular flooding to enable all transitions, evacuation to ensure that deadlocked states will stay deadlocked \emph{and} that all others can move infinitely often, and fair extension for those processes that are not deadlocked.
%
%\begin{enumerate}
%\item 
%Define $\visited_\bot$ to be the set of locally deadlocked states in the run $x$. 
%Further, let $\visited_\bot^1$ be the set of locally deadlocked states that are only deadlocked if there is no other process in the same state, and $\visited_\bot^2 = \visited_\bot \setminus \visited_\bot^2$, i.e., the set of states that are locally deadlocked even if there was another process in the same state. 
%Denote the set of processes of $\largesys$ that are deadlocked in $\visited_\bot^2$ by $P_\bot^2$, and those in $\visited_\bot^1$ by $P_\bot^1$. 
%Note that $\card{P_\bot^1} = \card{\visited_\bot^1} \le \card{B}$, since by definition there can be at most one process in each state.
%
%\item Re-define $\visited_\fin$\sj{usually $\visited_\fin$ is defined in terms of $\visited_\inf$}, $\first_q$, $\last_q$, $\witfirst_q, \witlast_q$ not to account for processes in $P_\bot^1$, for example $\first_q = min(\{ i \| \exists{p \not\in P_\bot^1}: s_i(B^p) = q\})$.
%Re-define $\visited_\inf = \visited \setminus (\visited_\fin \cup \visited_\bot)$.
%Note that $\visited_\fin$ may have a non-empty interection with $\visited_\bot^1$, but $\visited_\fin \cap \visited_\bot^2 = \emptyset$\ak{only if the run is infinite!}\sj{we only have to consider infinite runs; for global deadlocks, proof is the same as without fairness; but how can $\visited_\fin \cap \visited_\bot$ be non-empty? deadlocked states will stay forever, and cannot be in $\visited_\fin$}.
%
%\item Set $\yflood(p)=x(p)$ for all $p \in \{A^1\} \cup P^1_\bot$. Also:
	%\begin{enumerate}
	%\item For each state in $\visited_\fin \cup \visited_\bot^2$ devote one flooding process in $\cutoffsys$.
%% 	Note that if in the run $x$ there is no process different from $P_\bot^1$ that visits state in $\visited_\bot^1$, then we do not flood this state.
	%\item For each state in $\visited_\inf$ devote two flooding processes in $\cutoffsys$.
	%\item For all processes of $\cutoffsys$ that are not used in the previous steps: if $\visited_\inf \neq \emptyset$ (the case of a strictly local deadlock), set their local run to be equal to the local run of one of $P_\inf$ processes, else if $\visited_\inf = \emptyset$ (the case of a global deadlock), then copy the behaviour of a process in $P_\bot^2$ (such process exists since $n > |B|$).
	%\end{enumerate}
%\item Evacuate processes in states $\visited_\fin$ by applying the standard evacuation construction.
%Note that the construction does not use local runs of processes from $P_\bot^1$ since we re-defined $\last$ and $\witlast$, and hence no process evacuates into state in $\visited_\bot^1$.
%
%\item After evacuation, all $B$ processes will be in $\visited_\inf \cup \visited_\bot^2 \cup \visited_\bot^1$.
%For those in $\visited_\inf$, apply the fair extension.
%\item Finally, we use $\destutter$ and $\interleave$ as usual\ak{cannot use destutter}\sj{destutter can also result in finite paths for non-deadlocked runs; but we can just mention that a finite path means that all processes only take self-loops}.
%\end{enumerate}
%
%The resulting configuration sequence is a run of $\cutoffsys$ by correctness of the flooding, evacuation, fair extension, interleaving and destuttering constructions\ak{we can say this only if use exactly the same flooding/etc. consructions before -- i.e., don't account for processes that we copy}. 
%Furthermore, for every $q \in \visited_\bot^1$ we have exactly one process in $\cutoffsys$ that eventually stays in $q$, and for every $q \in \visited_\bot^2$ -- at least one such process; they are eventually locally deadlocked in $q$ because the states that appear infinitely often in the run $x$ of $\cutoffsys$ are the same as in the resulting run of $\largesys$.
%
%How many processes does the construction use?
%The first answer would be $|\visited_\fin| + |\visited_\bot^2| + |\visited_\bot^1| + 2|\visited_\inf| \leq 2|B|$ 
%(since $|\visited_\fin| + |\visited_\bot^1| \leq 2|\visited_\fin \cup \visited_\bot^1|$, and the sets $\visited_\bot^1 \cup \visited_\fin$, $\visited_\bot^2$, $\visited_\inf$ are disjoint).
%But we can reduce it to $2|B|-1$ (and later prove that it is tight) if analyze the cases\ak{this is crazy and should be double-checked\ldots}\sj{gist: at least one state of $B$ is in $\visited_\fin$ and is evacuated either to $\visited_\inf$ (in which case we drop one of the two other copies for that state), or into $\visited_\bot^2$ (in which case we have $3$ copies for these two states)}: 
%\begin{enumerate}
%\item 
%Process $A^1$ deadlocks. 
%Two cases are possible: $A^1$ deadlocks in a terminal state\ak{does terminal state contain transitions guarded with states of $A$?}\sj{terminal state is not defined} -- then use the standard flooding construction until $A^1$ reaches the terminal state, and then schedule processes arbitrarily strong-fair if possible. 
%This gives the cutoff $|B|$.
%
%The second case -- $A^1$ deadlocks in a non-terminal state guarded with a state $r$ of $B$ process.
%Let $uniq = \visited_\fin \oplus \visited_\bot^1$ (symmetric difference), then 
%\begin{align*}
%& |\visited_\fin| + |\visited_\bot^2| + |\visited_\bot^1| + 2|\visited_\inf| = \\
%& 2(|\visited_\fin \cap \visited_\bot^1| + |uniq| + |\visited_\bot^2| + |\visited_\inf|) - \\
%&~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ - |\visited_\bot^2| - |uniq|.
%\end{align*}
%Now note that $r \not\in \visited_\inf \cup \visited_\bot^1 \cup \visited_\bot^2$, and consider two cases: 
%i) $r \in uniq$: $|uniq|>0$ and hence the result is $\leq 2|B|-1$; 
%ii) $r \not\in uniq$: hence the result is $\leq 2|B|-2$.
%Hence, the cutoff $2|B|-1$.
%
%\item 
%Process $A^1$ moves infinitely often, and hence there is at least one $B$ process that deadlocks.
%Similarly to the previous case: if the $B$ process deadlocks in the terminal state, then $c=|B|+1$\ak{or $|B|$?}.
%Consider two cases: 
%\begin{enumerate}
%\item 
%$B$ deadlocks in state $q$ and $q \in \visited_\bot^2$.
%Hence, $|\visited_\bot^2|>1$ and the equation results in $\leq 2|B|-1$.
%
%\item 
%$B$ deadlocks in state $q$ and $q \in \visited_\bot^1$.
%If $q \in uniq$, then the equation results in $\leq 2|B|-1$.
%If $q \not\in uniq$, then $q \in \visited_\fin \cap \visited_\bot^1$.
%In this case observe that the process that visited state $q$ and then exited it in the run $x$, entered some state not in $\visited_\bot^1$ (by definition of $\visited_\fin$).
%If the process entered state in $\visited_\bot^2$, then $|\visited_\bot^2|>1$ and the equation results in $\leq 2|B|-1$.
%If the process entered state $q' \in \visited_\inf$, then modify the construction: instead of devoting two processes that flood state $q'$, devote only one process.
%This results in the cutoff $\leq 2|B|-1$.
%\end{enumerate}
%\end{enumerate}
%This concludes the proof.
\end{proof}
%----