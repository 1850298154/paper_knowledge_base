\subsection{Cutoffs for Conjunctive-Embedding Guard Systems}
\ak{not finished -- run into the problem that I could not solve.
    Originally, I wanted to put every process into every guard, 
    into the least restrictive state, 
    and then do looping, but the problem happens if the transition inside the guard is self-guarded}

\begin{restatable}[Deadlock Detection, Embedding guards]{lem}{blabla}
For 2-conjunctive-embedding systems on strong-fair initializing runs, 
with $c=???$ and any $n>c$:
  $$
  \cutoffsys \textit{ has a deadlock} 
  \ \Implied\ 
  \largesys \textit{ has a deadlock}
  $$
\end{restatable}
\begin{proof}
Given a locally deadlocked strong-fair initializing run of the \largesys, 
we construct such run in \cutoffsys.

Examples of 2-conjunctive-embedding guards: 
$\{\{a,b\}, \{a\}\}$, but not $\{\{a,b\}, \{a\}, \{b\}\}$.
I.e., all guards that are embedded into some guard are comparable with $\subset$
\footnote{Why guards like $(a,b), (a), (b)$ are more difficult and $(a,b),(b)$ are easier?
          Because if $(a,b)$ needs to blocked (but not $(a)$ or $(b)$),
          then a system run may be such that forces processes to flit $a \leftrightarrow b$ 
          when some other process goes from $\init$ to $(a,b)$.
          And if the process template has only $a \rightarrow b$, 
          then the process that goes $\init \rightarrow (a,b)$ can throw the process in $(a,b)$ 
          out of the guard 
          (first, move it $a \rightarrow b$ with transition guarded $\forall \neg a$, 
           second, move it out of $b$ with $\forall \neg b$).
          In contrast, in embedded guard systems when the process moves $\init \rightarrow (a,b)$,
          it is safe to keep the blocking process in $a$ until some moment, 
          when we can move it into $b$ and then finally out of $(a,b)$.}
Also, for now, disallow more than one level of embedding: 
if $g_1 \subset g_2$, then no other $g_i \subset g_1$.

The construction is based on three notes:
\li
\-[1.] invariant state: every cycle starts and ends with the some special state of $B$ processe, 
       called invariant state
\-[2.] abstraction of transitions inside the guard:
       instead of literal repeating how processes move inside the guard,
       we repeat only ``important'' transitions
\-[3.] loops repeat: we might need two loops from the original run of the large system
       in order to complete one loop in the cutoff system
\-[4.] there is a special case of inside-the-guard transitions
\il

We copy local runs of deadlocked processes as usual.\ak{TODO}
For the deadlocked processes to be deadlocked, 
we need to block the guards $BlockGuards' = \{ g_1, ..., g_{k'} \}$.
Some of those guards are already blocked by the deadlocked processes, 
so let $BlockGuards=\{g_1, ..., g_k\} \subseteq BlockGuards'$ denote the guards that are blocked
by infinitely moving processes of the large system.
Thus, our task is to construct a run of \cutoffsys such that:
always there is a process in some state of every $g_1,...,g_k$,
\emph{and} such processes move infinitely often.

\myparagraph{1) Invariant state}

What are the loop transitions? 
Take an inf-moving process in the large system.
It visits \init inf-often, 
and it visits some of guards $\subseteq BlockGuards$ inf-often\footnotemark[10].
Thus, for every guard $g \in BlockGuards$ there is a process of the large system
that moves $\init \rightsquigarrow g \rightsquigarrow \init$ inf-often.

There may be loops of several types. 
Consider the loop type in the figure.
In this loop, 
a process enters guard $\{a,b\}$ via state $a$ and then singleton-guard $\{b\}$.
Call this process $B_m$ (``moving'' process), 
and let $B_m'$ be the process of the cutoff system that currently copies its transitions.
When $B_m$ (and $B_m'$) is outside of $\{a,b\}$ while moving along the loop towards the guard,
in the large system there is some process that blocks the guard.
In the cutoff system, suppose we have a process $B_{a,b}'$ in state $a$ 
at the moment when $B_m$ (and thus $B_m'$) is in $\init$\footnotemark[666].

Process $B_m$ moves along the loop into the guard, 
and some transitions may be guarded $\forall\neg b$\footnotemark[20]
(that is why we cannot place $B_{a,b}'$ into $b$).
What we would like is to move $B_m'$ into $\{a,b\}$ by copying transitions of $B_m$,
then move $B_{a,b}'$ out of $\{a,b\}$ using transitions of $B_m$,
while leaving $B_m'$ in ${a,b}$.

Note 1: if process $B_{a,b}'$ stays in $a$ until process $B_m'$ (and $B_m$) reaches $a$,
then the transitions of $B_m'$ on path $\init \rightsquigarrow a$ are enabled.
However, keeping $B_{a,b}$ in $a$ may result in disabling the subsequent transition
of $B_m$ from $a$ into $b$
(imagine $B_m$ does $\transition{a}{b}{\forall\neg \{a,b\}}$ ---
 $B_{a,b}'$ of the cutoff system cannot repeat this).

Since $B_m$ reaches $a$ (and has a transition guarded $\forall \neg b$), 
there is the last moment in the path $\init \rightsquigarrow a$ 
when $\forall \neg b$ needs to be enabled\footnotemark[200].
After that moment, we can move $B_{a,b}'$ from $a$ into $b$.
But this transition should be enabled.
Now two cases are possible:
\li
\- the transition $a \rightarrow b$ becomes enabled 
   while $B_m$ moves $\init \rightsquigarrow a$.
   Hence, we move process $B_{a,b}'$ when this happens for the last time.
   \footnotemark[333]

\- the transition $a \rightarrow b$ became enabled 
   before $B_m$ started $\init \rightsquigarrow a$.
\il

\hl{the following scenario is problemic: 
    imagine in the large system:
    $B_{a,b}$ stays in $a$, until $B_m$ reaches $a$, 
    then $B_{a,b}$ goes outside for a moment -- $B_m$ goes into $b$ -- $B_{a,b}$ returns into $a$, 
    and finally $B_m$ leaves.
    Later, $B_{a,b}$ will move to make it strong-fair. 
    Here is the picture ($a \rightarrow b$ is guarded $\forall \neg \{a,b\}$):}
    \includegraphics[width=2.5cm]{img/embedded-guards-problem.png}











\footnotetext[10]{If no such processes exists, copy one such process, and we are done.}
\footnotetext[20]{If no such transitions exists, we put $B_{a,b}$ into $b$, 
                  and the construction is similar to 1-conj guards looping, 
                  because the processes can pass the baton of copying $B_m$ when they meet in $b$.
                  Almost: what if there is $\transition{}{}{\forall\neg \{a,b\}}$?\ak{todo}}
\footnotetext[200]{\ak{account for the case when it was enabled before we started from \init}}
\footnotetext[333]{\ak{Here we use the assumption that process $B_{a,b}$ 
                       (of the large system) moved $a \rightarrow b$.}}
\footnotetext[666]{Careful here -- account for different schedulings and possibilities.}























\end{proof}
