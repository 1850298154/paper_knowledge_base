\subsection{Cutoffs for 2-Conjunctive-Disjoint Guard Systems}
\ak{finished, but not polished}

\begin{restatable}[Deadlock Detection, 2-Disjoint Guards]{lem}{blabla}
For 2-conjunctive-disjoint systems on strong-fair initializing runs, 
with $c\approx 2|Q_B \smi \{\init\}|$\ak{calc} and any $n>c$:
  $$
  \cutoffsys \textit{ has a deadlock} 
  \ \Implied\ 
  \largesys \textit{ has a deadlock}
  $$
\end{restatable}
\begin{proof}
%
$BlockGuards$ are the guards that are not blocked by the deadlocked processes,
and, thus, must be blocked for the local deadlocks to occur.

Inf-moving processes visit such guards by looping 
$\init \rightsquigarrow \init$.
Thus, through every guard some process goes inf-often.
Link with a guard a process of the large system, called $B_m$, 
that visits it inf-often.

Roughly, the idea of the construction is the following.
We devote one process that starts in $\init$.
For every blocking guard, in the cutoff system, 
a process called $B_m'$ will emulate a loop 
$\init \rightsquigarrow \init$ of process $B_m$ of the large system.
In the loop of the process $B_m$, 
blocking guard states are visited in some order: 
some states are entered through and some are exited through.
First, we ensure that there is a process in every ``exit'' state of every 
blocking guard on the loop of $B_m$.
Second, let $B_m'$ mimick transitions of $B_m$ till it reaches the first
``enter'' state, 
then let the process, that is currently in the ``exit'' state, 
continue mimicking the transitions of $B_m$, and so on.
This way we reach the blocking guard under consideration and then reach $\init$.

The realitiy is more involved: 
the main complication is that the same blocking guard may be visited 
several times, thus, strictly speaking, ``enter'' and ``exit'' states
are not well-defined in the above.
Below we decribe the details.

\smallskip
\noindent
\emph{Notes.}
Since there is only a finite number of transitions and blocking guards 
but runs are infinite, after some moment:
\li
\-[1.] Any loop's transition fires inf-often.
\-[2.] Any loop's path between two blocking guards fire inf-often.
\il

Below we consider only such looping paths.

\smallskip
\noindent
\emph{Simplification.}
Given a blocking guard $g$ and a loop that visits $g$, 
divide the loop into three parts:
\li
\- $\init \rightsquigarrow g$ 
   (from $\init$ until the first visit of $g$),
\- $g \rightsquigarrow g$ 
   (from the first visit of $g$ until the last visit), and
\- $g \rightsquigarrow \init$ 
   (from the last visit until $\init$).
\il

Given a guard and a part, \emph{enter[exit]} state is 
the first[last] state of the guard visited on the path.
For the middle part, 
this equivalents to the first[last] state of the path.

Now the \emph{simplification}.
Given a part of the loop, 
remove all loops from the part that start and end in the same state.
Apply this to the first, middle, and last part.

% do we really need the simplification?
% > yes, due to several times firing of the internal transition of a guard
% > and we really need both: simplificaiton of inter- and intra-guard transitions,
% > because:
% 1. internal transition may be fired several times 
%    without visiting other blocking guards:
%    +-----+
%    |     |
%    [guard]
%
% 2. internal transition may be fired several times 
%    within the same guard:
%    +---------+
%    | .<--->. | (guard)
%    +---------+ 

Call the loop consisting of the simplified first, middle and last parts,
the \emph{simplified loop}.
Then, the simplification ensures:
\li
\- for every simplified part: 
   a blocking guard $g$ can be visited more than once
   only if $enter_g \neq exit_g$
   and the internal transitions of $g$ are not used.

\- in the simplified loop:
   if an internal blocking guard transition is fired more than once,
   then the firings are separated by a visit of another blocking guard.
\il

\smallskip
\noindent
\emph{Preparation.}
Fix a part of the simplified loop (first, middle, or last).
In this part, for each guard $g$, the transition through $g$ 
is of the form:
\li
\-[f1.] $enter \rightarrow exit$ ($g$ is visited once), or
\-[f2.] $enter \rightarrow \neg g \rightsquigarrow exit$ ($g$ is visited twice).
\il
%If the target guard $guard$ visit is of the first type, then,
%according to the notes, $enter \rightarrow exit$ is fired inf-often.
Given a blocking guard $g$ visited in the part,
the \emph{preparation of $g$ wrt. the part} is:
if transition through $g$ is of the second form -- do nothing,
if of the first form -- wait until the transition is fired
in the original run of the large system, then execute it.
The preparation ensures:
\li
\- if the process $B_g'$ is in state $enter$, 
   then in the part the transition through the guard is of the second form.
\il

\smallskip
\noindent
\emph{Main construction.}
For each blocking guard, fix a loop that visits it inf-often.
Fix a blocking guard $guard$, called the target guard, and, thus, fix the loop.
Derive the simplified loop.
Let the simplified loop be of the form:
$$ 
\underbrace{\init \ g_1' \ ... \ g_f'}_\text{the first part} \ 
\underbrace{g^\star \ g_1'' \ ... \ g_m'' \ g^\star}_\text{the middle part} \ 
\underbrace{g_1''' \ ... \ g_l''' \ \init}_\text{the last part}
$$
In the above formula, $f$, $m$, or $l$ can be $0$, but for simplicity
consider they are not.

%Prepare all processes, one by one, of the blocking guards visited in the first part 
%wrt. the first part,
%and the process of the target guard wrt. middle part.
%This ensures,
%for every $g$, 
%which is a blocking guard of the first part or the target guard,
%$B_{g}'$ is either in $exit$ or
%internal transitions of $g$ are not fired in the corresponding part.
%\footnotemark[1000].

Start with $\init$ and the process $B_\init'$.
Call the process of the cutoff system, we currently move, $B_m'$.
Initially $B_m'$ is $B_\init$.
Prepare the process in $g_1'$ wrt. the first part.
Make $B_m'$ mimick $B_m$ until it reaches $g_1'$:
\li
\- if transition through $g_1'$ in the first part is of form (f2),
   then let $B_m'$ continue mimicking $B_m$ until it reaches 
   the next blocking guard
\- if transition through $g_1'$ in the first part if of form (f1),
   then leave $B_m'$ in $enter_{g_1'}$, wait until $B_m$ reaches $exit_{g_1'}$ 
   (this ensures that we do not transit inside the guard 
   when there is another process, $B_{exit_{g_1'}}$, in it).
   Then, prepare the next blocking guard wrt. the corresponding part.
   Set $B_m' = B_{exit_{g_1'}}$.
   Then, let $B_m'$ mimick $B_m$ until it reaches the next blocking guard.
\il
Repeat this construction in a natural way until $B_m'$ reaches $\init$.

For a given target guard $g^\star$, the main construction ensures that the process 
$B_{g^\star}$ moves to the next blocking guard $g$ on the simplified loop.
But we need to ensure that $B_{q^\star}$ eventually reaches $\init$.
To this end, set $g^\star=g$ and repeat the construction.
And so on, until the desired process reaches $\init$.
Finally, do this for every blocking guard.

This concludes the description of the main construction.

Note: the setup phase of the main construction, 
      where we put one process into every blocking guard and 
      one or two processes into every deadlocked state,
      is straightforward.

Finally, the cutoff is defined by the maximal number of the blocking guards + 1,
and is of the scale $\approx 2|Q_B\smi\{\init\}|$.
\end{proof}
