\begin{proof}
Suppose run $x= (s_0,e_0,p_0),(s_1,e_1,p_1),\ldots$ of $\largesys$ is locally deadlocked for at least one process, and at least one process keeps on moving forever. 
We construct a run $y= (s^*_0,e^*_0,p^*_0),(s^*_1,e^*_1,p^*_1),\ldots$ where at least one process deadlocks and at least one process moves on forever in the following way.

Let $y(A^1,B^1)=x(A^1,B^j)$, where $j$ is chosen such that either $A^1$ moves infinitely often and $B^j$ deadlocks, or the other way around. Let $U^1$ denote the deadlocked process in $\cutoffsys$.

Then, let $d$ be the point in time from which $A^1$ or $B^i$ are disabled 
forever in $x$. To ensure that all transitions of $U^1$ are disabled in $s_d$ 
of $\cutoffsys$, let $I = \{ i | s_d(B^i) = q \textit{ for some } q \in 
Set(s_d,B)\}$, let $pr: I \rightarrow [2:\card{Set(s_d,B)}]$, and define $y(B^{pr(i)
}) = x(B^i)$ for all $i \in I$. In the following, we want to ensure that: a) 
$U^1$ will always remain deadlocked, and b) all transitions on local run 
$y(\overline{U}^1)$ are enabled. To ensure a), it is sufficient to ensure that 
$Set(s^*_\time,B) \supseteq Set(s_\time,B)$, and to ensure b), it is sufficient to ensure $Set(s^*_\time,B) \subseteq Set(s_\time,B)$. 
Thus, the goal of our 
construction is to ensure $Set(s^*_\time,B) = Set(s_\time,B)$ for all $\time 
\ge d$.\ak{What is $Set$? Is a set of states or set of sets?}

For a transition of $\largesys$ where $A^1$ or $B^j$ move, we fire the same transition in $\cutoffsys$. Otherwise, consider the following cases for a transition of $\largesys$ from $s_\time$ to $s_{\time+1}$:\sj{formally, this is probably a (0,1,many)-counter abstraction}
\begin{enumerate}
\item $Set(s_{\time+1},B) = Set(s_\time,B)$: we drop this transition in $\cutoffsys$, unless it leads to the situation that only one process is in the state that was left in the original transition\sj{i.e., unless it changes the state in the abstraction}; in that case, let all but one processes move along that transition
\item $Set(s_{\time+1},B) = (Set(s_\time,B) \setminus \{ q \}) \cup \{q'\}$ for some $q \in Set(s_\time,B)$, $q' \not\in Set(s_\time,B)$: we simulate the transition from $q$ to $q'$ with the unique process in $\cutoffsys$ that is in state $q$
\item $Set(s_{\time+1},B) = Set(s_\time,B) \setminus \{ q \}$ for some $q \in Set(s_\time,B)$: we simulate the transition from $q$ to a state $q' \in Set(s_{\time+1},B)$ with the unique process in $\cutoffsys$ that is in state $q$
\item $Set(s_{\time+1},B) = (Set(s_\time,B) \cup \{q\}$ for some $q \not\in Set(s_\time,B)$: if possible, we simulate this by a number of transitions from a state $q'$ to $q$, where multiple processes are in $q'$; if this is not possible, we add another local run: $y(B^{c+1})=x(B^i)$ for some $i$ with $s_{\time+1}(B^i) = q$.
\end{enumerate}

Using this construction, we simulate $\largesys$ in $\cutoffsys$ until we have 
reached $\time$ such that there exists $\time'$ with $d < \time' < \time$ and 
$s_\time'=s_\time$. The maximal length of a subsequence of $x$ such that 
$s_\time \neq s_{\time'}$ for all $x_\time,x_\time'$ is bounded by $\card{B}^n$. 
However, we only simulate steps where $Set(s_\time,B)$ changes, or where all 
but one processes move out of a state. Furthermore, we can remove loops 
within the abstraction, i.e., if there are $\time,\time'$ such that 
$Set(s^*_\time)=Set(s^*_{\time'})$, then we cut $x^*[\time+1:\time']$ from the run. 
Thus, there are at most $3^{\card{B}}$ different abstract configurations that 
can be reached on such a path. The number of steps of case d) that add 
another run is thus bounded by $3^{\card{B}}$.\sj{somewhat better cutoff possible, but probably not worth the effort...}

Note that the abstract state at the end of this loop is the same as in the original configuration, and therefore arbitrarily many executions of the loop can be appended.
\end{proof}