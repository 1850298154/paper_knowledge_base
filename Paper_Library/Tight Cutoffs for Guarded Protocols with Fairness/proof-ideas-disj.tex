\section{Proof Techniques for Disjunctive Systems}
\label{sec:ideas-disj}
\ak{to simplify the notation, can we remove `$(x)$' in $\visInf{\mB}{x}$?} \sj{I think it is much clearer if we leave it - the notation is self-explanatory currently}

\subsection{\LTLmX\ Properties without Fairness: Existing Constructions}
%\paragraph*{\LTLmX\ Properties without Fairness}
\label{sec:ideas-disj-nofair}

We revisit the main technique of the original proof 
of Theorem~\ref{thm:disj-cutoff-pairs}~\cite{Emerson00}. 
It constructs an infinite run $y$ of $\cutoffsys$ 
with $y \models h(A,B^{(1)})$, 
based on an infinite run $x$ of $\largesys$ with $n>c$ and $x \models h(A,B^{(1)})$. 
The idea is to copy local runs $x(A)$ and $x(B_1)$ into $y$, 
and construct runs of other processes in a way 
that enables all transitions along $x(A)$ and $x(B_1)$. 
The latter is achieved with the flooding construction.

\myparagraph{Flooding Construction \cite{Emerson00}}
Given a run $x = (s_1,e_1,p_1), (s_2,e_2,p_2) \ldots$ of $\largesys$, let
$\visited_\mB(x)$ be the set of all local states visited by $B$-processes in $x$,
i.e., $\visited_\mB(x) = \{ q \in Q_B \| \exists m \exists i.\ s_m(B_i) = q \}$. 

For every $q \in \visited_\mB(x)$ there is a local run of \largesys, say $x(B_i)$,
that visits $q$ first, say at moment $m_q$. Then, saying that process 
$B_{i_q}$ of \cutoffsys \emph{floods $q$} means:
$$y(B_{i_q}) = x(B_i)\slice{1}{m_q}(q)^\omega.$$ 
In words: the run $y(B_{i_q})$ is the same as $x(B_i)$ until moment $\time_q$,
and after that the process never moves.

The construction achieves the following. 
If we copy local runs of $A$ and $B_1$ from $x$ to $y$, 
and in $y$ for every $q \in \visited_\mB(x)$ introduce one process that floods $q$, 
then: 
if in $x$ at some moment $\time$ there is a process in state $q'$, 
then in $y$ at moment $\time$ there will also be a process (different from 
$A$ and $B_1$) in state $q'$. Thus, every transition of $A$
 and $B_1$, which is enabled at moment $\time$ in $x$, will also be enabled in $y$. 

%\begin{proof}[Proof idea of the bounding lemma]
\myparagraph{Proof idea of the bounding lemma}
The lemma for disjunctive systems without fairness can be proved by
copying local runs $x(A)$ and $x(B_1)$, and flooding all states in
$\visited_\mB(x)$. To ensure that at least one process moves infinitely often
in $y$, we copy one additional (infinite) local run from $x$. Finally, it may
happen that the resulting collection of local runs violates the interleaving 
semantics requirement. To resolve this, we add stuttering steps into local 
runs whenever two or more processes move at the same time, and we 
remove global stuttering steps in $y$. Since the only difference between 
$x(A,B_1)$ and $y(A,B_1)$ are stuttering steps, $y$ and $x$ satisfy the same $
\LTLmX$-properties $h(A,B^{(1)})$. 
Since $\card{\visited_\mB(x)} \leq 
\card{B}$, we need at most $1+\card{B}+1$ copies of $B$ in \cutoffsys.
%\end{proof}



\subsection{\LTLmX\ Properties with Fairness: New Constructions}
%\paragraph*{\LTLmX\ Properties with Fairness}
\label{sec:ideas-disj-fair}

The flooding construction does not preserve fairness, 
 and also cannot be used to construct deadlocked runs since it does not 
preserve  disabledness of transitions of processes $A$ or $B_1$. 
For these cases, we provide new proof constructions.

Consider the proof task of the bounding lemma for disjunctive systems with 
fairness: given an unconditionally fair run $x$ of 
\largesys with 
$x \models h(A,B^{(1)})$, we want to construct an unconditionally fair run $y$ 
of \cutoffsys with $y \models h(A,B^{(1)})$. In contrast to unfair systems, we 
need to ensure that all processes move infinitely often in $y$. 
The insight is 
that after a finite time all processes will start looping 
around some set $\visited^\inf$ of states. We construct a run $y$ that
mimics this. To this end, we introduce two constructions. \emph{Flooding with
evacuation} is similar to flooding, but instead of keeping
processes in their flooding states forever it evacuates the processes into 
$\visited^\inf$. \emph{Fair extension} lets all processes move infinitely 
often without leaving $\visited^\inf$.

\myparagraph{Flooding with Evacuation}
\input{flooding-with-evacuation}

\myparagraph{Fair Extension} 
\ak{explain intuition about those three sets}
\input{fair_extension}
%\begin{proof}[Proof idea of the bounding lemma]

\myparagraph{Proof idea of the bounding lemma}
\input{proof-disj-bounding-fair}
%\end{proof}


\subsection{Detection of Local and Global Deadlocks: New Constructions}
\label{sec:ideas-disj-deadlock}
%\paragraph*{Detection of Local and Global Deadlocks}

\myparagraphraw{Monotonicity Lemmas.}
The lemma for deadlock detection, for fair and unfair cases,
is proven for $n \geq |B|+1$.
In the case of local deadlocks, 
process $B_{n+1}$ mimics a process that moves infinitely often in $x$.
In the case of global deadlocks, 
by pigeon hole principle, 
in the global deadlock state there is a state $q$ with at least two processes in it---let process $B_{n+1}$ mimic a process that deadlocks in $q$.

\myparagraphraw{Bounding Lemmas.}
For the case of global deadlocks, fairness does not affect the proof of the bounding lemma. 
The insight is to divide deadlocked local states into two disjoint sets, 
$\dead_1$ and $\dead_2$, as follows.
Given a globally deadlocked run $x$ of \largesys, 
for every $q \in \dead_1$, 
there is a process of \largesys deadlocked in $q$ with input $i$,
that has an outgoing transition guarded ``$\exists q$''
-- hence, adding one more process into $q$ would unlock the process.
%\sj{do we always consider inputs correctly? what if $q \in \dead_1$ for some $e$, but $q \in \dead_2$ for $e'$?}\ak{thanks, modified, now it is impossible}
In contrast, $q \in \dead_2$ if any process deadlocked in $q$
stays deadlocked after adding more processes into $q$.
Let us denote the set of $B$-processes deadlocked in $\dead_1$ by $\mD_1$.
Finally, abuse the definition in Eq.~\ref{disj:def_vfin_wrt}
and denote by $\visFin{\mB\smi\mD_1}{x}$ the set of states
that are visited by $B$-processes not in $\mD_1$ before reaching a deadlocked state.

Given a globally deadlocked run $x$ of \largesys with $n\geq 2|B|-1$, 
we construct a globally deadlocked run $y$ of \cutoffsys with $c = 2|B|-1$ as follows:
\li
\- copy from $x$ into $y$ the local runs of processes in $\mD_1 \cup \{A\}$
\- flood every state of $\dead_2$
\- for every $q \in \visFin{\mB\smi\mD_1}{x}$, flood $q$ and evacuate into $\dead_2$.
\il
The construction ensures: 
(1) for any moment and any process in $y$,
    the set of local states that are visible to the process includes all the states that were visible 
    to the corresponding process in \largesys whose transitions we copy;
(2) in $y$, there is a moment when all processes deadlock in $\dead_1 \cup \dead_2$.

For the case of local deadlocks, 
the construction is similar but slightly more involved, 
and needs to distinguish between unfair and fair cases.
%The construction for local deadlocks is similar but slightly more involved, and needs to distinguish between unfair and fair cases.
In the unfair case, we also copy the behaviour of an infinitely moving process. 
In the strong-fair case,
we continue the runs of non-deadlocked processes with the fair extension. 
\iffinal \else See details in Appendix~\ref{sec:app-disj}.\fi

\ak{put here the tightness picture for deadlocks under fairness?}

%--- global deadlocks: fair and unfair:
%C: processes that dead1
%F: processes that dead2
%We copy local runs of dead1.
%We flood deadlocked states of dead2, and flood and evacuate non-deadlocked states of dead2.
%
%--- local deadlocks: unfair:
%I: processes that move infinitely often
%D: processes that dead
%copy local run of one process from I, 
%copy one local run of process from C,
%flood and evacuate finitely visited states by processes except copied
%
%--- local deadlocks: fair:
%I: processes that move infinitely often
%C: processes that dead1
%F: processes that dead2
%Copy local runs of C, 
%flood and evacuate finitely visited states of F\\C, 
%flood dead or infinitely often visited states of F\\C.
