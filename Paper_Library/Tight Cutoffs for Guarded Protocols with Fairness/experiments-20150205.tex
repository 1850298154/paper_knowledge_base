\section{Experiments}
\label{sec:experiments}

We used our new cutoff results in the context of parameterized synthesis to 
automatically construct guarded protocols with safety and lifeness guarantees 
for systems with an arbitrary number of components.
Our prototype is an extension of the parameterized synthesis tool {\sc Party}~\cite{Khalimov13a}.
It synthesizes guarded protocols using the following loop, for increasing 
bounds $(\bound_A,\bound_B)$ on the size of process templates:
\begin{enumerate}
\item[0.] initialize: set $(\bound_A,\bound_B)=(2,2)$
\item \label{enum:experimentsAlgorithm:propertyInst} automatically detect 
cutoff and instantiate specification
\item \label{enum:experimentsAlgorithm:ltl3ba} convert $\LTLmX$ specification into automaton
\item \label{enum:experimentsAlgorithm:enc} encode bounded template synthesis problem into SMT, check satisfiability
\item if SAT: return model of process templates; else increase $(\bound_A,\bound_B)$ and goto 1
% \begin{itemize}[leftmargin=*]
% \item if SAT, convert SMT model into process templates
% \item if UNSAT, increase size bound and goto 1
% \end{itemize}
\end{enumerate}
%
%In the cutoff detection step, we apply the cutoff results from 
%Section~\ref{sec:cutoffs} modularly, i.e., we calculate cutoffs and convert 
%to universal co-BÃ¼chi tree automaton (UCT)\sj{remind/use long version} for every conjunct of the specification separately (an optimization 
%mentioned in~\cite{KhalimovJB13b}). Finally, we produce the SMT encoding, 
%conjoining the SMT constraints for all parts. 
%
The method supports modular application of cutoffs for different properties and deadlock detection (cf. \cite{KhalimovJB13b}). For our evaluation, we selected one example for each guard type, and synthesized valid implementations, starting from an initial size bound of 2 for each template. 
%We analyzed the impact of cutoffs by comparing the algorithm's runtime for synthesis with and without cutoffs with respect to an increasing number of instances. In both cases, we used the symmetry observation for encoding the properties, e.g., in a system with 4 processes the property $\bigwedge_i \always(r_i \rightarrow \eventually g_i)$ is instantiated to $\always(r_1 \rightarrow \eventually g_1)$ instead of  $\always(r_1 \rightarrow \eventually g_1) \wedge \dots \wedge \always(r_4 \rightarrow \eventually g_4)$. \sa{Label vs. state -- should be no difference here}
The experiments were done on a Linux machine with a 3.5GHz Intel i7 CPU and 4GB RAM, where a single core was assigned to the synthesis task. Table~\ref{table:experimentsRuntimes} provides the runtimes resulting from our experiments.
We observe for each guard type that the runtime increases rapidly regarding the system size $n$. Applying cutoffs entails an upper bound for the the runtime, making the synthesis of large systems feasible. 

%\begin{table}
%\centering
%\caption{Impact of using cut-offs on synthesis runtime $[s]$, timeout=90min.}
%\label{table:experimentsRuntimes}
%\begin{tabular}{c|c|c|c|c|c|c|}
    %& \multicolumn{2}{c|}{\multirow{2}{*}{Disjunctive Guards}} & \multicolumn{4}{c|}{Conjunctive Guards} \\
%% 		\cline{4-9}
    %& \multicolumn{2}{c|}{} & \multicolumn{2}{c|}{Example 1} & \multicolumn{2}{c|}{Example 2} \\\hline
%$n$ & w/o cut-offs & with cut-offs & w/o cut-offs & with cut-offs & w/o cut-offs & with cut-offs \\\hline
%% 1 & $2.0$   & $2.0$     & $-$    & $-$     \\\hline         & $-$      \\\hline        
%2 & \multicolumn{2}{c|}{1.52}      & \multicolumn{2}{c|}{2.08}  & \multicolumn{2}{c|}{26.6}   \\\hline 
%3 & \multicolumn{2}{c|}{4.1}       & 8.79    & 4.83     & \multicolumn{2}{c|}{590.5}   \\\hline
%4 & \multicolumn{2}{c|}{12.1}      & 42.2    & 4.83    & TIMEOUT & 2819.2  \\\hline
%5 & 41.18    & 41.18              & 230     & 4.83    & TIMEOUT & 2819.2  \\\hline
%6 & 149.83    & 41.18              & 2113    & 4.83    & TIMEOUT & 2819.2  \\\hline
%7 & 481.06    & 41.18              & TIMEOUT & 4.83    & TIMEOUT & 2819.2  \\\hline
%8 & 1650      & 41.18              & TIMEOUT & 4.83    & TIMEOUT & 2819.2  \\\hline
%9 & TIMEOUT   & 41.18              & TIMEOUT & 4.83    & TIMEOUT & 2819.2  \\\hline
%\end{tabular}
%%\vspace{-13pt}
%\end{table}

\begin{figure}[Htb]
\centering
\subfloat[Impact of using cut-offs on synthesis runtime s, timeout=90min.]{
%\centering
\makebox[0.45\textwidth][c]{
\scalebox{0.85}{
\centering
\begin{tabular}{c|c|c|c|c|}
    & \multicolumn{2}{c|}{\multirow{2}{*}{Disjunctive Guards}} & \multicolumn{2}{c|}{Conjunctive Guards} \\
% 		\cline{4-9}
$n$ & w/o cut-offs & with cut-offs & w/o cut-offs & with cut-offs \\\hline
% 1 & $2.0$   & $2.0$     & $-$    & $-$     \\\hline         & $-$      \\\hline        
2 & \multicolumn{2}{c|}{1.53}      & \multicolumn{2}{c|}{8.78}   \\\hline 
3 & \multicolumn{2}{c|}{8.42}      & \multicolumn{2}{c|}{65.34}   \\\hline
4 & \multicolumn{2}{c|}{80}        & TIMEOUT & 1085.8 \\\hline
5 & \multicolumn{2}{c|}{TIMEOUT}   &  \multicolumn{2}{c|}{TIMEOUT} \\\hline
6 & \multicolumn{2}{c|}{TIMEOUT}   & \multicolumn{2}{c|}{TIMEOUT}  \\\hline
7 & \multicolumn{2}{c|}{TIMEOUT}   & \multicolumn{2}{c|}{TIMEOUT}  \\\hline
8 & \multicolumn{2}{c|}{TIMEOUT}   & \multicolumn{2}{c|}{TIMEOUT}  \\\hline
9 & \multicolumn{2}{c|}{TIMEOUT}   & \multicolumn{2}{c|}{TIMEOUT}  \\\hline
\end{tabular}}
\label{table:experimentsRuntimes}
}}
%\qquad
%\subfloat[Example 2]{
%\makebox[0.28\textwidth][c]{
%\scalebox{0.85}{\input{img/mutual_exclusion2_lts}}
%\label{fig:conjunctiveLTS2}
%}}
\qquad
\subfloat[Runtime Chart]{
\makebox[0.45\textwidth][c]{
\raisebox{-6em}{\scalebox{0.20}{\includegraphics{img/experiments.pdf}}}
\label{fig:conjunctiveLTS3}
}}
%
\end{figure}


%\begin{table}
%\centering
%\caption{Impact of synthesizing label-based guards on runtime of conjunctive guards synthesis $[s]$, timeout=90min.}
%\label{table:experimentsGuardTypeRuntimes}
%\begin{tabular}{c|c|c}
%$n$  & state guards    & label guards  \\\hline
%% 1    & $-$             & $-$           \\\hline
%2    & $10.7$          & $8.5$         \\\hline
%3    & $1090$          & $79.3$        \\\hline
%4    & TIMEOUT         & $1040$        \\\hline
%% 5    & TIMEOUT         & TIMEOUT       \\\hline
%\end{tabular}
%\end{table}

\smartpar{Disjunctive Guards.}
We want to obtain a closed system $\largesys$, where $A$ controls an output signal $w$, and every $B^i$ a signal $g_i$. 
The specification is 
$\GF(\neg w) \wedge \GF w \wedge \bigwedge_{i} \left[\GF(w \wedge g_i) \wedge  \GF g_i \wedge \GF(\neg g_i) \right]$ under fair scheduling, i.e., all processes most toggle their signals infinitely often, and every process $B^i$ must ``meet'' infinitely often with $A$ when both signals are enabled.
%  
%\begin{figure}[ht]
%\vspace{-10pt} 
%\centering
%\scalebox{0.75}{\input{img/disjunctive_lts}}
%\caption{Example: Disjunctive Guarded Implementation}
%\label{fig:disjunctiveLTS}
%\vspace{-10pt} 
%\end{figure}
\rb{bad name $a^1$? you use it to denote $i$th process} \sj{make it $1_A$, $2_A$, $1_B$, \ldots?}
Figure~\ref{fig:disjunctiveLTS} shows an implementation synthesized.
For this example, the cutoff for deadlock detection is $5$, and the cutoff for the $\LTLmX$-property is $6$. \rb{why? -- mistake, also explain} \sa{corrected}. Accordingly, Table~\ref{table:experimentsRuntimes} shows that cutoffs do not improve runtimes for systems with $n\leq 5$, but for $n \ge 5$ the cutoff approach has a constant runtime, since the generated templates are guaranteed to be correct for any bigger system.
\rb{example is not realistic -- is there a more realistic?} \sa{Unfortunately, we have a timeout before any cutoff comes into play.}


\smartpar{Conjunctive Guards.}\rb{add `Fair'?}
We want to obtain fair open systems $(B)^{(n)}$ with a single process template $B$ (i.e., $A$ can be arbitrary and $B$ does not react to it), based on the example mentioned in the introduction.
In the specification, each $B^i$ has input $r_i$\rb{$r^i$?} (`request') and output $g_i$ (`grant'). 
The specification requires: i) `every request should be granted', ii) `there should be no spurious grants', iii) mutual exclusion of grants, and iv) before granting, the process enters a trying state. To make the trying state observable, each process has an additional output $t_i$ that is raised if the process is in the trying state.
% Each process must respond to a request by finally setting the grant signal. 
% Besides guaranteeing mutual exclusion, spurious grants must be prevented.
% \begin{align*}
% &\bigwedge_i \always(r_i \wedge \sched_i \rightarrow \eventually g_i) \wedge \bigwedge_{i \neq j} \always(\neg(g_i \wedge g_j))\, \wedge\\ 
% &\bigwedge_i \always\left[g_i \rightarrow g_i \until (\neg g_i \weakuntil (r_i \wedge \sched_i))\right] \wedge\\
% &\bigwedge_i \neg\left[(\neg r_i \wedge \neg g_i) \until (\neg r_i \wedge g_i)\right]
% \end{align*}
% Predicate $\sched_i$ is used to specify that only requests which can be recognized by the process (i.e., if the process is scheduled) need to be granted.
% 
% \begin{figure}[ht]
%\begin{figure}[Htb]
%\centering
%\subfloat[Example 1]{
%\centering
%\makebox[0.29\textwidth][c]{
%\scalebox{0.85}{\input{img/mutual_exclusion_lts}}
%\label{fig:conjunctiveLTS1}
%}}
%%\qquad
%%\subfloat[Example 2]{
%%\makebox[0.28\textwidth][c]{
%%\scalebox{0.85}{\input{img/mutual_exclusion2_lts}}
%%\label{fig:conjunctiveLTS2}
%%}}
%\qquad
%\subfloat[Example 2]{
%\makebox[0.28\textwidth][c]{
%\scalebox{0.85}{\input{img/mutual_exclusion3_lts}}
%\label{fig:conjunctiveLTS3}
%}}
%%
%\caption{Conjunctive Guarded Implementations}
%\label{fig:conjunctiveLTS}
%\end{figure}
\begin{figure}[Htb]
\subfloat[Disjunctive Guarded Implementation]{
\centering
\makebox[0.6\textwidth][c]{
\scalebox{0.85}{\input{img/disjunctive_lts}}
\label{fig:disjunctiveLTS}
}}
\qquad
\subfloat[Conjunctive Guarded Implementation]{
\centering
\makebox[0.29\textwidth][c]{
\scalebox{0.85}{\input{img/mutual_exclusion_trying}}
\label{fig:conjunctiveLTS1}
}}
%
\caption{Example Implementations}
\label{fig:examples}
\end{figure}
Figure~\ref{fig:conjunctiveLTS1} shows an implementation synthesized.
%$t_0$ denotes the initial state. Consider a certain process $i$. Whenever the process is scheduled and the request signal $r_i$ is set, the transition to state $t_1$ is enabled. Thus, the process moves to $t_1$ and remains in this state as long as the guard $\{t_0, t_1\}$ is not satisfied, i.e., if there is at least on other process in the critical state $t_2$. Eventually all other processes are either in $t_0$ or in $t_1$, and process $i$ moves from $t_1$ to $t_2$, thus grants the request it received in state $t_0$. The grant signal $g_i$ is set until process $i$ is scheduled again, then it moves back to the initial state, where $g_i$ is false. The example requires at least three states. %\sa{Insert graph here}
%We managed to synthesize this under the following conditions: \ldots
For this example, the cutoff for properties is $ \leq 3$, and for local deadlock detection it is $4$ (for implementations of size $3$). Accordingly, the table shows some benefit of the cutoff method already for $n=4$.

%The second example defines one request signals $r$, and a two grant signals $g_1$, and $g_2$. The properties are as follows: i) `every request $r$ should finally be granted by $g_1$, followed by $g_2$', ii) `there should be no spurious grants', iii) `mutual exclusion of grants'.
%%
%Figure~\ref{fig:conjunctiveLTS2} shows an implementation synthesized. The cutoff for single-indexed and double-indexed properties is 1, and 2, respectively. The deadlock detection cutoff is $c=3$.

\rb{not clear -- how is this parameterized?}%The second example defines two request signals $r_1$, $r_2$, and a two grant signals $g_1$, and $g_2$. The properties are as follows: i) `every request $r_1$ should eventually be granted ($g_1$)', ii) `every request $r_2$ should eventually be granted ($g_2$) unless resource 1 is requested ($r_1$)', iii) `there should be no spurious grants', iv) `mutual exclusion of grants'. Figure~\ref{fig:conjunctiveLTS3} shows an implementation which satisfies the given specification. As before, we modularly use the cutoff $3$ for properties, and $4$ for deadlock detection. Note that we do not restrict synthesis to $1$-guarded processes, and therefore the cutoff does not guarantee absence of local deadlocks (although manual inspection shows that local deadlocks are not possible with the resulting implementation).

%Finally, we compared the performance of the synthesis algorithm wrt. guards based on i) labels and ii) on states, as mentioned in Section~\ref{sec:adapted}. We observed a speed-up of an order of magnitude when only considering label-based guards, but thus far have only evaluated it on the single example above.

% we analyzed the impact of the optional optimization mentioned in Section~\ref{sec:adapted}, comparing the performance of our synthesis algorithm regarding guards based on labels and guards based on states. 
% The runtime results in  show significant speed-ups, albeit we have thus far only tested the optimization for this single example. %By contrast, we do not profit from this optimization if the number of possible label assignments exceeds the number of states.
