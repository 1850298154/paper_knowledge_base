\section{Cutoffs for Conjunctive Systems}
\label{sec:app-conj}
%
%For convenience in the proofs, we {\bf inverse the meaning of conjunctive guard}, 
%i.e., given system state $s$, process $p$, and guard $guard \in Q_B \cupdot Q_A$:
%$$
%(s,p) \models guard 
%\ \iff\ 
%\forall p' \in \{A,B_1,\ldots,B_n\} \smi \{p\}:\ \state_{p'} \not\in guard.
%$$

\subsection{Conjunctive Systems without Fairness}

\begin{restatable}[Monotonicity: Conj, Props, Unfair]{lem}{ConjMonotonicityLemma}
\label{le:ConjMonotonicityLemma}
For conjunctive systems,
\begin{align*}
\forall n \geq 1:\ 
(A,B)^{(1,n)} \models \pexists h(A,B_1)
\ \ \Impl \ \ 
(A,B)^{(1,n+1)}\models \pexists h(A,B_1).
\end{align*}
\end{restatable}
\begin{proof}
Let the new process stutter in $\init$ state.
\end{proof}

\begin{restatable}[Bounding: Conj, Props, Unfair]{lem}{ConjBoundingLemma}
\label{le:ConjunctiveBoundingLemma}
For conjunctive systems,
\begin{align*}
\forall n \geq 2:\ 
(A,B)^{(1,2)} \models \pexists h(A,B_1)
\ \ \Implied \ \ 
\largesys \models \pexists h(A,B_1).
\end{align*}
\end{restatable}

\begin{proof}
\input{proof-conj-bounding}
\end{proof}

\begin{restatable}[Conj, Props, Unfair]{tightness}{TightConjPropRestricted}
\label{obs:conj:tight_prop}
The cutoff $c=2$ is tight for parameterized model checking of properties $\pexists h(A,B_1)$ in the 1-conjunctive systems, i.e., there is a system type $(A,B)$ and property $Eh(A,B_1)$ which is not satisfied by $(A,B)^{(1,1)}$ but is by $(A,B)^{(1,2)}$.
\end{restatable}
\begin{proof}
The figure below shows templates $(A,B)$, $\pexists h(A,B_1) = \pexists \eventually b$. An infinite run that satisfies the formula needs one copy of $B$ that stays in the initial state, and one that moves into $b$.
\begin{figure}[h]
\centering
\subfloat[Template A]{
\centering
%\makebox[0.3\textwidth][c]{
\scalebox{0.75}{\input{img/conj_tight_prop_tmplA}}
\label{fig:conj:tight_prop_fair_tmplA}
}%}
\hspace{1cm}
\subfloat[Template B]{
\centering
%\makebox[0.4\textwidth][c]{
\scalebox{0.75}{\input{img/conj_tight_prop_tmplB}}
\label{fig:conj:tight_prop_fair_tmplB}
}%}
\end{figure}
\end{proof}


\ifwithextensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{restatable}[Generalized Bounding Lemma]{lem}{ConjBoundingLemmaGeneral}
\label{le:ConjunctiveBoundingLemmaGen}
For conjunctive systems,
\begin{align*}
&\forall n \geq k+1: \largesys \models \pexists h(A,B_{(k)}) 
\ \iff\ 
(A,B)^{(1,k+1)} \models \pexists h(A,B_{(k)})
\end{align*}
\end{restatable}

\input{proof-conj-bounding-general}

\begin{restatable}[Tightness]{obs}{TightConjPropRestrictedGeneral}
\label{obs:conj:tight_prop:general}
The cutoff $k+1$ for properties $\pexists h(A,B_{(k)})$ on unconstrained runs in 1-guard conjunctive systems, i.e., there is a system type $(A,B)$ and property $Eh(A,B_{(k)})$ which is not satisfied by $(A,B)^{(1,k)}$ but is satisfied by $(A,B)^{(1,k+1)}$.
\end{restatable}
\begin{proof}
Consider again Fig.~\ref{fig:conj:tight_prop_tmpl}, and the property $\pexists h(A,B_{(k)}) = \pexists \bigwedge_{i \in [1..k]} \eventually b_i$.
\end{proof}
\fi      %\ifwithextensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsubsection{Deadlock Detection.}

% A conjunctive system $\largesys$ is called \emph{disjoint-guards system}\ak{bad name, negations of guards are disjoint, not guards} if for any transitions $t, t' \in \delta$: $\neg\guard(t)\cap \neg\guard(t') \neq \emptyset \implies \guard(t) = \guard(t')$.
% \ak{too restricted -- does not allow read-write locks. Try more general version: $\neg\guard(t) \cap \neg\guard(t') \neq \emptyset \implies \guard(t) \subseteq \guard(t') \vee \guard(t') \subseteq \guard(t)$.}
% 
% For a global state $s$ of a system $(A,B)^{(1,n)}$ and $U\in\{A,B\}$, let $Set(s,U)$ be the set of states of all processes of type $U$ in $s$.\ak{find home}
% 
% Let $(\stateset, \init, \inputs, \trans, \guard)$ be a process template. For transition $t \in \delta$, and $g\in\guard(t)$ let \emph{resource} be the the set $\neg g$.\ak{find home}\ak{better to define conj guards via negations of current guards?}

\begin{restatable}[Monotonicity: Conj, Deadlocks, Unfair]{lem}{ConjDeadlockMonotonicityLemmaRestricted}
\label{le:ConjunctiveMonotonicityLemmaDeadlocks}
For conjunctive systems:
$$
\forall n\geq 1: (A,B)^{(1,n)} \textit{ has a deadlock} 
\ \Impl\ 
(A,B)^{(1,n+1)} \textit{ has a deadlock}
$$
% \li
%   \- with $c=2|Q_B\smi \{ \init \}|$:\hl{XXX}
%   $$(A,B)^{(1,c)} \textit{ has a global deadlock} \ \Impl\ (A,B)^{(1,>c)} \textit{ has a global deadlock} $$
%   
%   \- with $c=1$:
%   $$(A,B)^{(1,c)} \textit{ has a local deadlock} \ \Impl\ (A,B)^{(1,>c)} \textit{ has a local deadlock}$$
%   
%   \- with $c=1$:
%   $$(A,B)^{(1,c)} \textit{ has a deadlock} \ \Impl\ (A,B)^{(1,>c)} \textit{ has a deadlock}$$

% \il
\end{restatable}
\begin{proof}
\input{proof-monotonicity-conj-deadlock}
\end{proof}


\begin{restatable}[Bounding: 1-Conj, Deadlocks, Unfair]{lem}{ConjDeadlockLemmaRestricted}
\label{le:ConjunctiveBoundingLemmaDeadlocks}
For 1-conjunctive systems:
\li
  \- with $c=2|Q_B\smi \{ \init \}|$ and any $n>c$ \footnote{This statement also applies to systems without restriction to $1$-conjunctive guards.}
  $$(A,B)^{(1,c)} \textit{ has a global deadlock} \ \Implied\ (A,B)^{(1,n)} \textit{ has a global deadlock} $$
  
  \- with $c=|Q_B\smi \{ \init \}|+2$ and any $n>c$:
  $$(A,B)^{(1,c)} \textit{ has a local deadlock} \ \Implied\ (A,B)^{(1,n)} \textit{ has a local deadlock}$$
  
  \- with $c=2|Q_B\smi \{ \init \}|$ and any $n>c$:
  $$(A,B)^{(1,c)} \textit{ has a deadlock} \ \Implied\ (A,B)^{(1,n)} \textit{ has a deadlock}$$
\il
\end{restatable}
\begin{proof}
\input{proof-conj-deadlock}
\end{proof}

\ak{proof trial of the disjoint conj is commented out}
%\begin{lem}
%``Bounding: disjoint-conj, Deadlocks, Unfair''
%\end{lem}
%\input{other/disjoint-conj-dead-proof-trial}

\begin{restatable}[1-Conj, Deadlocks, Unfair]{tightness}{TightConjDeadlockRestricted}
\label{obs:conj:tight_deadlock}
The cutoff $c=2|B|-2$ is tight for parameterized deadlock detection in the 1-conjunctive systems, i.e., for any $k$ there is a system type $(A,B)$ with $|B|=k$ such that there is a deadlock in $(A,B)^{(1,2|B|-2)}$, but not in $(A,B)^{(1,2|B|-3)}$. 
\end{restatable}
\input{tight-conj-deadlock}


\ifwithextensions   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Now consider the general case of guards of the original (unrestricted) form:
\begin{restatable}[Local Deadlock Detection, Unrestricted Guards]{lem}{ConjDeadlockUnrestricted}
\label{le:ConjunctiveBoundingLemmaDeadlocksUnrestricted}
Let $c=3^{\card{B}}$.
If there are no local deadlocks 
in the conjunctive system $\cutoffsys$, then for any $n \ge c$ the conjunctive system $\largesys$ has no local deadlocks.
\end{restatable}

\iffinal
\else
\input{proof-conj-deadlock-unrestricted}
\fi
\fi   %\ifwithextensions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Conjunctive Systems with Fairness}
In this section, subscript $i$ in path quantifiers, $\pexists_i$ and $\pforall_i$, 
denotes the quantification over initializing runs.

\begin{restatable}[Monotonicity: Conj, Props, Fair]{lem}{ConjMonLemmaFair}
\label{le:ConjMonFair}
For unconditionally-fair initializing runs of conjunctive systems:\sj{generalization is obvious; $n \ge k+1$ in general case}
\begin{align*}
& \forall n \ge 2:\\
& (A,B)^{(1,n)} \models \pexists_{uncond,i} h(A,B_1)
\ \Impl \
(A,B)^{(1,n+1)} \models \pexists_{uncond,i} h(A,B_1).
\end{align*}
\end{restatable}
\input{proof-conj-mon-fair}

\begin{restatable}[Bounding: Conj, Props, Fair]{lem}{ConjBoundingLemmaFair}
\label{le:FairConjunctiveBounding Lemma}
For unconditionally-fair initializing runs of conjunctive systems:
\begin{align*}
&\forall n \geq 1:\\
& (A,B)^{(1,1)} \models \pexists_{uncond} h(A,B_1)
\ \Implied \
(A,B)^{(1,n)} \models \pexists_{uncond} h(A,B_1)
\end{align*}
\end{restatable}
%

\input{proof-conj-bounding-fair}

\begin{restatable}[1-Conj, Props, Fair]{tightness}{TightConjPropRestrictedFair}
\label{obs:conj:tight_prop_fair}
The cutoff $c=2$ is tight for parameterized model checking of $\pexists h(A,B_1)$ 
on unconditionally-fair initializing runs in 1-conjunctive systems, 
i.e., 
there is a system type $(A,B)$ and property $\pexists h(A,B_1)$ 
which is satisfied by $(A,B)^{(1,1)}$ but not by $(A,B)^{(1,2)}$.
\end{restatable}
\begin{proof}
The figure below shows $(A,B)$, $\pexists h(A,B_1) = \pexists \FG (b_{init} \impl a_1)$.
\begin{figure}[h]
\centering
\vspace{-20pt}
\subfloat[Template A]{
\centering
%\makebox[0.4\textwidth][c]{
\scalebox{0.75}{\input{img/conj_tight_prop_fair_tmplA}}
\label{fig:conj:tight_prop_fair_tmplA}
}%}
\hspace{1cm}
\subfloat[Template B]{
\centering
%\makebox[0.6\textwidth][c]{
\scalebox{0.75}{\input{img/conj_tight_prop_fair_tmplB}}
\label{fig:conj:tight_prop_fair_tmplB}
}%}
\label{fig:conj:tight_prop_fair_tmpl}
\end{figure}
\end{proof}

\begin{restatable}[Monotonicity: Conj, Deadlocks, Fair]{lem}{ConjDeadlockMonotonicityLemmaFair}
\label{le:FairConjunctiveMonotonicityLemmaDeadlocks}
For 1-conjunctive systems on strong fair initializing or finite runs:
$$
\forall n\geq 1: (A,B)^{(1,n)} \textit{ has a deadlock}
\ \Impl\ 
(A,B)^{(1,n+1)} \textit{ has a deadlock}
$$
\end{restatable}
\begin{proof}\ak{check the minimal value of $n$ (1 or 2?)}
Let $x$ be a globally deadlocked or locally deadlocked strong-fair initializing run of $(A,B)^{(1,n)}$.
We will build a globally deadlocked or locally deadlocked strong-fair initializing run 
of $(A,B)^{(1,n+1)}$.

If $x$ is finite, then $y$ is the copy of $x$, and the new process stays in $\init_B$
until every process become deadlocked, and then is scheduled arbitrarily.
Note that $y$ constructed this way may be locally deadlocked 
rather than globally deadlocked as $x$ is.

Now consider the case when $x$ is locally deadlocked strong-fair initializing.

Let $\mD$ be the set of deadlocked $B$-processes in $x$, and $d$ be the moment 
when the processes become deadlocked.

Consider the case $\visInf{\mB\smi\mD}{x} \neq \emptyset$:
copy $x$ into $y$, and let the new process $B_{n+1}$ wait in $\init_B$ 
and interleave the roles with a process $B$ that moves infinitely often in $x$, 
similarly to as described in the proof of Lemma~\ref{le:ConjMonFair}.

Consider the case $\visInf{\mB\smi\mD}{x} = \emptyset$:
every $B$ process of $(A,B)^{(1,n)}$ is deadlocked and thus $\mD = \mB$.
Define 
$$
DeadGuards = \{\ q \| \exists P \in \mD
                      \textit{ with a transition guarded ``\,}
                      {\forall \neg q} 
                      \textit{\!'' in } (s_d(P),e_d(P))\ \}.
$$
Note that $Q_A \cap DeadGuards = \emptyset$, because $A$ visits infinitely often $\init_A$
and we consider 1-conjunctive systems.
Hence, copy $x$ into $y$, and let the new process $B_{n+1}$ wait in $\init_B$ 
until every process $B_1,...,B_n$ become deadlocked, and then schedule $B_{n+1}$ arbitrarily.
%
% See the proof of Lemma~\ref{le:ConjunctiveMonotonicityLemmaDeadlocks}.
%%% AK: this won't work because the process B_{n+1} in init should move inf often or deadlock,
%%% the arbitrary scheduling can lead to unlocking of every one
\end{proof}

\begin{restatable}[Bounding: 1-Conj, Deadlocks, Fair]{lem}{ConjDeadlockLemmaFair}
\label{le:FairConjunctiveBoundingLemmaDeadlocks}
For 1-conjunctive systems on strong-fair initializing or finite runs:
\ak{no real need for initializing -- but easier to explain}
\li
  \- with $c=2|Q_B\smi \{ \init \}|$ and any $n>c$:
  $$
  \cutoffsys \textit{ has a global deadlock} 
  \ \Implied\ 
  \largesys \textit{ has a global deadlock}
  $$

  \- with $c=2|Q_B\smi \{ \init \}|+1$ and any $n>c$ (when $|Q_B|>2$):
  $$
  \cutoffsys \textit{ has a local deadlock} 
  \ \Implied\ 
  \largesys \textit{ has a local deadlock}
  $$

  \- with $c=2|Q_B\smi \{ \init \}|$ and any $n>c$:
  $$
  \cutoffsys \textit{ has a deadlock} 
  \ \Implied\ 
  \largesys \textit{ has a deadlock}
  $$
\il
\end{restatable}
\begin{proof}
\input{proof-conj-deadlock-fair}
\end{proof}

\begin{restatable}[1-Conj, Deadlocks, Fair]{tightness}{TightConjDeadlockRestrictedFair}
\label{obs:conj:tight_deadlock_fair}
The cutoff $c=2|B|-2$ is tight for deadlock detection on strong-fair initializing
or finite runs in the 1-conjunctive systems, 
i.e., 
for any $k>2$ there is a system type $(A,B)$ with $|B|=k$ such that 
there is a strong-fair initializing deadlocked run in $(A,B)^{(1,2|B|-2)}$, 
but not in $(A,B)^{(1,2|B|-3)}$.
\end{restatable}

\input{tight-conj-deadlock-fair}





\ifwithextensions      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Label-dependent Cutoffs for Conjunctive Systems}

To obtain label-dependent cutoffs, we need to re-define the special role of the initial state for conjunctive guards: in this case, we assume that the initial state has a labeling $l_\initstate$, and this labeling must be part of any guard.

\begin{restatable}[Deadlock Detection, Label-based]{lem}{ConjDeadlockLemmaLabel}
\label{le:ConjunctiveBoundingLemmaDeadlocksLabel}
Let $c=2\card{\labelings_B}-2$.
If there are no local deadlocks 
in the conjunctive system $\cutoffsys$, then for any $n \ge c$ the conjunctive system $\largesys$ has no local deadlocks.
\end{restatable}

\iffinal
\else
\input{proof-conj-deadlock-label}
\fi
\fi     % \ifwithextensions   %%%%%%%%%%%%%%%%%%%%%%%%5

\iffinal
\else
\input{proof-conj-disjoint}
\fi

\iffinal
\else
\input{proof-conj-subsume}
\fi

\iffinal
\else
\section{2-Conjunctive Proof Idea}

\paragraph{Given:} a (initializing) system with only 1-conjunctive guards, except a single 2-conjunctive guard.

\paragraph{Goal:} find cutoff for local deadlock detection.

\paragraph{Idea}:
Assume in a system \largesys there is a locally deadlocked run $x$. That is, at some time $d$ there is a set of processes with state/input combinations $\dead \subseteq Q \times \Sigma$ such that $\forall (q,e) \in \dead$ and $\forall \time \geq d$, no transition from $(q,e)$ is enabled in $x_\time$. Let $\visited_\bot$ be the set of state components of $\dead$, i.e., $\visited_\bot = \{ q \in Q \mid \exists e \in \Sigma: (q,e) \in \dead \}$. 

As in the 1-conjunctive case, this local deadlock may depend on
\begin{enumerate}[label=\alph*)]
\item at least two processes staying in each of the states in $\visited^2_\bot \subset \visited_\bot$, and
\item an additional process staying in each of the states of an additional set $BlockStates$.
\end{enumerate}

Since we want to simulate a strong-fair run $x$, we need to ensure that all processes that are not in $\dead$ at moment $d$ will move infinitely often in our simulation. In particular, we assume that the deadlock depends on the 2-conjunctive guard of the system, and none of the deadlocked processes is in either of the states $q_1$ or $q_2$ that are excluded by this guard (otherwise, the 2-conjunctive guard is not important for the local deadlock and we can fall back to the 1-conjunctive proof).

To allow infinite movement, note that for every $q \in Blockstates$, there must be a loop from $q$ to $\initstate$ and back to $q$ (written $\myloop{q}$) in the original run $x$. While moving along this loop is easy in the pure 1-conjunctive case if we remove all processes not in $\visited_\bot \cup BlockStates$, it is not so easy if we have a 2-conjunctive guard: transitions on the loop $\myloop{q}$ may depend on guards that exclude either $q_1$ or $q_2$, the two states of the 2-conjunctive guard.

First, consider the problem of a process $p$ that occupies (wlog) the state $q_1$ of the 2-conjunctive guard at moment $d$, and has to make a loop $\myloop{q_1}$. The transition out of the loop may depend on a guard that forbids $q_1$, so another process needs to move into $q_2$ before $p$ can move out of $q_1$. The next transition along the loop may depend on a guard that forbids $q_2$, so another process needs to move into $q_1$, and the first additional process then needs to move out of $q_2$, etc.

\paragraph{Question:} How many processes are necessary to simulate just the loop $\myloop{q_1}$?
\fi


