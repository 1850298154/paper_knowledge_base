\section{Proof Techniques for Conjunctive Systems}
\label{sec:ideas-conj}

\subsection{\LTLmX\ Properties without Fairness: Existing Constructions}
%\paragraph*{\LTLmX\ Properties without Fairness}
\label{sec:ideas-conj-nofair}
Recall that the Monotonicity lemma is proven by keeping the additional process
in the initial state.
To prove the bounding lemma, 
Emerson and Kahlon \cite{Emerson00} suggest to simply copy the local runs $x(A)$ and $x(B_1)$ into $y$. 
In addition, we may need one more process that moves infinitely often to ensure that an infinite run of \largesys will result in an infinite run of \cutoffsys. All transitions of copied processes will be enabled because removing processes from a conjunctive system cannot disable a transition that was enabled before.

\subsection{\LTLmX\ Properties with Fairness: New Constructions}
%\paragraph*{\LTLmX\ Properties with Fairness}
\label{sec:ideas-conj-fair}

The proof of the 
Bounding lemma is the same as in the non-fair case, noting that if the 
original run is unconditional-fair, then so will be the resulting run.

Proving the Monotonicity lemma is more difficult, since the fair extension 
construction from disjunctive 
systems does not work for conjunctive systems
-- if an additional process mimics the transitions of an existing process
   then it disables transitions of the form 
   $\transition{q}{q'}{\textit{``\,}\forall\neg q\textit{\!''}}$ or
   $\transition{q}{q'}{\textit{``\,}\forall\neg q'\textit{\!''}}$.
%an additional process 
%in the same state may disable an outgoing transition that was enabled before.
Hence, we add the restriction of initializing runs, 
which allows us to construct a fair run as follows.
The additional process $B_{n+1}$ ``shares'' a local run $x(B_i)$ 
with an existing process $B_i$ of $(A,B)^{(1,n+1)}$: 
one process stutters in $\init_B$ while the other makes transitions from $x(B_i)$, 
and whenever $x(B_i)$ enters $\init_B$
(this happens infinitely often),
the roles are reversed. 
Since this changes the behavior of $B_i$, 
$B_i$ should not be mentioned in the formula, 
i.e., we need $n\geq 2$ for a formula $h(A,B^{(1)})$. 


\subsection{Detection of Local and Global Deadlocks: New Constructions}
\label{sec:ideas-conj-deadlock}
\myparagraphraw{Monotonicity lemmas} for both fair and unfair cases 
are proven by keeping process $B_{n+1}$ in the initial state, 
and copying the runs of deadlocked processes.
If the run of \largesys is globally deadlocked, then process $B_{n+1}$ may keep moving in the constructed run, i.e., it may only be locally deadlocked. 
In case of a local deadlock in \largesys, distinguish two cases: 
there is an infinitely moving $B$-process, or all $B$-processes are deadlocked 
(and thus $A$ moves infinitely often).
In the latter case, use the same construction as in the global deadlock case
(the correctness argument uses the fact that systems are 1-conjunctive, 
 runs are initializing, and there is only one process of type $A$).
In the former case, copy the original run, and let $B_{n+1}$ share
a local run with an infinitely moving $B$-process.

\myparagraphraw{Bounding lemma (no fairness).}
In the case of global deadlock detection, 
Emerson and Kahlon~\cite{Emerson00} suggest to copy a subset of the original local runs.
For every local state $q$ that is present in the final state of the run, 
we need at most two local runs that end in this state. 
In the case of local deadlocks, 
our construction uses the fact that systems are 1-conjunctive.
In 1-conjunctive systems, if a process is deadlocked, 
then there is a set of states $DeadGuards$ that all need to be populated by other processes
in order to disable all transitions of the deadlocked process. 
Thus, 
the construction copies: 
(i) the local run of a deadlocked process, 
(ii) for each $q \in DeadGuards$, the local run of a process 
     that is in $q$ at the moment of the deadlock, and
(iii) the local run of an infinitely moving process.
\iffinal \else See the details in Appendix~\ref{sec:app-conj}.\fi

\myparagraphraw{Bounding lemma (strong fairness).}
We use a construction that is similar to that of properties under fairness for disjunctive systems (Sect.~\ref{sec:ideas-disj-fair}):
  in the setup phase, 
  we populate some ``safe'' set of states with processes,
  and then we extend the runs of non-deadlocked processes 
  to satisfy strong fairness, 
  while ensuring that deadlocked processes never get enabled.

Let $c=2|Q_B\smi \{ \init_B \}|$. 
Let $x= (s_1,e_1,p_1)\ldots$ be a locally deadlocked strong-fair intitializing run 
of $\largesys$ with $n>c$. 
We construct a locally deadlocked strong-fair initializing run $y$ of $\cutoffsys$.

Let $\mD \subseteq \mB$ be the set of deadlocked $B$-processes in $x$. 
Let $d$ be the moment in $x$ starting from which every process in $\mD$ is deadlocked.
Let $\dead(x)$ be the set of states in which processes $\mD$ of \largesys
are deadlocked.
Let $\dead_2(x) \subseteq \dead(x)$ be the set of deadlocked states such that: 
for every $q \in \dead_2(x)$, 
there is a process $B_i \in \mD$ with $s_d(B_i) = q$ 
and that for input $e_{\geq d}(B_i)$ has a transition guarded with ``$\forall \neg q$''.
Thus, a process in $q$ is deadlocked with $e_d(B_i)$
only if there is another process in $q$ in every moment $\geq d$.
Let $\dead_1(x) = \dead(x)\smi\dead_2(x)$.
%I.e., 
%for any $q \in \dead_1(x)$, there is a process $P$ of \largesys 
%which is deadlocked in $s_d(P) = q$ with input $e_d(P)$,
%and no transitions from $q$ with input $e_d(P)$ are guarded with ``$\forall \neg q$''.
Define $DeadGuards$ to be the set
$$
\{\ q \| \exists B_i \in \mD
         \textit{ with a transition guarded ``\,}
         {\forall \neg q} 
         \textit{\!'' in } (s_d(B_i),e_d(B_i))\ \}.
$$ 
% AK: 'in (s_d(B_i), e_d(B_i))' is confusing: does it mean that q is in (s_d(B_i), e_d(B_i))?
%$$
%DeadGuards = \left\{ 
%q ~\left|~ \begin{array}{l} \exists B_i \in \mD
%                      \textit{ with a transition guarded by ``\,}
%                      {\forall \neg q}
%                      \textit{\!''}\\
%											\textit{in } (s_d(B_i),e_d(B_i))
%											\end{array}\right. \right\}
%$$
Figure~\ref{fig:ideas:conj-deadlocks-venn} illustrates properties of sets 
$DeadGuards$, $\dead_1$, $\dead_2$, $\visInf{\mB\smi\mD}{x}$.
%
\begin{figure}[t]
\vspace{-0.4cm}
\centering
\includegraphics[width=0.7\textwidth]{img/conj-deadlocks-venn.png}
\caption[fig:ideas:conj-deadlocks-venn]{%
Bounding lemma (strong fairness):
Venn diagram for 
$\dead_1$, $\dead_2$, $DeadGuards$, $\visInf{\mB\smi\mD}{x}$.
States $q_1,...,q_6$ are to illustrate that the corresponding sets may be non-empty.
E.g., 
in $x$, 
a process may be deadlocked in $q_1 \in (DeadGuards \cap \dead_1 \cap \visInf{\mB\smi\mD}{x})$, 
%and another process in $q_2 \in \dead_1 \smi (DeadGuards \cup \visInf{\mB\smi\mD}{x})$.%
and another process in $q_3 \in \dead_1 \cap DeadGuards \smi \visInf{\mB\smi\mD}{x}$.%
%E.g., 
%in $x$, 
%there may be at least one process $P \in \mD$ deadlocked in 
%$q_2 \in \dead_1 \smi (DeadGuards \cup \visInf{\mB\smi\mD}{x})$ with input $e_d(P)$,
%no non-deadlocked processes visit $q_2$ infinitely often, 
%and no process $P' \in \mD$ has an outgoing deadlocked transition from 
%$s_d(P')$ with $e_d(P')$ guarded ``$\forall \neg q_2$''.
%Or: 
%in $x$, 
%there may be at least two processes from $\mD$ deadlocked in 
%$q_6 \in (\dead_2 \cap DeadGuards) \smi \visInf{\mB\smi\mD}{x}$, 
%no non-deadlocked processes visit $q_6$ infinitely often,
%and $q_6$ for an input $i$ has an outgoing transition guarded ``$\forall \neg q_6$''.%
}
\label{fig:ideas:conj-deadlocks-venn}
\vspace{-0.4cm}
\end{figure}

In the {\bf setup phase}, we copy from $x$ into $y$: 
\li
\- the local run of $A$; 
\- for every $q \in \dead_1$, the local run of one process deadlocked in $q$;
\- for every $q\in \dead_2$, the local runs of two%
   \footnote{Strictly speaking, 
             in $x$ we might not have two deadlocked processes 
             in a state in $dead_2$
             -- one process may be deadlocked, 
                others enter and exit the state infinitely often.
             In such case, there is always a non-deadlocked process in the state.
             Then, copy the local run of such infinitely moving process 
             until it enters the deadlocked state, and then deadlock it 
             by providing the same input as the deadlocked process receives.} 
   processes deadlocked in $q$;
\- for every $q \in DeadGuards \smi \dead$, the local run of a process that reaches $q$ after moment $d$.
\- Finally, we keep one $B$-process in $\init_B$ until moment $d$.  
\il
The setup phase ensures: 
in every state $q \in \dead$,
there is at least one process deadlocked in $q$ at moment $d$ in $y$. 
Now we need to ensure that the non-deadlocked processes in $DeadGuards\smi \dead$ and $\init_B$
move infinitely often, which is done using the looping extension described bellow.

Order arbitrarily 
$DeadGuards \smi \dead = (q_1,\ldots,q_k) \subseteq \visInf{\mB\smi\mD}{x}$.
Let $\mP \subseteq \{B_1,...,B_c\}$ be the non-deadlocked processes of \cutoffsys that we moved 
into $(q_1,\ldots,q_k) \cupdot \{\init_B\}$ in the setup phase.
Note that $|\mP| = |(q_1,...,q_k)| + 1$.

The {\bf looping phase} is: set $i=1$, and repeat infinitely the following.
\li
  \- let $B_\init \in \mP$ be the process of \cutoffsys that is currently in $\init_B$, 
     and $B_{q_i} \in \mP$ be the process of \cutoffsys that is currently in $q_i$
     
  \- let $\tilde{B}_{q_i} \in \visInf{\mB\smi\mD}{x}$ be a process of \largesys 
     that visits $q_i$ and $\init_B$ infinitely often.
     Let $B_\init$ of \cutoffsys copy transitions of $\tilde{B}_{q_i}$
     on some path $\init_B \to \ldots \to q_i$,
     then let $B_{q_i}$ copy transitions of $\tilde{B}_{q_i}$ on some path 
     $q_i \to \ldots \to \init_B$. 
     For copying we consider only the paths of $\tilde{B}_{q_i}$ that happen after moment $d$.

  \- $i=i \oplus 1$
\il
\iffinal \else For more details, including tightness observations, see Appendix~\ref{sec:app-conj}.\fi
\begin{remark}\label{rem:general-conj-tough}
In 1-conjunctive systems, the set $DeadGuards$ is ``static'', i.e.,
  there is always at least one process in \emph{each state} of $DeadGuards$ 
  starting from the moment of the deadlock.
In contrast, in general conjunctive systems where guards can overlap, 
  there is no such set. However, there is a similar set of sets of states, such that \emph{one state from each set} always needs to be populated to ensure the deadlock. 
% AK: not sure about the conjecture for the general case -- for 2-conj-disjoint fine,
%     but it appears that this is too technical for this paper.
%  We conjecture that our proof techniques can be used to obtain cutoffs for such systems, 
%  albeit with a significantly more complicated construction.
\end{remark}
  
%See the details in Appendix~\ref{sec:app-conj}.
%
%Lacking a proof for the general case, we provide cutoffs for $1$-conjunctive systems. 
%In 1-conjunctive systems, if some processes are deadlocked, then there is the set $Block$ of states
%  which needs to be populated by processes, in order to disable all transitions of all the 
%  deadlocked process. 
%Note that in 1-conjunctive systems this set is `static' meaning
%  there is always at least one process in each state of $Block$ starting from the moment of the deadlock.
%In contrast, in general conjunctive systems where guards can overlap, 
%  there is no such set (but there is a similar \emph{set of sets} of states).
%For 1-conjunctive systems, the proof of the Bounding lemma has a similar structure 
%  to that of properties under fairness for disjunctive systems:
%  first, we ensure that all non-deadlocked processes move into a `safe' set of states 
%  that contains $Block$, 
%  and then we use an analogue of fair extension to extend their runs to satisfy 
%  the strong fairness, also ensuring that there is always at least one process in every state 
%  of $Block$. See the details in Appendix~\ref{sec:app-conj}.
%
