\section{Reduction Method and Challenges}
\label{sec:paramsynt}
 
We show how to use existing cutoff results of Emerson and Kahlon~\cite{Emerson00} to reduce the PMCP to a standard model checking problem, and parameterized synthesis to template synthesis. We note the limitations of the existing results that are crucial in the context of synthesis.

\smallskip
\noindent
{\bf Reduction by Cutoffs.}
A \emph{cutoff} for a system type $(\templateI,\templateII)$ and a specification $\spec$ is a number $c \in \bbN$ such that:
\[ 
\forall n \ge c: \left( \largesys \models \spec ~~\iff~~ \cutoffsys \models \spec \right).
\]
%
Similarly, $c \in \bbN$ is a \emph{cutoff for (local/global) deadlock detection}
if $\forall n \ge c:$ $\largesys$ has a (local/global) deadlock iff $\cutoffsys$ has a (local/global) deadlock.
%
For the systems and specifications presented in this paper, cutoffs can be computed from 
the size of process template $B$ and the number $k$ of copies of $B$ 
mentioned in the specification, and are given as expressions like 
$\card{B}+k+1$.

\begin{remark}\label{re:EK_cutoffs}
Our definition of a cutoff is different from that of Emerson and Kahlon~\cite{Emerson00}, and instead similar to, e.g., Emerson and Namjoshi~\cite{Emerso03}. The reason is that we want the following property to hold for any $(A,B)$ and $\Phi$: 

\noindent \emph{if $n_0$ is the smallest number such that ~$\forall n \geq n_0:\ \largesys \models \Phi$},

\noindent \emph{then any $c<n_0$ is not a cutoff, any $c\geq n_0$ is a cutoff.}

\smallskip\noindent 
We call $n_0$ the \emph{tight} cutoff.
The definition in \cite[page 2]{Emerson00} requires that $\forall{n\leq c}. \largesys \models \Phi$ if and only if $\forall{n \geq 1}: \largesys \models \Phi$, and thus allows stating $c<n_0$ as a cutoff if $\Phi$ does not hold for all $n$. \qed
\end{remark}
%
In model checking, a cutoff allows us to check whether any ``big'' system satisfies the specification by checking it in the cutoff system. 
As noted by Jacobs and Bloem~\cite{Jacobs14}, a 
similar reduction applies to the parameterized synthesis problem. 
For guarded protocols, we obtain the following 
\emph{semi-decision procedure for parameterized synthesis}\ak{is it decidable?}:
\begin{enumerate}
  \item[0.] set initial bound $(\bound_A,\bound_B)$ on size of process templates;
  \item[1.] determine cutoff for $(\bound_A,\bound_B)$ and $\spec$;
  \item[2.] solve bounded template synthesis problem for cutoff, size bound, and $\spec$;
  \item[3.] if successful return $(A,B)$ else increase $(\bound_A,\bound_B)$ and goto (1).
\end{enumerate}


\myparagraph{Existing Cutoff Results}
Emerson and Kahlon~\cite{Emerson00} have shown:

\begin{thm}[Disjunctive Cutoff Theorem] \label{thm:disj-cutoff-pairs}
    For closed disjunctive systems, $\card{B}+2$ is a cutoff {$^{(\dagger)}$} for formulas of the
    form $\pforall h(A,B^{(1)})$ and $\pexists h(A,B^{(1)})$, and for global
    deadlock detection.
\end{thm}
 
\begin{thm}[Conjunctive Cutoff Theorem] \label{thm:conj-cutoff}
    For closed conjunctive systems, $2\card{B}$ is a cutoff {$^{(\dagger)}$} for formulas of the
    form $\pforall h(A)$ and $\pexists h(A)$, and for global deadlock detection.
    For formulas of the form $\pforall h(B^{(1)})$ and $\pexists h(B^{(1)})$,
    $2\card{B}+1$ is a cutoff.
\end{thm}

\begin{remark}
$^{(\dagger)}$ Note that Emerson and Kahlon \cite{Emerson00} proved these results for
a different definition of a cutoff (see Remark \ref{re:EK_cutoffs}).  
Their results also hold for our definition, except possibly for
global deadlocks.  For the latter case to hold with the new cutoff definition, one 
also needs to prove the direction ``global deadlock in the cutoff system implies global
deadlock in a large system'' (later called Monotonicity Lemma).  In Sect.~\ref{sec:ideas-disj-deadlock} and \ref{sec:ideas-conj-deadlock} we
prove these lemmas for the case of general deadlock (global \emph{or} local).
\end{remark}

\myparagraph{Challenge: Open Systems}
For any open system $S$ there exists a closed system $S'$ such that $
S$ and $S'$ cannot be distinguished by $\LTL$ specifications 
(cp. Manna and Pnueli~\cite{Manna92}). Thus, one approach to PMC for open 
systems is to use a translation between open and closed systems, and then use the 
existing cutoff results for closed systems.

%While such an approach works in theory, it is not feasible when cutoffs 
%depend on the size of process templates: in this case the conversion not only results in a 
%blowup of the local state space of each process, but also in the number of 
%processes that we need to consider. 
While such an approach works in theory, it might not be feasible in practice:
since cutoffs depend on the size of process templates,
and the translation blows up the process template,
it also blows up the cutoffs.
Thus, cutoffs that directly support open systems are important.


\myparagraph{Challenge: Liveness and Deadlocks under Fairness}
We are interested in cutoff results that support liveness properties.
In general, we would like to consider only runs where all processes move infinitely often, i.e., use the unconditional fairness assumption $\forall{p}. \GF \sched_p$. However, this would mean that we accept all systems that always go into a local deadlock, since then the assumption is violated. This is especially undesirable in synthesis, because the synthesizer usually tries to violate the assumptions in order to satisfy the specification. To avoid this, we require the absence of local deadlocks under the strong fairness assumption $\forall{p}. (\GF \enabled_p \impl \GF \sched_p)$. Since strong fairness and absence of local deadlocks imply unconditional fairness, we can then use the latter as an assumption for the original specification.

%In these systems, processes may be disabled depending on their input and the global state. \change{Thus, strong fairness $\forall{p}. (\GF \enabled_p \impl \GF \sched_p)$ is an insufficient assumption, since the environment can easily violate liveness properties by choosing inputs and scheduling such that some process is only enabled finitely often.}
%{Thus, strong fairness $\forall{p}. (\GF \enabled_p \impl \GF \sched_p)$ is an
%insufficient assumption, since the environment can easily violate a process's liveness
%property by choosing inputs and scheduling such that the process never moves 
%after some moment.}
%%
%Moreover, using the unconditional fairness assumption $\forall{p}. \GF \sched_p$
%\remove{for the complete specification} is also undesirable, since then we would accept all systems that always go into a local deadlock. This is especially undesirable in synthesis.
%To exclude this case, we require absence of local deadlocks under the strong fairness assumption. 

In summary, for a parameterized specification $\spec$, we consider satisfaction of
\[
\begin{array}{lllll}
\textit{``all runs are infinite''} &~~\land~~& \pforall_{strong} \spec_{\neg dead} & ~~\land~~ & \pforall_{uncond} \spec.
\end{array}
\]
%
This is equivalent to $\textit{``all runs are infinite''} \land \pforall_{strong} (\spec_{\neg dead} \,\land\, \spec)$, but by considering the form above we can separate the tasks of deadlock detection and of model checking $\LTLmX$-properties, and obtain modular cutoffs. 

In the following, we present cutoffs for problems of the forms 
(i) $\pforall_{uncond} \spec$,
(ii) $\pforall_{strong} \spec_{\neg dead}$ and no global deadlocks 
(and the variants with $\pexists$ path quantifier).
%, as well as for the detection of global deadlocks.
% AK: the previous version reads like we provide cutoffs for three problems -- we have only two



