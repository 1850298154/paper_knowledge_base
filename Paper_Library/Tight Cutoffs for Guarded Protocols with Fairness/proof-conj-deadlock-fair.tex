\providecommand{\deadOne}{\dead_1}
\providecommand{\deadTwo}{\dead_2}

\myparagraph{Global Deadlocks}
$c=2|Q_B \smi \{\init_B\}|$, 
see Lemma~\ref{le:ConjunctiveBoundingLemmaDeadlocks}, 
the fairness does not matter on finite runs.

\myparagraph{Local Deadlocks}
Let $c=2|Q_B\smi \{ \init_B \}|$. 
Let $x= (s_1,e_1,p_1)\ldots$ be a locally deadlocked strong-fair intitializing run 
of $\largesys$ with $n>c$. 
We construct a locally deadlocked strong-fair initializing run $y$ of $\cutoffsys$.

Let $\mD$ be the set of deadlocked processes in $x$. 
Let $d$ be the moment in $x$ starting from which every process in $\mD$ is deadlocked.

Let $\dead(x)$ be the set of states in which processes $\mD$ of \largesys
are deadlocked.

Let $\deadTwo(x) \subseteq \dead(x)$ be the set of deadlocked states such that: 
for every $q \in \deadTwo(x)$, 
there is a process $P \in \mD$ with $s_d(P) = q$ 
and that for input $e_{\geq d}(P)$ has a transition guarded with ``$\forall \neg q$''.
Thus, a process in $q$ is deadlocked with $e_d(P)$
only if there is another process in $q$ in every moment $\geq d$.

Let $\deadOne(x) = \dead(x)\smi\deadTwo(x)$.
I.e., 
for any $q \in \deadOne(x)$, there is a process $P$ of \largesys 
which is deadlocked in $s_d(P) = q$ with input $e_d(P)$,
and no transitions from $q$ with input $e_d(P)$ are guarded with ``$\forall \neg q$''.
%%% AK:
%%% Note that this def of deadOne differs from the below one (that i used originally):
%%% for every $q \in \deadOne(x)$, 
%%% there is a process $P \in \mD$ of \largesys
%%% that for input $e_{\geq d}(P)$ does not have a transition guarded with ``$\forall \neg q$''.
%%% The definition currently used may define deadOne which has less states that the commented one.
%%% But in the commented version we used the trick "Wlog., assume deadOne \cap deadTwo = 0", 
%%% which seems to produce the same set of states!

%Similarly, let $\deadOne(x)$ be the set of deadlocked states such that: 
%for every $q \in \deadOne(x)$, 
%there is a process $P \in \mD$ of \largesys
%that for input $e_{\geq d}(P)$ does not have a transition guarded with ``$\forall \neg q$''.
%I.e., 
%for such process $P$ is deadlocked in $q \in \deadOne(x)$ with input $e_{\geq d}(P)$,
%even if there is no other process in $q$ at any moment after $d$.
%
%Wlog., assume that $\deadOne(x) \cap \deadTwo(x) = \emptyset$.
%\footnote{Note:
%it is possible that
%$\deadOne \cap \deadTwo \neq \emptyset$ 
%for some locally deadlocked strong-fair initializing run $x$.
%But from $x$ we can always produce a locally deadlocked strong-fair initializing
%run $x'$ with an empty intersection as follows.
%Let $q \in \deadOne \cap \deadTwo$.
%Then, there is a process, $p \in {B_1,...,B_n}$, 
%deadlocked in $q$ with input $e(p)$ such that 
%all outgoing transitions from $q$ with $e(p)$ are not guarded with 
%``$\forall \neg q$''.
%Then, to all processes deadlocked in $q$ we provide input $e(p)$.
%This removes state $q$ from $\deadTwo$.
%By modifying inputs to all processes deadlocked in a state in the intersection,
%we can produce $x'$ with the empty intersection.
%}

%Let $\visited^\inf(x)$ be the set of states that are entered and
%exited infinitely often in $x$
%(this definition is slightly different from that of the rest of the paper).

%\ak{redefine the previous $\visited^\inf$ to mean: ``entered and exited inf often''?}

%Note:
%it is possible that $\dead(x) \cap \visited^\inf(x) \neq \emptyset$:
%one process may be deadlocked in such state provided one input,
%while another process may enter and exit the state infinitely often
%provided a different input.
% we cannot deadlock those non-deadlocked processes that
% visit $dead$, 
% because they might be moving on the loop that deadlocks some states,
% and deadlocking this process would require to move others from their states
% and BOOM! everyone gets unlocked!

Define
$$
DeadGuards = \{\ q \| \exists P \in \mD
                      \textit{ with a transition guarded ``\,}
                      {\forall \neg q} 
                      \textit{\!'' in } (s_d(P),e_d(P))\ \}.
$$
We illustrate properties of sets 
$DeadGuards$, $\deadOne$, $\deadTwo$, $\visInf{\mB\smi\mD}{x}$ 
in Fig.~\ref{fig:conj-deadlocks-venn}.
\ak{check how $A$'s states affect all those sets, currently i assumed that they are all subsets of $Q_B$}

\begin{figure}[h]
\begin{mdframed}
\centering
\includegraphics[width=0.7\textwidth]{img/conj-deadlocks-venn.png}
\captionsetup{singlelinecheck=off}
\caption[fig:conj-deadlocks-venn]{%
Venn diagram for sets $DeadGuards$, $\deadOne$, $\deadTwo$, $\visInf{\mB\smi\mD}{x}$:
\begin{itemize}
\item[($q_1$)] $\deadOne \cap DeadGuards \cap \visInf{\mB\smi\mD}{x} \neq \emptyset$ is possible:
               in $x$, 
               there is a process deadlocked in state $q_1$,
               there is a non-deadlocked process that visits $q_1$ infinitely often,
               and there is a process deadlocked in a state $q \neq q_1$ 
               with a transition guarded ``$\forall \neg q_1$'' 

\item[($q_3$)] $\deadOne \cap DeadGuards \smi \visInf{\mB\smi\mD}{x} \neq \emptyset$ is possible:
               similarly to $q_1$, 
               except that no non-deadlocked processes visit $q_3$ infinitely often

\item[($q_2$)] $\deadOne \smi (\visInf{\mB\smi\mD}{x} \cup DeadGuards) \neq \emptyset$ is possible:
               in $x$, 
               there is a process deadlocked in state $q_2$,
               no other processes visit $q_2$ infinitely often,
               and no processes are deadlocked with a transition guarded ``$\forall \neg q_2$''

\item[($q_4$)] $DeadGuards \smi \dead \neq \emptyset$ is possible:
               there is a process deadlocked in a state $q \neq q_4$ 
               with a transition guarded  ``$\forall \neg q_4$''

\item[($q_5$)] $\deadTwo \cap \visInf{\mB\smi\mD}{x} \cap DeadGuards \neq \emptyset$ is possible:
               there is at least one process deadlocked in $q_5$ with a transition guarded ``$\forall \neg q_5$'',
               and some non-deadlocked process visits $q_5$ infinitely often
               (this process does not deadlock in $q_5$, 
                because in $q_5$ it receives an input different from that of the deadlocked processes)

\item[($q_6$)] $\deadTwo \cap DeadGuards \smi \visInf{\mB\smi\mD}{x} \neq \emptyset$ is possible:
               similarly to $q_5$, except no non-deadlocked processes visit $q_6$ infinitely often
\end{itemize}
}
\label{fig:conj-deadlocks-venn}
\end{mdframed}
\end{figure}

Let us assume $DeadGuards \neq \emptyset$ -- the other case is straightforward.\ak{check}

The construction has two phases, the setup and the looping.
The setup phase is:
\li
\-[a.] $y(A) = x(A)$

\-[b.] for every $q \in \deadOne$: 
   devote one process of \cutoffsys that copies 
   a process of \largesys deadlocked in $q$

\-[c.] for every $q \in \deadTwo \setminus \visInf{\mB\smi\mD}{x}$: 
   devote two processes of \cutoffsys that copy 
   the behaviour of two processes of \largesys that deadlock in $q$

\-[d.] for every $q \in \deadTwo \cap \visInf{\mB\smi\mD}{x}$:
   in $x$, 
   there is a process, $B_q^\inf \in \mB\smi\mD$, that visits $q$ infinitely often,
   and there is a process, $B_q^\bot \in \deadTwo$, deadlocked in $q$.
   Then:
\li
   \-[1.] devote one process of \cutoffsys that copies the behaviour of $B_q^\bot$
   \-[2.] devote one process of \cutoffsys that copies the behaviour of $B_q^\inf$ 
          until it reaches $q$ at a moment after $d$,
          and then provide the same input as $B_q^\bot$ receives at moment $d$.
          This will deadlock the process.
\il

\-[e.] for every $q \in DeadGuards \setminus \dead$:
       note that $q \in \visInf{\mB\smi\mD}{x}$ and, thus, there is a process, 
       $B_q^\inf \in \mB\smi\mD$, 
       that visits $q$ infinitely often.
       Devote one process of \cutoffsys that copies the behaviour of $B_q^\inf$ 
       until it reaches $q$ at a moment after $d$

\-[f.] if $DeadGuards \setminus \dead \neq \emptyset$ 
       or $A \in \mD$,
       then devote one process that stays in $\init_B$.
       The process will be used in the looping phase to ensure that the run $y$ is infinite,
       and that every process of \cutoffsys used in (e) 
       moves infinitely often (and thus $y$ is strong-fair).
%       Note that if $A$ moves infinitely often in $x$ and $DeadGuards \smi \dead = \emptyset$,
%       then there is no need for such additional infinitely moving process.

\-[g.] let any other process of \cutoffsys (if any) 
       copy behaviour of a process of \largesys 
       that was not used in the construction so far (including this step)
\il
\ak{go through every item, and prove it is necessary (by giving an example)}
The setup phase ensures: 
in every state $q \in \dead$,
there is at least one process deadlocked in $q$ at moment $d$ in $y$. 
Now we need to ensure that the non-deadlocked processes described 
in steps (e) and (f) move infinitely often.

The looping phase is applied to processes in (e) and (f) only\footnote%
{%
  If there are no such processes, then the setup phase produces the sought run $y$.
}.
Order arbitrarily 
$DeadGuards \smi \dead = (q_1,\ldots,q_k) \subseteq \visInf{\mB\smi\mD}{x}$.
Note that $\init_B \not\in (q_1,...,q_k)$.
Let $\mP$ be the set of processes of \cutoffsys used in steps (e) or (f).
Note that $|\mP| = |(q_1,...,q_k)| + 1$.

The looping phase is: set $i=1$, and repeat infinitely the following.
\li
  \- let $P_\init \in \mP$ be the process that is currently in $\init_B$, 
     and $P_{q_i} \in \mP$ -- in $q_i$
     
  \- let $B_{q_i} \in \visInf{\mB\smi\mD}{x}$ be a process of \largesys 
     that visits $q_i$ and $\init_B$ infinitely often.
     Let $P_\init$ of \cutoffsys copy transitions of $B_{q_i}$
     on some path $\init_B \to \ldots \to g_i$,
     then let $P_{g_i}$ copy transitions of $B_{q_i}$ on some path 
     $g_i \to \ldots \to \init_B$. 
     For copying we consider only the paths of $B_{q_i}$ that happen after moment $d$.

  \- $i=i \oplus 1$
\il

The number of copies of $B$ that the construction uses in the worst case is 
(if ignore (g), assume $Q_B>2$, $DeadGuards \smi \dead = \emptyset$, and $A \in \mD$):
$$
1_{(f)} + 2|\deadTwo|_{(c),(d)} + |\deadOne|_{(b)} 
 \leq 
2|Q_B \smi \{\init_B\}| + 1.
$$

\myparagraph{Deadlocks}
The largest value of $c$ among those for ``Local Deadlocks'' 
and for ``Global Deadlocks'' can be used as the sought value of $c$ 
for the case of general deadlocks.
But it will not be the smallest one.
In the proof of the case ``Local Deadlocks'', in the setup phase, 
item (e) can be modified for the case when $A \in \mD$:
since we do not need to ensure that $y$ is infinite, 
we avoid allocating a process in state $\init_B$.
For a given locally deadlocked strong-fair run, the setup phase may produce
the globally deadlocked run, but that is allright for the case of general deadlocks.
With this note, for the general case $c = 2|Q_B \smi \{\init_B\}|$.
%
%\li
%  \-[a.] $y(A^1) = x(A^1)$
%  \-[b.] for each $q \in \deadOne(x)$: devote one process of \cutoffsys that mimics a process of \largesys that deadlocks in $q$\ak{replace `mimic' -- copy?}
%
%  \-[c1.] for each $q \in \deadTwo(x) \smi BlockStates$: devote two processes of \cutoffsys that mimic two processes of \largesys that deadlock in $q$
%  \-[c2.] for each $q \in \deadTwo(x) \cap BlockStates$: devote one processes of \cutoffsys that mimic one processes of \largesys that deadlocks in $q$
%  \-[d.] for each $q \in BlockStates$ devote one process of \cutoffsys that mimics a process $p_q$ that is in state $q$ at moment $d$. Note that such process in \largesys exists. 
%  
%  \-[e.] if $BlockStates \neq \emptyset$, then devote one process of \cutoffsys that stays in $\init$
%
%%   \-[d2.] Note \largesys has a process $p_q'$ different from $p_q$ from (d1) that enters $q$ infinitely often. Process $p_q'$ also visits $\init$ infinitely often. Thus, devote one process of \cutoffsys that stays in $\init$. Let $m_{qq}$ be some moment after 
%%   \li
%%     \-[d1.] if there is a process in \largesys that loops $q\to q$ infinitely often, then devote one process of \cutoffsys that mimics this process
%
%%     \- every process of \largesys that enters $q$ later exits $q$. Hence there are two processes of \largesys that meet in $q$ at some moment $m_{qq}$: devote two processes $p_1,p_2$ of \cutoffsys that mimic the behaviour of such processes till they meet in $q$ at the moment $m_{qq}$.
%%     Now observe that there is an infinite number of looping paths from $q \to \ldots\to q$ in the run $x$ by processes that enter $q$ and exit $q$ infinitely often.
%%     Starting from moment $m_{qq}$ interleave loopings between processes $p_1,p_2$, namely, start with $p_1$: stutter them both until some process of \largesys does the looping $q\to \ldots \to q$, and let process $p_1$ repeat that looping while keeping process $p_2$ in $q$.
%%     Now change turns: stutter them both until the moment when some process of \largesys does the looping $q \to \ldots \to q$, and let $p_2$ repeat the looping while keeping $p_1$ in state $q$. And so on.\ak{needs formalization}
%%   \il 
%
%  \-[f.] let any other process of \cutoffsys (if any) mimic a process of \largesys that was not used in the construction so far (including step (e))
%\il
%The setup phase ensures that in every state in $\dead(x)$ there is at least one process deadlocked at moment $d$ in $y$. Now we need to ensure that non-deadlocked processes described in step (d) move infinitely often.
%
%The looping phase applies to processes in (d) and (e) only. Order arbitrarily $BlockStates=(g1,\ldots,g_k)$. Then, set $i=1$, and repeat infinitely:
%\li
%  \- let $B^\init$ be the process from step (d) or (e) that is currently in $\init$, and $B^{g_i}$ is the one from (d) or (e) that is in $g_i$
%  \- in $x$ state $g_i$ is visited infinitely often by a process of \largesys that starts in $\init$. Hence, let $B^\init$ mimic that process on its loop from $\init \to \ldots\to g_i$, then let $B^{g_i}$ mimic that process on $g_i \to \ldots \to \init$
%  \- $i=i \oplus 1$
%\il
%The construction uses (if ignore (f)) assuming $Q_B>2$ and in the worst case (when $BlockStates$ is empty) $|\deadOne(x)| + 2|\deadTwo(x)| \leq 2|Q_B\smi \{ \init \}|$ processes B.
%
% The upper bound on the number of processes used in the construction of $y$ is $2(|BlockSet|-1) \leq 2|B|-2$.
%
% \input{other/disjoint-conj-dead-fair-proof-trial}
