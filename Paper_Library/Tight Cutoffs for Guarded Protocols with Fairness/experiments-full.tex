\section{Implementation and Experiments}
\label{sec:experiments}

We implemented our synthesis approach based on {\sc Party}~\cite{Khalimov13a}, 
a tool for parameterized synthesis of token rings. Our tool is written in 
Python and inherits from {\sc Party} the specification language and 
interfaces to automata translation tool LTL3BA~\cite{BabiakKRS12}. For generating and solving the SMT problem, we use the Python API of the solver Z3~\cite{Moura08}.

We synthesize guarded protocols using the following loop, for increasing 
bounds on the size of process templates:
\begin{enumerate}
\item \label{enum:experimentsAlgorithm:propertyInst} automatically detect 
cutoff and instantiate specification
\item \label{enum:experimentsAlgorithm:ltl3ba} call LTL3BA to convert 
specification into automaton
\item \label{enum:experimentsAlgorithm:enc} produce SMT encoding of bounded 
synthesis problem
\item call Z3: 
if SAT, return the model for process templates, else if UNSAT increase size bound and goto 1
% \begin{itemize}[leftmargin=*]
% \item if SAT, convert SMT model into process templates
% \item if UNSAT, increase size bound and goto 1
% \end{itemize}
\end{enumerate}

In the cutoff detection step, we apply the cutoff results from 
Section~\ref{sec:cutoffs} modularly, i.e., we calculate cutoffs and convert 
to universal co-Büchi tree automaton (UCT)\sj{remind/use long version} for every conjunct of the specification separately (an optimization 
mentioned in~\cite{KhalimovJB13b}). Finally, we produce the SMT encoding, 
conjoining the SMT constraints for all parts.

For our evaluation, we selected one example for each guard type, and synthesized valid implementations, starting from an initial bound of 2 for each template. We analyzed the impact of cutoffs by comparing the algorithm's runtime for synthesis with and without cutoffs with respect to an increasing number of instances. In both cases, we used the symmetry observation for encoding the properties, e.g., in a system with 4 processes the property $\bigwedge_i \always(r_i \rightarrow \eventually g_i)$ is instantiated to $\always(r_1 \rightarrow \eventually g_1)$ instead of  $\always(r_1 \rightarrow \eventually g_1) \wedge \dots \wedge \always(r_4 \rightarrow \eventually g_4)$. \sa{Label vs. state -- should be no difference here}

The experiments were done on a Linux machine with a 3.5GHz Intel i7 CPU and 4GB RAM, where a single core was assigned to the synthesis task. Table~\ref{table:experimentsRuntimes} provides the runtimes resulting from our experiments.
\sj{table needs to be explained, or removed}
We observe for each guard type that the runtime increases rapidly regarding the system size $n$. Applying cutoffs entails an upper bound for the the runtime, making the synthesis of large systems feasible. This upper bound is reached for system size $n=2$ and $n=4$ for the conjunctive guarded system, respectively, and system size $n=4$ for disjunctive guarded system. Moreover, we observe that applying cutoffs yields a runtime reduction for $n \geq 2$ in case of our conjunctive guarded system, and $n=4$ in case of disjunctive guarded system.

\begin{table}
\centering
\caption{Impact of using cut-offs on runtime $[s]$, timeout=90min.\sa{TODO}}
\label{table:experimentsRuntimes}
\begin{tabular}{c|c|c|c|c|c|c|c|c}
    & \multicolumn{2}{c|}{\multirow{2}{*}{Disjunctive Guards}} & \multicolumn{4}{c}{Conjunctive Guards} \\\cline{4-9}
    & \multicolumn{2}{c|}{} & \multicolumn{2}{c|}{Example 1} & \multicolumn{2}{c}{Example 2} & \multicolumn{2}{c}{Example 3} \\\hline
$n$ & w/o cut-offs & with cut-offs & w/o cut-offs & with cut-offs & w/o cut-offs & with cut-offs & w/o cut-offs & with cut-offs \\\hline
% 1 & $2.0$   & $2.0$     & $-$    & $-$     \\\hline         & $-$      \\\hline        
2 & \multicolumn{2}{c|}{1.52}      & 2.08    & 0.99   & 5.75    & 5.75  & 26.6    & 12.1   \\\hline 
3 & \multicolumn{2}{c|}{4.1}       & 8.79    & 0.99   & 88.3    & 18.7  & 590.5   & 40.4   \\\hline
4 & \multicolumn{2}{c|}{12.1}      & 42.2    & 0.99   & 369.3   & 105.1 & TIMEOUT & 219.2  \\\hline
5 & 41.177    & 23.15              & 230     & 0.99   & 3240    & 105.1 & TIMEOUT & 219.2  \\\hline
6 & 149.83    & 23.15              & 2113    & 0.99   & TIMEOUT & 105.1 & TIMEOUT & 219.2  \\\hline
7 & 481.06    & 23.15              & TIMEOUT & 0.99   & TIMEOUT & 105.1 & TIMEOUT & 219.2  \\\hline
8 & 1650      & 23.15              & TIMEOUT & 0.99   & TIMEOUT & 105.1 & TIMEOUT & 219.2  \\\hline
9 & TIMEOUT   & 23.15              & TIMEOUT & 0.99   & TIMEOUT & 105.1 & TIMEOUT & 219.2  \\\hline
\end{tabular}
%\vspace{-13pt}
\end{table}

%\begin{table}
%\centering
%\caption{Impact of synthesizing label-based guards on runtime of conjunctive guards synthesis $[s]$, timeout=90min.}
%\label{table:experimentsGuardTypeRuntimes}
%\begin{tabular}{c|c|c}
%$n$  & state guards    & label guards  \\\hline
%% 1    & $-$             & $-$           \\\hline
%2    & $10.7$          & $8.5$         \\\hline
%3    & $1090$          & $79.3$        \\\hline
%4    & TIMEOUT         & $1040$        \\\hline
%% 5    & TIMEOUT         & TIMEOUT       \\\hline
%\end{tabular}
%\end{table}


\subsection{Disjunctive Guards}

We consider instances of a closed system $(U_1, U_2)^{(1, n)}$. The first process template has an output signal $w$, the second -- $g$. 
The specification is 
$\GF(\neg w) \wedge \GF w \wedge \bigwedge_{i} \left[\GF(w \wedge g_i) \wedge  \GF g_i \wedge \GF(\neg g_i) \right]$.
%  
\begin{figure}[ht]
\vspace{-10pt} 
\centering
\scalebox{0.75}{\input{img/disjunctive_lts}}
\caption{Example: Disjunctive Guarded Implementation}
\label{fig:disjunctiveLTS}
\vspace{-10pt} 
\end{figure}
Figure~\ref{fig:disjunctiveLTS} shows an implementation synthesized.
For this example, the deadlock detection cutoff for $U_2$ is $3$. Cutoffs for single-indexed and double-indexed properties of the specification are $4$.
Therefore, we observe no runtime differences when comparing synthesis with cutoffs and synthesis without cutoffs for $n \leq 3$ instances of $U_2$ (see Table~\ref{table:experimentsRuntimes}). For $n=4$, the deadlock detection cutoff causes a runtime improvement. The maximum cutoff $c=4$ enables us to successfully synthesize systems for an arbitrary number of $U_2$ instances.
%The states $a^0$ and $b^0$ are the initial states of templates $U_1$ and $U_2$, while the states $a^1$ and $b^1$ are the respective synchronization states. Process $U_1
%One the one hand, process $U_1^1$ can enter its synchronization state $t_1^1$ without any restrictions, but can only move back to the initial state if there is at least one instance of $U_2$ in a synchronization state $t_2^1$. On the other hand, $U_2$ processes can only move if the $U_1$ process is in its synchronization state. Thus, there must be at least one pair-wise synchronization every time the $U_1$ process enters $t_1^1$.  \sa{Description of templates necessary?}
%We managed to synthesize this under the following conditions: \ldots \sa{Insert graph here}

\subsection{Conjunctive Guards}
We consider a system $(U)^{(n)}$ with a single process template\ak{r u sure that cutoffs stay for one-template systems?}. We analyze the synthesis results for three different specifications.

In the first specification, each process has input $r$ (`request') and output $g$ (`grant'). 
The specification requires: i) `every request should be granted', ii) `there should be no spurious grants', and iii) mutual exclusion of grants. 
% Each process must respond to a request by finally setting the grant signal. 
% Besides guaranteeing mutual exclusion, spurious grants must be prevented.
% \begin{align*}
% &\bigwedge_i \always(r_i \wedge \sched_i \rightarrow \eventually g_i) \wedge \bigwedge_{i \neq j} \always(\neg(g_i \wedge g_j))\, \wedge\\ 
% &\bigwedge_i \always\left[g_i \rightarrow g_i \until (\neg g_i \weakuntil (r_i \wedge \sched_i))\right] \wedge\\
% &\bigwedge_i \neg\left[(\neg r_i \wedge \neg g_i) \until (\neg r_i \wedge g_i)\right]
% \end{align*}
% Predicate $\sched_i$ is used to specify that only requests which can be recognized by the process (i.e., if the process is scheduled) need to be granted.
% 
% \begin{figure}[ht]
\begin{figure}[Htb]
\centering
\subfloat[Example 1]{
\centering
\makebox[0.29\textwidth][c]{
\scalebox{0.85}{\input{img/mutual_exclusion_lts}}
\label{fig:conjunctiveLTS1}
}}
\qquad
\subfloat[Example 2]{
\makebox[0.28\textwidth][c]{
\scalebox{0.85}{\input{img/mutual_exclusion2_lts}}
\label{fig:conjunctiveLTS2}
}}
\qquad
\subfloat[Example 3]{
\makebox[0.28\textwidth][c]{
\scalebox{0.85}{\input{img/mutual_exclusion3_lts}}
\label{fig:conjunctiveLTS3}
}}
%
\caption{Conjunctive Guarded Implementations}
\label{fig:conjunctiveLTS}
\end{figure}

Figure~\ref{fig:conjunctiveLTS1} shows an implementation synthesized.
%$t_0$ denotes the initial state. Consider a certain process $i$. Whenever the process is scheduled and the request signal $r_i$ is set, the transition to state $t_1$ is enabled. Thus, the process moves to $t_1$ and remains in this state as long as the guard $\{t_0, t_1\}$ is not satisfied, i.e., if there is at least on other process in the critical state $t_2$. Eventually all other processes are either in $t_0$ or in $t_1$, and process $i$ moves from $t_1$ to $t_2$, thus grants the request it received in state $t_0$. The grant signal $g_i$ is set until process $i$ is scheduled again, then it moves back to the initial state, where $g_i$ is false. The example requires at least three states. %\sa{Insert graph here}
%We managed to synthesize this under the following conditions: \ldots
The evaluation results for conjunctive guarded systems show that the bound independent property cutoffs are of benefit for the runtime also if small systems are synthesized. Also, the problem complexity does not increase if additional processes are added to systems of size $n\geq 3$, the deadlock-detection cutoff. \sa{Compare to mutual exclusion without spurious.}
The runtime improvement for $n=2$ is due to the modularly applied constant cutoffs for single-indexed ($c=1$), and double-indexed properties 
($c=2$), respectively (see Lemma~\ref{le:FairConjunctiveBounding Lemma}).
%

The second example defines one request signals $r$, and a two grant signals $g_1$, and $g_2$. The properties are as follows: i) `every request $r$ should finally be granted by $g_1$, followed by $g_2$', ii) `there should be no spurious grants', iii) `mutual exclusion of grants'.
%
Figure~\ref{fig:conjunctiveLTS2} shows an implementation synthesized. The cutoff for single-indexed and double-indexed properties is 1, and 2, respectively. The deadlock detection cutoff is $c=3$.

The third example defines two request signals $r_1$, $r_2$, and a two grant signals $g_1$, and $g_2$. The properties are as follows: i) `every request $r_1$ should finally be granted ($g_1$)', ii) `every request $r_2$ should finally be granted ($g_2$) unless resource 1 is requested ($r_1$)', iii) `there should be no spurious grants', `mutual exclusion of grants'. Figure~\ref{fig:conjunctiveLTS3} shows an implementation which satisfies the given specification. As before, we use the constant cutoffs for single-indexed and double-indexed properties, and the deadlock detection cutoff $c=3$.

%Finally, we compared the performance of the synthesis algorithm wrt. guards based on i) labels and ii) on states, as mentioned in Section~\ref{sec:adapted}. We observed a speed-up of an order of magnitude when only considering label-based guards, but thus far have only evaluated it on the single example above.

% we analyzed the impact of the optional optimization mentioned in Section~\ref{sec:adapted}, comparing the performance of our synthesis algorithm regarding guards based on labels and guards based on states. 
% The runtime results in  show significant speed-ups, albeit we have thus far only tested the optimization for this single example. %By contrast, we do not profit from this optimization if the number of possible label assignments exceeds the number of states.
