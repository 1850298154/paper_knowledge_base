Parallel execution of transactional workloads under determinism and conflict constraints naturally gives rise to classical combinatorial optimization problems in multiprocessor scheduling and packing. In this work, blockchain execution serves as a motivating application domain in which such constraints arise explicitly and at scale. Similar constraints for replica determinism have long been studied in dependable and replicated systems, where concurrent workloads must produce identical outcomes across replicas to ensure state consistency~\cite{jimenez2000deterministic_scheduling}.

At its core, OBS is a precedence-constrained makespan scheduling problem on identical processors $\left(P|prec|C_{max}\right)$. %,  where dependencies restrict overlap. Classic results show that m
Multiprocessor scheduling with precedence and resource constraints is NP-hard in general~\cite{ullman1973NPcompletescheduling,GareyandJohnson1975complexity_results}, %which explains why exact optimization quickly becomes intractable for realistic block sizes and why practical methods rely on heuristics or approximations. On the positive side, a
which explains why exact optimization becomes intractable for realistic block sizes and motivates heuristic or approximate approaches. A standard scalable approach is list scheduling, %the classic $\left(2-1/p\right)$ performance guarantee attributed to Graham’s analysis
with $(2-1/p)$ approximation ratio~\cite{graham1966bounds,graham1969bounds}. %While this bound strictly applies to list scheduling without additional resource conflicts, it motivates greedy event-driven schedulers as practical baselines even when optimal solutions are intractable. 
Although this bound applies without additional resource conflicts, it motivates greedy event-driven schedulers as practical baselines when optimal solutions are infeasible. 
%
More broadly, the $P|prec|C_{max}$ literature shows that the structure of the precedence partial order %—chains, trees, series–parallel, interval or level orders—can drastically change the complexity class and the quality of approximation algorithms
%
can significantly affect complexity and approximability~\cite{prot2018survey_prec_structures,pinedo2016scheduling}. 
%
Our precedence DAGs arise from intersecting a total order with a symmetric conflict relation and do not align with known polynomial-time special cases, inheriting the general NP-hardness.
%Our precedence DAGs form a specific subclass generated by intersecting a total order with a symmetric conflict relation, which does not align with these standard special cases and therefore inherits the general NP-hardness rather than any of the known polynomial‑time pockets.
%In particular, the goal 
Our goal is thus to understand how simple, fast heuristics behave on realistic conflict structures and workload heterogeneity.


A defining constraint in blockchain execution is fixed-order determinism: correctness requires equivalence to a specific total order, not merely serializability to some order. Similar constraints arise in parallel state machine replication and deterministic transactional systems, where concurrency must respect an externally imposed total order~\cite{kotlaandDahlin2004highthroughputBFT,abadi2014deterministicdatabasesystems, Thomson2010determinism}. This motivates modeling concurrency as a precedence-constrained scheduling problem rather than allowing arbitrary reordering.

Several blockchain systems exploit parallelism to accelerate execution of an already ordered block. Speculative frameworks such as Block-STM~\cite{BlockSTM}, used in Diem~\cite{diemcodebase} and Aptos~\cite{aptoscodebase,aptoswhitepaper}, execute transactions optimistically in parallel and resolve conflicts via deterministic abort-and-retry against a preset transaction sequence. Related approaches such as BTM~\cite{anjana_AFT_Effecient_parallel_execution} use read/write-set hints to reduce aborts when access sets are known in advance. Other designs rely on explicit conflict declarations: Solana requires transactions to declare their access list, enabling the runtime (Sealevel~\cite{solanaSealevel}) to schedule non-overlapping transactions in parallel while serializing conflicts~\cite{yakovenko2017solana}. Object-centric execution follows a similar philosophy, representing state as objects and tracking object-level conflicts; Sui Lutris, in particular, exploits object-level access metadata to enable parallelism while resorting to consensus only when shared-object conflicts require total ordering~\cite{sui}. Across these designs (including recent systems such as Monad~\cite{monadParallelExecutionDocs2025}) parallelism is exploited opportunistically, but remains constrained by the prefix of the total order: a conflicting early transaction can stall later independent ones rather than being bypassed. OBS makes this restriction explicit by allowing any order-equivalent execution schedule, thereby formalizing the gap between opportunistic in-order parallelism and optimal makespan-minimizing execution under limited cores.

%Speculative frameworks like Block-STM~\cite{BlockSTM}, utilized by Diem~\cite{diemcodebase} and Aptos~\cite{aptoscodebase,aptoswhitepaper}, parallelize execution by dynamically discovering dependencies and resolving conflicts via deterministic abort-and-retry against a preset transaction sequence. Complementary approaches like BTM~\cite{anjana_AFT_Effecient_parallel_execution} utilize read/write-set hints to reduce execution aborts, consistent with settings where access sets are known prior to execution. These approaches focus on accelerating runtime execution for a fixed transaction order and do not address the algorithmic problem of selecting and scheduling transactions jointly under a hard time budget.

%Solana-class designs require each transaction (instruction) to declare in advance which accounts it will read and which it will write, allowing the runtime (Sealevel~\cite{solanaSealevel}) to detect conflicts and schedule non-overlapping transactions in parallel deterministically~\cite{yakovenko2017solana}. This “declared access” interface contrasts with purely speculative execution by enabling explicit pre-execution reasoning about conflicts. A closely related modern thread is object-centric execution, where the state is represented as objects and transactions carry explicit metadata about which objects they access; the system can then schedule transactions in parallel by tracking object-level conflicts. Sui Lutris, in particular, leverages object-level access structure to support parallelism while using consensus only when shared-object conflicts require total ordering~\cite{sui}.

A substantial body of work studies scheduling under conflict graphs. For unit-time jobs, conflict-graph scheduling reduces to graph coloring, while heterogeneous execution times break this equivalence~\cite{batchscheduleexecute}. Empirical studies highlight sensitivity to contention and workload structure~\cite{sathyaperi2025graphcolouring}, and measurements on Ethereum show conflict graphs dominated by hotspots, limiting achievable speedups~\cite{anjana_AFT_Effecient_parallel_execution,heimbach2023definftshinderblockchain,Biton2025conflictsgraphedethereum}. Complementary semantic analyses characterize when reordering is safe under read/write effects, abstracting away from optimization objectives such as makespan or resource-aware selection~\cite{bartoletti2020concurrentsmartcontractexecution,bartoletti2021transactionparallelisminblockchains}. Closely related classical models consider identical-machine scheduling with incompatibility graphs $P|G|C_{max}$, which is NP-hard in general~\cite{blazewicz1991schedulingincompatiblejobs,kowalczyk2017exact_parallel_conflicts,brauner2016scheduling_conflictgraph}, with exact and MILP-based methods applicable only at moderate scales~\cite{moura2025compact_conflicts}.



%A substantial body of work studies conflict graphs and deterministic scheduling derived from them. Hay and Friedman formalize conflict-graph scheduling, and observe that for unit-time transactions, the low-latency schedules correspond to graph coloring, while heterogeneous runtimes break this reduction~\cite{batchscheduleexecute}. Empirical studies evaluate conflict-graph-based schedulers (e.g., coloring-based phases), and highlight sensitivity to contention and workload structure~\cite{sathyaperi2025graphcolouring}. Measurements on Ethereum show conflict graphs are often skewed by hotspots, limiting achievable speedups~\cite{anjana_AFT_Effecient_parallel_execution,heimbach2023definftshinderblockchain,Biton2025conflictsgraphedethereum}. Complementary semantic work characterizes when reordering is safe under read/write effects, abstracting away from optimization objectives such as makespan or resource-aware selection~\cite{bartoletti2020concurrentsmartcontractexecution,bartoletti2021transactionparallelisminblockchains}. Closely related classical models study identical-machine scheduling with incompatibility graphs $P\mid G\mid C_{max}$, which is NP-hard in general~\cite{blazewicz1991schedulingincompatiblejobs,kowalczyk2017exact_parallel_conflicts,brauner2016scheduling_conflictgraph}, with exact and MILP-based methods applicable only to moderate instance sizes~\cite{moura2024compact_conflicts}. PBC builds on this structure, with the added features that jobs are optional and carry heterogeneous weights.


PBC builds on these models by jointly selecting and scheduling transactions under a hard runtime budget. It generalizes multiple knapsack~\cite{chekuri2005polynomial}, knapsack with conflict graphs~\cite{pferschy2009knapsack}, and parallel-machine scheduling with rejection~\cite{engels2003techniques_scheduling_rejection,jansen2010scheduling_rejection_parallel}. Unlike existing block construction pipelines, which are typically driven by greedy fee-based selection (e.g., gas price or fee per gas) and largely ignore parallelizability and interaction effects among transactions~\cite{neiheiser2025anthemiusefficientmodular}, our formulation explicitly captures the interaction between transaction selection, conflicts, heterogeneous execution times, and core-level makespan. To our knowledge, deployed block assembly pipelines do not incorporate parallelizability directly into transaction selection in a systematic way, making block construction the primary systems gap our work targets.



%PBC represents a joint selection-and-scheduling challenge that generalizes both the multiple knapsack problem~\cite{chekuri2005polynomial} and the strongly NP-hard knapsack problem with conflict graphs~\cite{pferschy2009knapsack}. It can also be viewed as combining parallel-machine scheduling with incompatibilities and scheduling with rejection~\cite{engels2003techniques_scheduling_rejection,jansen2010scheduling_rejection_parallel}. Unlike systems that utilize heuristic concurrency budgets for block construction~\cite{neiheiser2025anthemiusefficientmodular}, our approach explicitly models the interaction between transaction selection, conflicts, heterogeneous execution times, and core-level makespan.
%our approach explicitly models the interplay between transaction selection, core-level makespan, and execution-time heterogeneity. By evaluating these heuristics against MILP-derived baselines on real-world traces, we characterize the performance gap inherent in the joint problem of selecting weighted jobs under strict parallel execution budgets, a combination largely unaddressed in prior blockchain-specific settings.


%Most blockchain implementations that exploit parallelism do so only when executing an already ordered block. Systems such as Solana, Aptos (Block-STM), Diem, Sui, and recent designs like Monad execute transactions in parallel subject to conflict constraints, but still process them in consensus order: a conflicting early transaction can stall later independent ones rather than being bypassed~\cite{solanaSealevel,aptosParallelExec2025,monadParallelExecutionDocs2025}. OBS formalizes the stronger objective of minimizing makespan under limited cores while preserving equivalence to the consensus order, by allowing any order-equivalent schedule. This makes explicit the gap between opportunistic in-order parallelism in existing runtimes and optimal order-equivalent execution.


%Block construction, by contrast, is typically driven by greedy fee-based selection (e.g., gas price or fee per gas) and largely ignores parallelizability and interaction effects among transactions. PBC addresses this missing layer by jointly selecting and scheduling transactions under a hard runtime budget, accounting for conflicts, heterogeneous execution times, and core availability. To the best of our knowledge, no deployed protocol incorporates parallelizability directly into transaction selection, making block construction the primary systems gap our work targets.

