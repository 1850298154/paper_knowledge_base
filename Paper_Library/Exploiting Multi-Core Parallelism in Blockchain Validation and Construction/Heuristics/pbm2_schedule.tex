\begin{algorithm}[t!]
\caption{$\findschedulePtwo{}$ }
\label{heu:p2-schedule}
\footnotesize
\begin{multicols}{2}
\begin{algorithmic}[1]
\Function{$\findschedulePtwo{T, p, B, \priority, \conflicts}$}{}
  \State $now \gets 0$
  \State $free \gets [1..p]$ \Comment{Free cores}
  \State $running \gets \emptyset$ \Comment{Trans. running}
  \State $\selected \gets \emptyset$ \Comment{Trans. completed}
  \State $ready \gets T$ \Comment{Pending transactions}
    \State $\deferred \gets \emptyset$ \Comment{Conflicting with running}
  \Repeat
    \While{$(ready \setminus \deferred \neq \emptyset) \land (free \neq \emptyset)$}
        \State $\tau \gets \arg \min \{ \priority{[\tau']} :$ \\
        \hspace{3cm} $\tau' \in ready \setminus \deferred \}$
        \If{$(running \cap \conflicts{[\tau]} \neq \emptyset)$}
            \State $\deferred \gets \deferred \cup \{\tau\}$
            \State \textbf{continue}
        \EndIf
        \State $ready \gets ready \setminus \{\tau\}$
%      \State $\tau \gets \textsc{TOP}(ready)$
        \If{$now + \executiontime{\tau} > B$}
%        \State $\tau \gets \textsc{POP}(ready)$
        \State \textbf{continue}
      \EndIf
      \State $running \gets running \cup \{\tau\}$
      \State $\selected \gets \selected \cup \{\tau\}$
%      \State $T \gets T \setminus \{\tau\}$
      \State $\start{[\tau]} \gets now$
      \State $\finish{[\tau]} \gets now + \executiontime{\tau}$
      \State $\core{[\tau]} \gets$ any element in $free$
      \State $free \gets free \setminus \{\core{[\tau]}\}$
    \EndWhile
%    \If{$running \neq \emptyset$}
    \State $now \gets \min\{\finish{[\tau]} : \tau \in running\}$
    \State $S \gets \{\tau \in running \;:\; \finish{[\tau]} = now\}$
    \State $running \gets running \setminus S$
    \For{\textbf{each} $\tau \in S$}
        \State $free \gets free \cup \{\core{[\tau]}\}$
        \State $\deferred \gets \deferred \setminus \conflicts{[\tau]}$
    \EndFor
%           \For{\textbf{each } $\tau' : \mathrm{conflict}(\tau,\tau')$} 
%               \State $\degree{[\tau']} \gets \degree{[\tau']}-1$
%               \State $s[\tau'] \gets \frac{\rho[\tau']}{\degree{[\tau']}+1}$
%               \State $\priority{[\tau']} \gets (-s[\tau'],-\rho[\tau'],-\reward{\tau'},\degree{[\tau']},\id{\tau'})$
%           \EndFor
%         \EndFor
% %    \EndIf

%     \For{\textbf{each } $\tau \in defer$}
%       \State $ready \gets ready \cup \{\tau\}$
%     \EndFor
    \Until{$(running = \emptyset) \land (ready = \emptyset)$}
    \State \textbf{return } $(\selected,\start,\core)$
\EndFunction
%     \State $\tau \gets \arg \min_{\tau' \in running} \{\finish{[\tau']}\}$
%     \State $now \gets \finish{[\tau]}$
%     \State $S \gets \emptyset$
%     \While{$running \neq \emptyset$ \textbf{and} $\text{Top}(running).\text{finish} = now$}
%       \State $(\_,\tau^\star,c^\star) \gets \textsc{ExtractMin}(running)$
%       \State $S \gets S \cup \{(\tau^\star,c^\star)\}$
%     \EndWhile
%     \State $free \gets free \cup \{\core{[\tau]}\}$
%     \For{\textbf{each } $(\tau,\tau') \in E$}
%         \State $\degree{[\tau']} \gets \degree{[\tau']}-1$
%         \State $s[\tau'] \gets \frac{\rho[\tau']}{\degree{[\tau']}+1}$ 
%         \State $\priority{[\tau']} \gets (-s[\tau'], -\rho[\tau'],-\reward{\tau'},+\degree{[\tau']},+\id{\tau'})$ 
%     \EndFor
%     \State $ready \gets ready \cup {defer}$
%   \Until{$(running = \emptyset) \land (ready = \emptyset)$ \textbf{ or } $now \ge B$}
%   \State
%   \State \textbf{return } $(\start,\core)$
% \EndFunction
\end{algorithmic}
\end{multicols}
\end{algorithm}
