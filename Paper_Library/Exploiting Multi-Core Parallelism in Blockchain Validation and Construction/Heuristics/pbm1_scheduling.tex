\begin{algorithm}[H]
\caption{$\findschedulePone{}$}%
\label{heu:scheduling_problem1}%
\footnotesize
\begin{multicols}{2}
\begin{algorithmic}[1]
\Function{$\findschedulePone{T, p, \priority, \indegree, \successor}$}{}
    \State $now \gets 0$
    \State $free \gets [1..p]$ \Comment{Free cores}
    \State $running \gets \emptyset$ \Comment{Trans.~that are running}
    \State $ready \gets \{\tau \in T: \indegree{[\tau]}=0\}$ \Comment{Ready tx}
    \Repeat
        \While{$(ready \neq \emptyset) \land (free \neq \emptyset)$}
            \State $\tau \gets \arg \min \{ \priority{[\tau']}: \tau' \in ready \}$
            \State $ready \gets ready \setminus \{\tau\}$
            \State $running \gets running \cup \{\tau\}$
            \State $\start{[\tau]} \gets now$
            \State $\finish{[\tau]} \gets now + \executiontime{\tau}$
            \State $\core{[\tau]} \gets$ any element in $free$
            \State $free \gets free \setminus \{\core{[\tau]}\}$
        \EndWhile
        \State $now \gets \min\{\finish{[\tau]} : \tau \in running\}$
        \State $S \gets \{\tau \in running \;:\; \finish{[\tau]} = now\}$
        \State $running \gets running \setminus S$
        \For{\textbf{each} $\tau \in S$}
        % \State $\tau \gets \arg \min_{\tau' \in running} \{\finish{[\tau']}\}$
        % \State $running \gets running \setminus \{\tau\}$
        % \State $now \gets \finish{[\tau]}$
        \For{\textbf{each} $\tau' \in \successor{[\tau]}$}
            \State $\indegree{[\tau']} \gets \indegree{[\tau']} - 1$
            \If{$\indegree{[\tau']} = 0$} 
                \State $ready \gets ready \cup \{\tau'\}$
            \EndIf
        \EndFor
        \State $free \gets free \cup \{\core{[\tau]}\}$
        \EndFor
    \Until{$(running = \emptyset) \land (ready = \emptyset)$}
    \State \textbf{return} $(\start, \core)$
\EndFunction
\end{algorithmic}
\end{multicols}
\end{algorithm}
    % \While{$(ready \neq \emptyset) \land (free \neq \emptyset)$}
    %         \State $\tau \gets \arg \min_{\tau' \in ready} \{\priority{[\tau']}\}$
    %         \State $ready \gets ready \setminus \{\tau\}$
    %         \State $running \gets running \cup \{\tau\}$
    %         \State $\start{[\tau]} \gets now$
    %         \State $\finish{[\tau]} \gets now + \executiontime{\tau}$
    %         \State $\core{[\tau]} \gets$ any element in $free$
    %         \State $free \gets free \setminus \{\core{[\tau]}\}$
    % \EndWhile
    % \State \textbf{return} $(\start, \core)$
    % \EndFunction

    %   \end{algorithmic}
    %   \end{algorithm}
      
    % \Function{SCHEDULE\_TRANSACTIONS}{T, succ, h v}
    %     \State $ready \leftarrow$ min-heap keyed by $K(i)$
    %     \For{$i \in T$}
    %         \If{$\indegree{i}=0$} \State insert $i$ into $ready$ \EndIf
    %     \EndFor
    %     \State $r \leftarrow 0$
    %     \While{$ready \neq \emptyset$}
    %         \State $r \leftarrow r+1$; \ $S \leftarrow \emptyset$
    %         \For{$c=1$ \textbf{to} $p$}
    %             \If{$ready=\emptyset$} \textbf{break} \EndIf
    %             \State $i \leftarrow$ extract-min($ready$); \ $S \leftarrow S \cup \{i\}$; \ $round(i) \leftarrow r$
    %         \EndFor
    %         \For{$i \in S$}
    %             \For{$j \in succ(i)$}
    %                 \State $\indegree(j) \leftarrow \indegree(j)-1$
    %                 \If{$\indegree(j)=0$} \State insert $j$ into $ready$ \EndIf
    %             \EndFor
    %         \EndFor
    %     \EndWhile
    %     \State \textbf{return} $round$
    %   \EndFunction

    % \Function{$\findschedule{T, p, \priority, \indegree, \successor}$}{}
    %     \State $now \gets 0$
    %     \State for each $i \in T$: $start[i]\leftarrow\bot$, $finish[i]\leftarrow\bot$, $core[i]\leftarrow\bot$
    %     \State for each $i \in T$: $\indegree{i} \gets |pred[i]|$
    %     \State $ready \gets$ min-heap keyed by $K(i)$ in lexicographic order
    %     \State $running \gets$ min-heap keyed by finish time
    %     \State $free \gets \{1,2,\dots,p\}$

    %     \For{\textbf{each} $i \in T$}
    %       \If{$\indegree{i}=0$} \State push $i$ into $ready$ \EndIf
    %     \EndFor

    %     \While{$ ready \neq \emptyset$ \textbf{and} $free \ne \emptyset$ }
    %         \State $i \gets \text{extract-min}(ready)$
    %         \State pick and remove any $c \in free$
    %         \State $core[i]\gets c$; \ $start[i]\gets now$; \ $finish[i]\gets now + \executiontime{i}$
    %         \State push $(finish[i], i, c)$ into $running$
    %     \EndWhile

    %     \While{$running \neq \emptyset$ \textbf{or} $ready \neq \emptyset$}
    %         \State $(t\_next, \_,\_) \gets$ extract-min($running$) \Comment{Advance to the next completion event}
    %         \State $now \gets t\_next$

            
    %         \State $S \gets \emptyset$ \Comment{Collect and finalize all jobs finishing at t\_next}
    %         \While{$running \neq \emptyset$ \textbf{and}  $\text{top}(running).\text{finish\_time} = now$}
    %             \State $(_,j,c) \gets$ extract-min($running$)
    %             \State add $(j,c)$ to $S$
    %         \EndWhile

    %         \For{ \textbf{each} $(j,c) \in S$}
    %             \State insert $c$ into $free$
    %         \EndFor
            
    %         \For{ \textbf{each} $(j,c) \in S$}
    %             \For{\textbf{each} $k \in succ(j)$}
    %                 \State $\indegree{k} \gets \indegree{k} -1$
    %                 \If{$\indegree{k}=0$}
    %                     \State push $k$ into $ready$
    %                 \EndIf
    %             \EndFor
    %         \EndFor

    %         \While{$ ready \neq \emptyset$ \textbf{and} $free \neq \emptyset$} 
    %             \State $i \gets$ extract-min($ready$)
    %             \State pick and remove any $c \in free$
    %             \State $core[i]\gets c$; \ $start[i]\gets now$; \ $finish[i]\gets now + \executiontime{i}$
    %             \State push $(\text{finish}[i], i,c)$ into $running$
    %         \EndWhile
        
    %     \EndWhile
    %     \State \textbf{return} $(start, core)$
    % \EndFunction

    %   \end{algorithmic}
    %   \end{algorithm}