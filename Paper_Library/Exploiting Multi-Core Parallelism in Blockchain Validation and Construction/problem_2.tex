\section{Parallel-Block Construction (PBC)} \label{sec:problem2}
We now turn to the block-construction problem. Given a
%We have a set of transactions in 
mempool $\mempool=\{\tau_1, \ldots, \tau_n\}$ of pending transactions, 
%the validator must select and schedule a subset of transactions that maximizes total reward while fitting within the block runtime limit~$B$.  To capture dependencies, 
we construct an undirected conflict graph $G=(\mempool,E)$ whose nodes correspond to the transactions in $\mempool$, with an edge $(\tau_i,\tau_j)\in E$ if and only if the two transactions conflict (as defined in \Cref{subsubsec:conflicts}).
%and there is a link from $\tau_i$ to $\tau_j$ (i.e., $(i,j) \in E$) if $\tau_i$ and $\tau_j$ have a conflict (explained in Section \ref{subsubsec:conflicts}). Each block has a maximum gas limit $B$, which is computed as the sum of the actual gas used by the transactions in the block.
The block runtime limit~$B$ and the conflicts must be respected in the schedule obtained for the transactions selected from $T$ to be included in the block.
%equals the total gas consumed by all selected transactions, i.e., the sum of their actual gas usage. 
This setting combines both \emph{selection} (which transactions to include) and \emph{scheduling} (how to assign them across cores) under dependency and time budget constraints.

\subsection{PCB MILP Formulations}

\subsubsection{Homogeneous Transactions}

\input{MILP/pbm2_milp_simple}

We first consider the homogeneous case, where all transactions have identical execution time~$t$. The block gas budget $B$ therefore allows at most  $R=\lfloor B/t \rfloor$ execution rounds. MILP~\ref{milp-pbm2-simple} formalizes the selection-and-scheduling problem for this setting. Here, $x_{ir}=1$ if and only if transaction~$\tau_i$ is selected and executed in round~$r$, yielding a validator reward $w_i := \reward{\tau_i}$ for its inclusion in the block.  
%$x_{ir}$ indicating whether transaction $\tau_i$ is scheduled in round $r$. 

The problem can be viewed as a weighted packing task: we fill each of the $R$ rounds with up to $p$ non-conflicting transactions, choosing the subset that maximizes total weight (i.e., reward $\sum_{i} w_i$)  while respecting both conflict and capacity constraints. 
%The selection-and-scheduling problem reduces to packing up to $p$ items per round, respecting conflict edges, while maximizing total weight $\sum_{i \in [n]} w_i$. Here, the weight $w_i$ of a transaction is the reward $\reward{\tau_i}$ the validator would get after successfully including transaction $\tau_i$ in the block.

%\smallskip
\textbf{Correctness.}
Constraint~\eqref{con:onetrans-s2} ensures that each transaction is scheduled at most once across all rounds.  
Constraint~\eqref{con:p-cores-s2} enforces the validator’s core capacity, limiting each round to at most $p$ concurrent transactions.  
Constraint~\eqref{con:conflict-s2} excludes conflicting pairs from being assigned to the same round, preserving deterministic execution semantics.  
Together, these constraints guarantee that every feasible solution corresponds to a conflict-free parallel schedule that fits within the gas budget.  
The objective~\eqref{obj:max-s2} then selects the optimal subset of transactions that maximizes total validator reward under these feasibility constraints.

\subsubsection{Heterogeneous Transactions}

\input{MILP/pbm2_milp_simple_and_complex}

We now extend to the case of transactions with heterogeneous execution times~$t_i$. 
MILP~\ref{milp-pbm2-simple&complex} jointly models transaction selection and parallel scheduling under conflicts, core capacity, and runtime constraints.  The binary variable $v_i$ determines whether transaction $\tau_i$ is selected to be included in a block. If selected ($v_i=1$), it must be assigned to exactly one core via~$x_{ic}$ and executed during the time window $[s_i, e_i]$ with duration $t_i$. Conflict edges $(i,j)\in E$ forbid temporal overlap between the conflicting transactions. Their mutual ordering is decided by $y_{ij}$, enforced through constraints \eqref{con:conflict1-c3}–\eqref{con:conflict2-c3}. For non-conflicting pairs, overlap is allowed unless they share a core. Same-core assignment is captured by $w_{ijc}$, the logical AND of $x_{ic}$ and $x_{jc}$, and $z_{ij}$ which flags whether a pair shares any core.
If $z_{ij}=1$, the pair must be serialized, with order selected by $y_{ij}$ as enforced in constraints \eqref{con:order1-c2}–\eqref{con:order2-c2}. The objective~\eqref{obj:max-c3}  maximizes the total weight $\sum_{i \in [n]} w_i v_i$ subject to gas and core limits, balancing which transactions are included and how they are scheduled.

\textbf{Correctness.} 
Constraint~\eqref{con:one-assignment-c3} ensures that every selected transaction occupies exactly one core, while \eqref{con:noneg-c3} and the activation bounds couple start and end times to the selection variable~$v_i$.  
Conflict pairs $(i,j)\in E$ are serialized via constraints~\eqref{con:conflict1-c3}–\eqref{con:conflict2-c3}, preventing overlapping execution regardless of order.  
For non-conflicting transactions, same-core co-assignment is detected by $w_{ijc}$ and summarized by $z_{ij}$; if $z_{ij}=1$, constraints~\eqref{con:order1-c2}–\eqref{con:order2-c2} enforce a valid ordering determined by $y_{ij}$.  
These constraints guarantee that all selected transactions can be executed within the gas limit~$B$ without violating conflict or resource dependencies.  
The objective then identifies the highest-reward feasible subset and schedule.



%\smallskip
\subsubsection{Complexity} Both the homogeneous (MILP~\ref{milp-pbm2-simple}) and heterogeneous (MILP~\ref{milp-pbm2-simple&complex}) formulations of PCB  generalize NP-hard problems such as weighted parallel-machine scheduling and multidimensional knapsack.  
The homogeneous formulation involves $\mathcal{O}(nR)$ binary variables and $\mathcal{O}(nR + |E|R)$ constraints, while the heterogeneous one expands to $\mathcal{O}(n^2p)$ binary variables and $\mathcal{O}(n^2p + |E|)$ constraints.  
Solver time thus grows sharply with block size and heterogeneity, motivating the use of fast approximation methods. 
%In the following, we introduce scalable heuristics that jointly select and schedule transactions under the same conflict and budget constraints.


\subsection{Heuristics}

%\input{Heuristics/pbm2_degree_from_dag}



\input{Heuristics/pbm2_schedule}





Our mempool heuristics (\Cref{heu:p2-score,heu:p2-schedule,heu:problem2}) greedily assemble a conflict-free parallel schedule of transactions under the runtime limit $B$. 
They combine lightweight scoring and event-driven dispatch to approximate the MILP objective efficiently.

%\begin{itemize}

    %\item 
    \noindent
    \textbf{Priority Scores:} For each transaction $\tau$ in the mempool, we compute its value density as $\rho[\tau] \coloneqq \frac{\reward{\tau}}{\executiontime{\tau}}$
    %and calculate a conflict-aware score $s$ as 
    %\begin{equation*}
    %$
        %s[\tau] \coloneqq \frac{\rho[\tau]}{\degree{[\tau]}+1},
    %$
    %\end{equation*}
     and $\degree{[\tau]}$ is the number of transactions with which $\tau$ conflicts.
    The composite priority key 
    $\priority{[\tau]} \coloneqq ( -\rho[\tau],\degree{[\tau]},-\reward{\tau},\id{\tau}),$
    favors high-reward, low-conflict transactions, breaking ties deterministically by~$\id{\tau}$.
    %high value-per-time on lightly connected nodes. The transaction id breaks ties deterministically.

    %\item 
    \noindent
    \textbf{Transaction Scheduling:} Using the priorities above, we iteratively dispatch transactions to free cores (\Cref{heu:p2-schedule}). At each step, the scheduler maintains three sets: \emph{ready} transactions (eligible for execution), \emph{running} transactions (currently executing), and a \emph{deferred} set of candidates that conflict with running ones. When a core becomes free, the highest-priority non-conflicting transaction is launched, provided the cumulative runtime used remains within~$B$. On each completion event, the corresponding transaction is removed from \emph{running}, its conflicts are cleared from \emph{deferred}, and its core is released.  
    This process continues until either the runtime budget or transaction pool is exhausted.  
    \Cref{heu:problem2} integrates both steps into a full end-to-end pipeline.
    %We maintain a set of ready transactions (by $\priority{}$) and a set of running jobs. Whenever one or more cores become free, we dispatch the best ready job till either there are no more feasible transactions to schedule or the gas limit $B$ is reached. This works for both simple-only and simple-complex transaction workloads.
%\end{itemize}


%\smallskip
\textbf{Complexity.}  The conflict graph construction has complexity $\mathcal{O}(n^2)$.
Computing transaction degrees and priorities has also complexity $\mathcal{O}(n^2)$.  
The event-driven scheduler then performs $\mathcal{O}(n \log n)$ priority operations plus $\mathcal{O}(np)$ updates for dispatch and completion across $p$ cores.  
Overall, the heuristic runs in polynomial time, dominated by graph construction and conflict detection.

\begin{figure*}[t!]
\centering

\begin{minipage}[t]{0.49\textwidth}

\input{Heuristics/pbm2_scoring}

\end{minipage}\hfill
\begin{minipage}[t]{0.49\textwidth}

\input{Heuristics/pbm2_main}

\end{minipage}

\end{figure*}