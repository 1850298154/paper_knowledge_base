
\section{System Model and Problems Definitions} \label{sec:problemstatement}

\subsection{Blockchains}

We model a blockchain as a distributed ledger that maintains a shared state and processes a continuous stream of client-submitted transactions. Pending transactions reside in a \textit{mempool} until they are selected for inclusion in a block. Each block is proposed by a designated \textit{validator} (or leader) that assembles transactions from the mempool, subject to 
%subject to a \textit{per-block gas limit}, i.e., an upper bound on the total gas used by the blockâ€™s transactions, and hence (under our model) 
an upper bound on block execution time.

%We assume a blockchain to which clients send transactions. These transactions will eventually be included in a block. Before that, they are maintained in a mempool.

%We assume that each block is created by a chosen \server that takes transactions from the mempool. Blocks have a predefined gas limit $B$ (computed as the sum of the actual gas used by the transactions in the block).

\subsection{Transactions}

%Transactions change the state of the blockchain. The state is a collection of state elements $E$, accounts (addresses) and storage slots with their values. 
%These elements can be accounts, smart contract variables (storage slots). We assume for simplicity that $E$ does not change (e.g., no new smart contract is defined).

We use the transaction model of Ethereum.
Each transaction $\tau$ has execution and fee parameters that govern how it is processed by the validator. 
When executed, $\tau$ consumes a certain amount of gas $\gasused{\tau}$. It also has a \emph{Priority Fee}, denoted $\tip{\tau}$, so that $\reward{\tau} = \gasused{\tau} \cdot \tip{\tau}$ is the reward to the validator that includes $\tau$ in a block.

% It has a \emph{Gas Limit}, denoted $\gaslimit{\tau}$, which is the maximum gas the sender authorizes the execution environment (EVM) to consume while executing the transaction. 
% It also has a \emph{Max Fee per Gas} and a \emph{Priority Fee}, denoted $\maxfee{\tau}$ and $\tip{\tau}$, respectively. 
% When executed, $\tau$ consumes a certain amount of gas $\gasused{\tau} \leq \gaslimit{\tau}$, and has a cost 
% $\cost{\tau}= \gasused{\tau} (\basefee + \tip{\tau}),$
% where $\basefee$ is the \emph{Base Fee}. This is a fee fixed by the protocol for all the transactions in a block as a function of the network congestion. It must hold that $\basefee + \tip{\tau} \leq \maxfee{\tau}$. From the transaction cost,
% $\gasused{\tau} \cdot \basefee$ is burnt\footnote{\textit{Burning} permanently removes the corresponding value from circulation, rather than transferring them to any participant. This mechanism helps control long-term inflation by offsetting newly issued rewards.}, while $\reward{\tau} = \gasused{\tau} \cdot \tip{\tau}$ is the reward to the validator.

\smallskip
\noindent We consider two execution-time regimes:
\begin{itemize}
\item  \textbf{Homogeneous} transactions with identical execution time (equivalently identical \gasused{\tau}).
\item  \textbf{Heterogeneous} transactions with varying execution times (equivalently varying \gasused{\tau}).
\end{itemize}

In Ethereum-like settings, simple transfers are often homogeneous, whereas smart contract transactions are typically heterogeneous.
%
We assume that when a transaction $\tau$ is issued, the client includes an \emph{access list} %$\accesslist{\tau}$ 
specifying the set of state keys (accounts and storage slots) $\readset{\tau}$ and $\writeset{\tau}$ that $\tau$ reads and writes, respectively. In practice, transfers typically access only a few keys (e.g., sender and receiver of cryptocurrency), whereas smart contract transactions may access many keys. 
%The access list of a transaction consists of a read set and a write set. So, for each transaction $\tau_i$, let $\readset{\tau_i}$ be the set of keys it \emph{reads} and $\writeset{\tau_i}$ the set of keys it \emph{writes} 
%(Here ``keys'' refer to accounts or contracts by address.)
%; a value transfer writes both sender and recipient balances.)

%We consider that two transactions have a conflict if their respective access lists have elements in common.

\textbf{Conflicts.}
We say that two transactions $\tau_i$ and $\tau_j$ conflict if and only if they access a common state key and at least one of them writes to it. I.e., read--read overlaps are not conflicts, but any overlap involving a write is. Formally,
\begin{align}
    \mathrm{conflict}(\tau_i,\tau_j) \equiv \Big( (\writeset{\tau_i}\cap \writeset{\tau_j}) \cup (\writeset{\tau_i}\cap \readset{\tau_j}) \cup (\readset{\tau_i}\cap\writeset{\tau_j}) \Big) \neq\varnothing. & \label{subsubsec:conflicts}
\end{align}
%

%(In practice, when it is unclear the type of access to a state key, we conservatively treat the access as a write, yielding a potential over-estimation of conflicts.)


\subsection{Problems Definitions}
Our goal is to exploit multi-core hardware to validate and execute transactions efficiently while preserving blockchain semantics.
%, by minimizing execution time when the block is fixed and maximizing validator reward subject to a runtime limit when constructing a block.
% We study two complementary settings:
% %The objective is to maximize the level of parallelism in the validation of the transactions of a block. To do that, there are these possibilities:
% \begin{enumerate}
%     \item \textbf{Fixed-order execution.} The validator receives a block of transactions to validate. The validator can execute non-conflicting transactions in parallel, while conflicting transactions must follow the block order.
%     %\item The validator receives a set of transactions to validate without a particular order. The validator can run non-conflicting transactions in parallel, and conflicting transactions can be run in any order.
%     \item \textbf{Block construction.} The chosen validator assembles a new block by selecting transactions from the mempool. The validator decides both which transactions to include and how to schedule them.
% \end{enumerate}
%
We assume a validator has an execution environment that can process up to $p$ transactions in parallel, where $p$ is the number of CPU cores of the validator.
%
We also assume that the time to execute a transaction $\tau$ is proportional to its gas consumption, which we model as exactly $\gasused{\tau}$.
%
Then, we can define:

\begin{definition}[Schedule]
A schedule $S$ of a set of transactions $T$ on $p$ cores assigns to each transaction in $T$ a core and a starting time to run.  
    Given a schedule $S$ of a set of transactions $T$ on $p$ cores, its \emph{makespan}, denoted $\makespan{S}$, is the time to complete the execution (without preemption) of all transactions in $T$ as defined by the schedule $S$.
\end{definition}

We now formalize the two problems.

\begin{problem}
\label{prb:block}
\textbf{Ordered-Block Scheduling (OBS):} Given a block with the sequence of transactions $T=(\tau_1, \ldots, \tau_n)$, find a schedule $S$ of the transactions in $T$ on $p$ cores, that minimizes makespan $\makespan{S}$, subject to the constraint that conflicting transactions are not executed in parallel, and they are executed in the order of the sequence. 
\end{problem}

\begin{problem}
\label{prb:mpool}
\textbf{Parallel-Block Construction (PBC):} Given a runtime limit $B$ and a set of transactions in the mempool $\mempool=\{\tau_1, \ldots, \tau_n
\}$, select a subset of transactions $T \subseteq \mempool$ and a schedule $S$ of $T$ on $p$ cores such that: conflicting transactions are not executed in parallel,  $\makespan{S} \leq B$, and the total reward $\reward{T}=\sum_{\tau \in T} \reward{\tau}$ is maximized.
\end{problem}

%We now formalize the two problems introduced above, presenting exact MILP formulations that capture their constraints precisely, and fast deterministic heuristics that scale to realistic workloads. 

%Section~\ref{sec:problem1} develops these models and heuristics for fixed-order block execution, and Section~\ref{sec:problem2} does so for block construction under gas and reward constraints.